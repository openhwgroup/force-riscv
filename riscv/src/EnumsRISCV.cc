//
// Copyright (C) [2020] Futurewei Technologies, Inc.
//
// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
// FIT FOR A PARTICULAR PURPOSE.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/*  !!! NOTICE !!!
    This file is automatically generated by the script: utils/enum_classes/create_enum_files.py
    Please do not modify this file manually.  Instead, modify the above mentioned script to re-generate this file.
*/

#include <EnumsRISCV.h>

#include <GenException.h>

#include <sstream>

using namespace std;

namespace Force {


  /*!
    Report an unknown enum value of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
  */
  static void unknown_enum_value(const string& enum_type_name, unsigned long long value)
  {
    stringstream err_stream;
    err_stream << "Unknown " << enum_type_name << " enum value: " << dec << value;
    throw EnumTypeError(err_stream.str());
  }

  /*!
    Report an unknown enum name of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
  */
  static void unknown_enum_name(const string& enum_type_name, const string& enum_name)
  {
    stringstream err_stream;
    err_stream << "Unknown " << enum_type_name << " enum name: " << enum_name;
    throw EnumTypeError(err_stream.str());
  }

  /*!
    Throw an exception if in_str and enum_name are not identical.
  */
  static void validate(const string& specified_enum_name, const string& expected_enum_name, const string& enum_type_name)
  {
    if (specified_enum_name != expected_enum_name) {
      unknown_enum_name(enum_type_name, specified_enum_name);
    }
  }


  unsigned char ERegReserveGroupSize = 4;

  const string ERegReserveGroup_to_string(ERegReserveGroup in_enum)
  {
    switch (in_enum) {
    case ERegReserveGroup::GPR: return "GPR";
    case ERegReserveGroup::FPRSIMDR: return "FPRSIMDR";
    case ERegReserveGroup::VECREG: return "VECREG";
    case ERegReserveGroup::SystemRegister: return "SystemRegister";
    default:
      unknown_enum_value("ERegReserveGroup", (unsigned char)(in_enum));
    }
    return "";
  }

  ERegReserveGroup string_to_ERegReserveGroup(const string& in_str)
  {
    string enum_type_name = "ERegReserveGroup";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "FPRSIMDR", enum_type_name);
      return ERegReserveGroup::FPRSIMDR;
    case 71:
      validate(in_str, "GPR", enum_type_name);
      return ERegReserveGroup::GPR;
    case 83:
      validate(in_str, "SystemRegister", enum_type_name);
      return ERegReserveGroup::SystemRegister;
    case 86:
      validate(in_str, "VECREG", enum_type_name);
      return ERegReserveGroup::VECREG;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERegReserveGroup::GPR;
  }

  ERegReserveGroup try_string_to_ERegReserveGroup(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FPRSIMDR");
      return ERegReserveGroup::FPRSIMDR;
    case 71:
      okay = (in_str == "GPR");
      return ERegReserveGroup::GPR;
    case 83:
      okay = (in_str == "SystemRegister");
      return ERegReserveGroup::SystemRegister;
    case 86:
      okay = (in_str == "VECREG");
      return ERegReserveGroup::VECREG;
    default:
      okay = false;
      return ERegReserveGroup::GPR;
    }
    return ERegReserveGroup::GPR;
  }


  unsigned char EVmRegimeTypeSize = 4;

  const string EVmRegimeType_to_string(EVmRegimeType in_enum)
  {
    switch (in_enum) {
    case EVmRegimeType::M: return "M";
    case EVmRegimeType::S: return "S";
    case EVmRegimeType::HS: return "HS";
    case EVmRegimeType::VS: return "VS";
    default:
      unknown_enum_value("EVmRegimeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmRegimeType string_to_EVmRegimeType(const string& in_str)
  {
    string enum_type_name = "EVmRegimeType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      validate(in_str, "HS", enum_type_name);
      return EVmRegimeType::HS;
    case 77:
      validate(in_str, "M", enum_type_name);
      return EVmRegimeType::M;
    case 83:
      validate(in_str, "S", enum_type_name);
      return EVmRegimeType::S;
    case 86:
      validate(in_str, "VS", enum_type_name);
      return EVmRegimeType::VS;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmRegimeType::M;
  }

  EVmRegimeType try_string_to_EVmRegimeType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      okay = (in_str == "HS");
      return EVmRegimeType::HS;
    case 77:
      okay = (in_str == "M");
      return EVmRegimeType::M;
    case 83:
      okay = (in_str == "S");
      return EVmRegimeType::S;
    case 86:
      okay = (in_str == "VS");
      return EVmRegimeType::VS;
    default:
      okay = false;
      return EVmRegimeType::M;
    }
    return EVmRegimeType::M;
  }


  unsigned char EMemBankTypeSize = 1;

  const string EMemBankType_to_string(EMemBankType in_enum)
  {
    switch (in_enum) {
    case EMemBankType::Default: return "Default";
    default:
      unknown_enum_value("EMemBankType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemBankType string_to_EMemBankType(const string& in_str)
  {
    string enum_type_name = "EMemBankType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      validate(in_str, "Default", enum_type_name);
      return EMemBankType::Default;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemBankType::Default;
  }

  EMemBankType try_string_to_EMemBankType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      okay = (in_str == "Default");
      return EMemBankType::Default;
    default:
      okay = false;
      return EMemBankType::Default;
    }
    return EMemBankType::Default;
  }


  unsigned char EVmContextParamTypeSize = 10;

  const string EVmContextParamType_to_string(EVmContextParamType in_enum)
  {
    switch (in_enum) {
    case EVmContextParamType::MODE: return "MODE";
    case EVmContextParamType::MPRV: return "MPRV";
    case EVmContextParamType::MPP: return "MPP";
    case EVmContextParamType::SPP: return "SPP";
    case EVmContextParamType::MXR: return "MXR";
    case EVmContextParamType::SUM: return "SUM";
    case EVmContextParamType::MBE: return "MBE";
    case EVmContextParamType::SBE: return "SBE";
    case EVmContextParamType::UBE: return "UBE";
    case EVmContextParamType::TVM: return "TVM";
    default:
      unknown_enum_value("EVmContextParamType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmContextParamType string_to_EVmContextParamType(const string& in_str)
  {
    string enum_type_name = "EVmContextParamType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "MODE", enum_type_name);
      return EVmContextParamType::MODE;
    case 3:
      validate(in_str, "SPP", enum_type_name);
      return EVmContextParamType::SPP;
    case 4:
      validate(in_str, "MPRV", enum_type_name);
      return EVmContextParamType::MPRV;
    case 8:
      validate(in_str, "MBE", enum_type_name);
      return EVmContextParamType::MBE;
    case 16:
      validate(in_str, "UBE", enum_type_name);
      return EVmContextParamType::UBE;
    case 22:
      validate(in_str, "SBE", enum_type_name);
      return EVmContextParamType::SBE;
    case 25:
      validate(in_str, "TVM", enum_type_name);
      return EVmContextParamType::TVM;
    case 29:
      validate(in_str, "MPP", enum_type_name);
      return EVmContextParamType::MPP;
    case 30:
      validate(in_str, "SUM", enum_type_name);
      return EVmContextParamType::SUM;
    case 31:
      validate(in_str, "MXR", enum_type_name);
      return EVmContextParamType::MXR;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmContextParamType::MODE;
  }

  EVmContextParamType try_string_to_EVmContextParamType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "MODE");
      return EVmContextParamType::MODE;
    case 3:
      okay = (in_str == "SPP");
      return EVmContextParamType::SPP;
    case 4:
      okay = (in_str == "MPRV");
      return EVmContextParamType::MPRV;
    case 8:
      okay = (in_str == "MBE");
      return EVmContextParamType::MBE;
    case 16:
      okay = (in_str == "UBE");
      return EVmContextParamType::UBE;
    case 22:
      okay = (in_str == "SBE");
      return EVmContextParamType::SBE;
    case 25:
      okay = (in_str == "TVM");
      return EVmContextParamType::TVM;
    case 29:
      okay = (in_str == "MPP");
      return EVmContextParamType::MPP;
    case 30:
      okay = (in_str == "SUM");
      return EVmContextParamType::SUM;
    case 31:
      okay = (in_str == "MXR");
      return EVmContextParamType::MXR;
    default:
      okay = false;
      return EVmContextParamType::MODE;
    }
    return EVmContextParamType::MODE;
  }


  unsigned char EBranchConditionTypeSize = 8;

  const string EBranchConditionType_to_string(EBranchConditionType in_enum)
  {
    switch (in_enum) {
    case EBranchConditionType::BEQ: return "BEQ";
    case EBranchConditionType::BNE: return "BNE";
    case EBranchConditionType::BLT: return "BLT";
    case EBranchConditionType::BLTU: return "BLTU";
    case EBranchConditionType::BGE: return "BGE";
    case EBranchConditionType::BGEU: return "BGEU";
    case EBranchConditionType::CBEQZ: return "CBEQZ";
    case EBranchConditionType::CBNEZ: return "CBNEZ";
    default:
      unknown_enum_value("EBranchConditionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EBranchConditionType string_to_EBranchConditionType(const string& in_str)
  {
    string enum_type_name = "EBranchConditionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 64:
      validate(in_str, "BGE", enum_type_name);
      return EBranchConditionType::BGE;
    case 69:
      validate(in_str, "BGEU", enum_type_name);
      return EBranchConditionType::BGEU;
    case 73:
      validate(in_str, "BNE", enum_type_name);
      return EBranchConditionType::BNE;
    case 84:
      validate(in_str, "BLTU", enum_type_name);
      return EBranchConditionType::BLTU;
    case 86:
      validate(in_str, "BEQ", enum_type_name);
      return EBranchConditionType::BEQ;
    case 87:
      validate(in_str, "CBNEZ", enum_type_name);
      return EBranchConditionType::CBNEZ;
    case 90:
      validate(in_str, "BLT", enum_type_name);
      return EBranchConditionType::BLT;
    case 92:
      validate(in_str, "CBEQZ", enum_type_name);
      return EBranchConditionType::CBEQZ;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EBranchConditionType::BEQ;
  }

  EBranchConditionType try_string_to_EBranchConditionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 64:
      okay = (in_str == "BGE");
      return EBranchConditionType::BGE;
    case 69:
      okay = (in_str == "BGEU");
      return EBranchConditionType::BGEU;
    case 73:
      okay = (in_str == "BNE");
      return EBranchConditionType::BNE;
    case 84:
      okay = (in_str == "BLTU");
      return EBranchConditionType::BLTU;
    case 86:
      okay = (in_str == "BEQ");
      return EBranchConditionType::BEQ;
    case 87:
      okay = (in_str == "CBNEZ");
      return EBranchConditionType::CBNEZ;
    case 90:
      okay = (in_str == "BLT");
      return EBranchConditionType::BLT;
    case 92:
      okay = (in_str == "CBEQZ");
      return EBranchConditionType::CBEQZ;
    default:
      okay = false;
      return EBranchConditionType::BEQ;
    }
    return EBranchConditionType::BEQ;
  }


  unsigned char EPteAttributeTypeSize = 12;

  const string EPteAttributeType_to_string(EPteAttributeType in_enum)
  {
    switch (in_enum) {
    case EPteAttributeType::Address: return "Address";
    case EPteAttributeType::IGNORED: return "IGNORED";
    case EPteAttributeType::RES0: return "RES0";
    case EPteAttributeType::SystemPage: return "SystemPage";
    case EPteAttributeType::RSW: return "RSW";
    case EPteAttributeType::DA: return "DA";
    case EPteAttributeType::G: return "G";
    case EPteAttributeType::U: return "U";
    case EPteAttributeType::X: return "X";
    case EPteAttributeType::W: return "W";
    case EPteAttributeType::R: return "R";
    case EPteAttributeType::V: return "V";
    default:
      unknown_enum_value("EPteAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPteAttributeType string_to_EPteAttributeType(const string& in_str)
  {
    string enum_type_name = "EPteAttributeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(6 < size ? 6 : 6 % size) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 49:
      validate(in_str, "RES0", enum_type_name);
      return EPteAttributeType::RES0;
    case 65:
      validate(in_str, "DA", enum_type_name);
      return EPteAttributeType::DA;
    case 68:
      validate(in_str, "IGNORED", enum_type_name);
      return EPteAttributeType::IGNORED;
    case 71:
      validate(in_str, "G", enum_type_name);
      return EPteAttributeType::G;
    case 82:
      validate(in_str, "R", enum_type_name);
      return EPteAttributeType::R;
    case 83:
      validate(in_str, "RSW", enum_type_name);
      return EPteAttributeType::RSW;
    case 85:
      validate(in_str, "U", enum_type_name);
      return EPteAttributeType::U;
    case 86:
      validate(in_str, "V", enum_type_name);
      return EPteAttributeType::V;
    case 87:
      validate(in_str, "W", enum_type_name);
      return EPteAttributeType::W;
    case 88:
      validate(in_str, "X", enum_type_name);
      return EPteAttributeType::X;
    case 98:
      validate(in_str, "SystemPage", enum_type_name);
      return EPteAttributeType::SystemPage;
    case 115:
      validate(in_str, "Address", enum_type_name);
      return EPteAttributeType::Address;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPteAttributeType::Address;
  }

  EPteAttributeType try_string_to_EPteAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(6 < size ? 6 : 6 % size) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 49:
      okay = (in_str == "RES0");
      return EPteAttributeType::RES0;
    case 65:
      okay = (in_str == "DA");
      return EPteAttributeType::DA;
    case 68:
      okay = (in_str == "IGNORED");
      return EPteAttributeType::IGNORED;
    case 71:
      okay = (in_str == "G");
      return EPteAttributeType::G;
    case 82:
      okay = (in_str == "R");
      return EPteAttributeType::R;
    case 83:
      okay = (in_str == "RSW");
      return EPteAttributeType::RSW;
    case 85:
      okay = (in_str == "U");
      return EPteAttributeType::U;
    case 86:
      okay = (in_str == "V");
      return EPteAttributeType::V;
    case 87:
      okay = (in_str == "W");
      return EPteAttributeType::W;
    case 88:
      okay = (in_str == "X");
      return EPteAttributeType::X;
    case 98:
      okay = (in_str == "SystemPage");
      return EPteAttributeType::SystemPage;
    case 115:
      okay = (in_str == "Address");
      return EPteAttributeType::Address;
    default:
      okay = false;
      return EPteAttributeType::Address;
    }
    return EPteAttributeType::Address;
  }


  unsigned char EPageGranuleTypeSize = 1;

  const string EPageGranuleType_to_string(EPageGranuleType in_enum)
  {
    switch (in_enum) {
    case EPageGranuleType::G4K: return "G4K";
    default:
      unknown_enum_value("EPageGranuleType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPageGranuleType string_to_EPageGranuleType(const string& in_str)
  {
    string enum_type_name = "EPageGranuleType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 71:
      validate(in_str, "G4K", enum_type_name);
      return EPageGranuleType::G4K;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPageGranuleType::G4K;
  }

  EPageGranuleType try_string_to_EPageGranuleType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 71:
      okay = (in_str == "G4K");
      return EPageGranuleType::G4K;
    default:
      okay = false;
      return EPageGranuleType::G4K;
    }
    return EPageGranuleType::G4K;
  }


  unsigned char EPageGenBoolAttrTypeSize = 12;

  const string EPageGenBoolAttrType_to_string(EPageGenBoolAttrType in_enum)
  {
    switch (in_enum) {
    case EPageGenBoolAttrType::FlatMap: return "FlatMap";
    case EPageGenBoolAttrType::InstrAddr: return "InstrAddr";
    case EPageGenBoolAttrType::Regulated: return "Regulated";
    case EPageGenBoolAttrType::ViaException: return "ViaException";
    case EPageGenBoolAttrType::Privileged: return "Privileged";
    case EPageGenBoolAttrType::Atomic: return "Atomic";
    case EPageGenBoolAttrType::CanAlias: return "CanAlias";
    case EPageGenBoolAttrType::ForceAlias: return "ForceAlias";
    case EPageGenBoolAttrType::ForceMemAttrs: return "ForceMemAttrs";
    case EPageGenBoolAttrType::ForceNewAddr: return "ForceNewAddr";
    case EPageGenBoolAttrType::NoDataAbort: return "NoDataAbort";
    case EPageGenBoolAttrType::NoInstrAbort: return "NoInstrAbort";
    default:
      unknown_enum_value("EPageGenBoolAttrType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPageGenBoolAttrType string_to_EPageGenBoolAttrType(const string& in_str)
  {
    string enum_type_name = "EPageGenBoolAttrType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 65:
      validate(in_str, "NoInstrAbort", enum_type_name);
      return EPageGenBoolAttrType::NoInstrAbort;
    case 70:
      validate(in_str, "FlatMap", enum_type_name);
      return EPageGenBoolAttrType::FlatMap;
    case 98:
      validate(in_str, "NoDataAbort", enum_type_name);
      return EPageGenBoolAttrType::NoDataAbort;
    case 100:
      validate(in_str, "InstrAddr", enum_type_name);
      return EPageGenBoolAttrType::InstrAddr;
    case 101:
      validate(in_str, "Regulated", enum_type_name);
      return EPageGenBoolAttrType::Regulated;
    case 103:
      validate(in_str, "Privileged", enum_type_name);
      return EPageGenBoolAttrType::Privileged;
    case 105:
      validate(in_str, "ForceAlias", enum_type_name);
      return EPageGenBoolAttrType::ForceAlias;
    case 109:
      validate(in_str, "ForceMemAttrs", enum_type_name);
      return EPageGenBoolAttrType::ForceMemAttrs;
    case 112:
      validate(in_str, "ViaException", enum_type_name);
      return EPageGenBoolAttrType::ViaException;
    case 115:
      validate(in_str, "CanAlias", enum_type_name);
      return EPageGenBoolAttrType::CanAlias;
    case 116:
      validate(in_str, "Atomic", enum_type_name);
      return EPageGenBoolAttrType::Atomic;
    case 119:
      validate(in_str, "ForceNewAddr", enum_type_name);
      return EPageGenBoolAttrType::ForceNewAddr;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPageGenBoolAttrType::FlatMap;
  }

  EPageGenBoolAttrType try_string_to_EPageGenBoolAttrType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 65:
      okay = (in_str == "NoInstrAbort");
      return EPageGenBoolAttrType::NoInstrAbort;
    case 70:
      okay = (in_str == "FlatMap");
      return EPageGenBoolAttrType::FlatMap;
    case 98:
      okay = (in_str == "NoDataAbort");
      return EPageGenBoolAttrType::NoDataAbort;
    case 100:
      okay = (in_str == "InstrAddr");
      return EPageGenBoolAttrType::InstrAddr;
    case 101:
      okay = (in_str == "Regulated");
      return EPageGenBoolAttrType::Regulated;
    case 103:
      okay = (in_str == "Privileged");
      return EPageGenBoolAttrType::Privileged;
    case 105:
      okay = (in_str == "ForceAlias");
      return EPageGenBoolAttrType::ForceAlias;
    case 109:
      okay = (in_str == "ForceMemAttrs");
      return EPageGenBoolAttrType::ForceMemAttrs;
    case 112:
      okay = (in_str == "ViaException");
      return EPageGenBoolAttrType::ViaException;
    case 115:
      okay = (in_str == "CanAlias");
      return EPageGenBoolAttrType::CanAlias;
    case 116:
      okay = (in_str == "Atomic");
      return EPageGenBoolAttrType::Atomic;
    case 119:
      okay = (in_str == "ForceNewAddr");
      return EPageGenBoolAttrType::ForceNewAddr;
    default:
      okay = false;
      return EPageGenBoolAttrType::FlatMap;
    }
    return EPageGenBoolAttrType::FlatMap;
  }


  unsigned char EPagingExceptionTypeSize = 6;

  const string EPagingExceptionType_to_string(EPagingExceptionType in_enum)
  {
    switch (in_enum) {
    case EPagingExceptionType::InstructionAccessFault: return "InstructionAccessFault";
    case EPagingExceptionType::LoadAccessFault: return "LoadAccessFault";
    case EPagingExceptionType::StoreAmoAccessFault: return "StoreAmoAccessFault";
    case EPagingExceptionType::InstructionPageFault: return "InstructionPageFault";
    case EPagingExceptionType::LoadPageFault: return "LoadPageFault";
    case EPagingExceptionType::StoreAmoPageFault: return "StoreAmoPageFault";
    default:
      unknown_enum_value("EPagingExceptionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPagingExceptionType string_to_EPagingExceptionType(const string& in_str)
  {
    string enum_type_name = "EPagingExceptionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(12 < size ? 12 : 12 % size);

    switch (hash_value) {
    case 70:
      validate(in_str, "StoreAmoPageFault", enum_type_name);
      return EPagingExceptionType::StoreAmoPageFault;
    case 97:
      validate(in_str, "InstructionPageFault", enum_type_name);
      return EPagingExceptionType::InstructionPageFault;
    case 99:
      validate(in_str, "InstructionAccessFault", enum_type_name);
      return EPagingExceptionType::InstructionAccessFault;
    case 115:
      validate(in_str, "StoreAmoAccessFault", enum_type_name);
      return EPagingExceptionType::StoreAmoAccessFault;
    case 116:
      validate(in_str, "LoadPageFault", enum_type_name);
      return EPagingExceptionType::LoadPageFault;
    case 117:
      validate(in_str, "LoadAccessFault", enum_type_name);
      return EPagingExceptionType::LoadAccessFault;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPagingExceptionType::InstructionAccessFault;
  }

  EPagingExceptionType try_string_to_EPagingExceptionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(12 < size ? 12 : 12 % size);

    switch (hash_value) {
    case 70:
      okay = (in_str == "StoreAmoPageFault");
      return EPagingExceptionType::StoreAmoPageFault;
    case 97:
      okay = (in_str == "InstructionPageFault");
      return EPagingExceptionType::InstructionPageFault;
    case 99:
      okay = (in_str == "InstructionAccessFault");
      return EPagingExceptionType::InstructionAccessFault;
    case 115:
      okay = (in_str == "StoreAmoAccessFault");
      return EPagingExceptionType::StoreAmoAccessFault;
    case 116:
      okay = (in_str == "LoadPageFault");
      return EPagingExceptionType::LoadPageFault;
    case 117:
      okay = (in_str == "LoadAccessFault");
      return EPagingExceptionType::LoadAccessFault;
    default:
      okay = false;
      return EPagingExceptionType::InstructionAccessFault;
    }
    return EPagingExceptionType::InstructionAccessFault;
  }


  unsigned char EVmConstraintTypeSize = 11;

  const string EVmConstraintType_to_string(EVmConstraintType in_enum)
  {
    switch (in_enum) {
    case EVmConstraintType::Existing: return "Existing";
    case EVmConstraintType::AddressError: return "AddressError";
    case EVmConstraintType::ReadOnly: return "ReadOnly";
    case EVmConstraintType::NoExecute: return "NoExecute";
    case EVmConstraintType::PrivilegedNoExecute: return "PrivilegedNoExecute";
    case EVmConstraintType::UnpriviligedNoExecute: return "UnpriviligedNoExecute";
    case EVmConstraintType::NoUserAccess: return "NoUserAccess";
    case EVmConstraintType::PageTable: return "PageTable";
    case EVmConstraintType::UserAccess: return "UserAccess";
    case EVmConstraintType::PageFault: return "PageFault";
    case EVmConstraintType::FlatMap: return "FlatMap";
    default:
      unknown_enum_value("EVmConstraintType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmConstraintType string_to_EVmConstraintType(const string& in_str)
  {
    string enum_type_name = "EVmConstraintType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 4:
      validate(in_str, "PageTable", enum_type_name);
      return EVmConstraintType::PageTable;
    case 22:
      validate(in_str, "PageFault", enum_type_name);
      return EVmConstraintType::PageFault;
    case 33:
      validate(in_str, "NoUserAccess", enum_type_name);
      return EVmConstraintType::NoUserAccess;
    case 37:
      validate(in_str, "AddressError", enum_type_name);
      return EVmConstraintType::AddressError;
    case 39:
      validate(in_str, "UserAccess", enum_type_name);
      return EVmConstraintType::UserAccess;
    case 40:
      validate(in_str, "PrivilegedNoExecute", enum_type_name);
      return EVmConstraintType::PrivilegedNoExecute;
    case 43:
      validate(in_str, "NoExecute", enum_type_name);
      return EVmConstraintType::NoExecute;
    case 44:
      validate(in_str, "Existing", enum_type_name);
      return EVmConstraintType::Existing;
    case 54:
      validate(in_str, "FlatMap", enum_type_name);
      return EVmConstraintType::FlatMap;
    case 58:
      validate(in_str, "UnpriviligedNoExecute", enum_type_name);
      return EVmConstraintType::UnpriviligedNoExecute;
    case 60:
      validate(in_str, "ReadOnly", enum_type_name);
      return EVmConstraintType::ReadOnly;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmConstraintType::Existing;
  }

  EVmConstraintType try_string_to_EVmConstraintType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 4:
      okay = (in_str == "PageTable");
      return EVmConstraintType::PageTable;
    case 22:
      okay = (in_str == "PageFault");
      return EVmConstraintType::PageFault;
    case 33:
      okay = (in_str == "NoUserAccess");
      return EVmConstraintType::NoUserAccess;
    case 37:
      okay = (in_str == "AddressError");
      return EVmConstraintType::AddressError;
    case 39:
      okay = (in_str == "UserAccess");
      return EVmConstraintType::UserAccess;
    case 40:
      okay = (in_str == "PrivilegedNoExecute");
      return EVmConstraintType::PrivilegedNoExecute;
    case 43:
      okay = (in_str == "NoExecute");
      return EVmConstraintType::NoExecute;
    case 44:
      okay = (in_str == "Existing");
      return EVmConstraintType::Existing;
    case 54:
      okay = (in_str == "FlatMap");
      return EVmConstraintType::FlatMap;
    case 58:
      okay = (in_str == "UnpriviligedNoExecute");
      return EVmConstraintType::UnpriviligedNoExecute;
    case 60:
      okay = (in_str == "ReadOnly");
      return EVmConstraintType::ReadOnly;
    default:
      okay = false;
      return EVmConstraintType::Existing;
    }
    return EVmConstraintType::Existing;
  }


  unsigned char EPrivilegeLevelTypeSize = 4;

  const string EPrivilegeLevelType_to_string(EPrivilegeLevelType in_enum)
  {
    switch (in_enum) {
    case EPrivilegeLevelType::U: return "U";
    case EPrivilegeLevelType::S: return "S";
    case EPrivilegeLevelType::H: return "H";
    case EPrivilegeLevelType::M: return "M";
    default:
      unknown_enum_value("EPrivilegeLevelType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPrivilegeLevelType string_to_EPrivilegeLevelType(const string& in_str)
  {
    string enum_type_name = "EPrivilegeLevelType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      validate(in_str, "H", enum_type_name);
      return EPrivilegeLevelType::H;
    case 77:
      validate(in_str, "M", enum_type_name);
      return EPrivilegeLevelType::M;
    case 83:
      validate(in_str, "S", enum_type_name);
      return EPrivilegeLevelType::S;
    case 85:
      validate(in_str, "U", enum_type_name);
      return EPrivilegeLevelType::U;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPrivilegeLevelType::U;
  }

  EPrivilegeLevelType try_string_to_EPrivilegeLevelType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      okay = (in_str == "H");
      return EPrivilegeLevelType::H;
    case 77:
      okay = (in_str == "M");
      return EPrivilegeLevelType::M;
    case 83:
      okay = (in_str == "S");
      return EPrivilegeLevelType::S;
    case 85:
      okay = (in_str == "U");
      return EPrivilegeLevelType::U;
    default:
      okay = false;
      return EPrivilegeLevelType::U;
    }
    return EPrivilegeLevelType::U;
  }


  unsigned char EMemAttributeImplTypeSize = 1;

  const string EMemAttributeImplType_to_string(EMemAttributeImplType in_enum)
  {
    switch (in_enum) {
    case EMemAttributeImplType::Unpredictable: return "Unpredictable";
    default:
      unknown_enum_value("EMemAttributeImplType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemAttributeImplType string_to_EMemAttributeImplType(const string& in_str)
  {
    string enum_type_name = "EMemAttributeImplType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 85:
      validate(in_str, "Unpredictable", enum_type_name);
      return EMemAttributeImplType::Unpredictable;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemAttributeImplType::Unpredictable;
  }

  EMemAttributeImplType try_string_to_EMemAttributeImplType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 85:
      okay = (in_str == "Unpredictable");
      return EMemAttributeImplType::Unpredictable;
    default:
      okay = false;
      return EMemAttributeImplType::Unpredictable;
    }
    return EMemAttributeImplType::Unpredictable;
  }


  unsigned char ESystemOptionTypeSize = 7;

  const string ESystemOptionType_to_string(ESystemOptionType in_enum)
  {
    switch (in_enum) {
    case ESystemOptionType::PrivilegeLevel: return "PrivilegeLevel";
    case ESystemOptionType::DisablePaging: return "DisablePaging";
    case ESystemOptionType::NoHandler: return "NoHandler";
    case ESystemOptionType::NoSkip: return "NoSkip";
    case ESystemOptionType::FlatMap: return "FlatMap";
    case ESystemOptionType::MatchedHandler: return "MatchedHandler";
    case ESystemOptionType::SkipBootCode: return "SkipBootCode";
    default:
      unknown_enum_value("ESystemOptionType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESystemOptionType string_to_ESystemOptionType(const string& in_str)
  {
    string enum_type_name = "ESystemOptionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      validate(in_str, "FlatMap", enum_type_name);
      return ESystemOptionType::FlatMap;
    case 72:
      validate(in_str, "MatchedHandler", enum_type_name);
      return ESystemOptionType::MatchedHandler;
    case 80:
      validate(in_str, "DisablePaging", enum_type_name);
      return ESystemOptionType::DisablePaging;
    case 101:
      validate(in_str, "NoHandler", enum_type_name);
      return ESystemOptionType::NoHandler;
    case 103:
      validate(in_str, "PrivilegeLevel", enum_type_name);
      return ESystemOptionType::PrivilegeLevel;
    case 111:
      validate(in_str, "NoSkip", enum_type_name);
      return ESystemOptionType::NoSkip;
    case 116:
      validate(in_str, "SkipBootCode", enum_type_name);
      return ESystemOptionType::SkipBootCode;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESystemOptionType::PrivilegeLevel;
  }

  ESystemOptionType try_string_to_ESystemOptionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FlatMap");
      return ESystemOptionType::FlatMap;
    case 72:
      okay = (in_str == "MatchedHandler");
      return ESystemOptionType::MatchedHandler;
    case 80:
      okay = (in_str == "DisablePaging");
      return ESystemOptionType::DisablePaging;
    case 101:
      okay = (in_str == "NoHandler");
      return ESystemOptionType::NoHandler;
    case 103:
      okay = (in_str == "PrivilegeLevel");
      return ESystemOptionType::PrivilegeLevel;
    case 111:
      okay = (in_str == "NoSkip");
      return ESystemOptionType::NoSkip;
    case 116:
      okay = (in_str == "SkipBootCode");
      return ESystemOptionType::SkipBootCode;
    default:
      okay = false;
      return ESystemOptionType::PrivilegeLevel;
    }
    return ESystemOptionType::PrivilegeLevel;
  }


  unsigned char EExceptionClassTypeSize = 14;

  const string EExceptionClassType_to_string(EExceptionClassType in_enum)
  {
    switch (in_enum) {
    case EExceptionClassType::InstrAddrMisaligned: return "InstrAddrMisaligned";
    case EExceptionClassType::InstrAccessFault: return "InstrAccessFault";
    case EExceptionClassType::IllegalInstr: return "IllegalInstr";
    case EExceptionClassType::Breakpoint: return "Breakpoint";
    case EExceptionClassType::LoadAddrMisaligned: return "LoadAddrMisaligned";
    case EExceptionClassType::LoadAccessFault: return "LoadAccessFault";
    case EExceptionClassType::StoreAmoAddrMisaligned: return "StoreAmoAddrMisaligned";
    case EExceptionClassType::StoreAmoAccessFault: return "StoreAmoAccessFault";
    case EExceptionClassType::EnvCallFromUMode: return "EnvCallFromUMode";
    case EExceptionClassType::EnvCallFromSMode: return "EnvCallFromSMode";
    case EExceptionClassType::EnvCallFromMMode: return "EnvCallFromMMode";
    case EExceptionClassType::InstrPageFault: return "InstrPageFault";
    case EExceptionClassType::LoadPageFault: return "LoadPageFault";
    case EExceptionClassType::StoreAmoPageFault: return "StoreAmoPageFault";
    default:
      unknown_enum_value("EExceptionClassType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionClassType string_to_EExceptionClassType(const string& in_str)
  {
    string enum_type_name = "EExceptionClassType";
    size_t size = in_str.size();
    char hash_value = in_str.at(11 < size ? 11 : 11 % size) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "InstrPageFault", enum_type_name);
      return EExceptionClassType::InstrPageFault;
    case 4:
      validate(in_str, "StoreAmoPageFault", enum_type_name);
      return EExceptionClassType::StoreAmoPageFault;
    case 8:
      validate(in_str, "LoadAddrMisaligned", enum_type_name);
      return EExceptionClassType::LoadAddrMisaligned;
    case 13:
      validate(in_str, "LoadAccessFault", enum_type_name);
      return EExceptionClassType::LoadAccessFault;
    case 19:
      validate(in_str, "Breakpoint", enum_type_name);
      return EExceptionClassType::Breakpoint;
    case 22:
      validate(in_str, "StoreAmoAccessFault", enum_type_name);
      return EExceptionClassType::StoreAmoAccessFault;
    case 27:
      validate(in_str, "StoreAmoAddrMisaligned", enum_type_name);
      return EExceptionClassType::StoreAmoAddrMisaligned;
    case 30:
      validate(in_str, "IllegalInstr", enum_type_name);
      return EExceptionClassType::IllegalInstr;
    case 31:
      validate(in_str, "InstrAddrMisaligned", enum_type_name);
      return EExceptionClassType::InstrAddrMisaligned;
    case 32:
      validate(in_str, "LoadPageFault", enum_type_name);
      return EExceptionClassType::LoadPageFault;
    case 34:
      validate(in_str, "EnvCallFromMMode", enum_type_name);
      return EExceptionClassType::EnvCallFromMMode;
    case 51:
      validate(in_str, "InstrAccessFault", enum_type_name);
      return EExceptionClassType::InstrAccessFault;
    case 58:
      validate(in_str, "EnvCallFromUMode", enum_type_name);
      return EExceptionClassType::EnvCallFromUMode;
    case 60:
      validate(in_str, "EnvCallFromSMode", enum_type_name);
      return EExceptionClassType::EnvCallFromSMode;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionClassType::InstrAddrMisaligned;
  }

  EExceptionClassType try_string_to_EExceptionClassType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(11 < size ? 11 : 11 % size) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "InstrPageFault");
      return EExceptionClassType::InstrPageFault;
    case 4:
      okay = (in_str == "StoreAmoPageFault");
      return EExceptionClassType::StoreAmoPageFault;
    case 8:
      okay = (in_str == "LoadAddrMisaligned");
      return EExceptionClassType::LoadAddrMisaligned;
    case 13:
      okay = (in_str == "LoadAccessFault");
      return EExceptionClassType::LoadAccessFault;
    case 19:
      okay = (in_str == "Breakpoint");
      return EExceptionClassType::Breakpoint;
    case 22:
      okay = (in_str == "StoreAmoAccessFault");
      return EExceptionClassType::StoreAmoAccessFault;
    case 27:
      okay = (in_str == "StoreAmoAddrMisaligned");
      return EExceptionClassType::StoreAmoAddrMisaligned;
    case 30:
      okay = (in_str == "IllegalInstr");
      return EExceptionClassType::IllegalInstr;
    case 31:
      okay = (in_str == "InstrAddrMisaligned");
      return EExceptionClassType::InstrAddrMisaligned;
    case 32:
      okay = (in_str == "LoadPageFault");
      return EExceptionClassType::LoadPageFault;
    case 34:
      okay = (in_str == "EnvCallFromMMode");
      return EExceptionClassType::EnvCallFromMMode;
    case 51:
      okay = (in_str == "InstrAccessFault");
      return EExceptionClassType::InstrAccessFault;
    case 58:
      okay = (in_str == "EnvCallFromUMode");
      return EExceptionClassType::EnvCallFromUMode;
    case 60:
      okay = (in_str == "EnvCallFromSMode");
      return EExceptionClassType::EnvCallFromSMode;
    default:
      okay = false;
      return EExceptionClassType::InstrAddrMisaligned;
    }
    return EExceptionClassType::InstrAddrMisaligned;
  }


  unsigned char EInstructionGroupTypeSize = 4;

  const string EInstructionGroupType_to_string(EInstructionGroupType in_enum)
  {
    switch (in_enum) {
    case EInstructionGroupType::General: return "General";
    case EInstructionGroupType::Float: return "Float";
    case EInstructionGroupType::System: return "System";
    case EInstructionGroupType::Vector: return "Vector";
    default:
      unknown_enum_value("EInstructionGroupType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstructionGroupType string_to_EInstructionGroupType(const string& in_str)
  {
    string enum_type_name = "EInstructionGroupType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "Float", enum_type_name);
      return EInstructionGroupType::Float;
    case 71:
      validate(in_str, "General", enum_type_name);
      return EInstructionGroupType::General;
    case 83:
      validate(in_str, "System", enum_type_name);
      return EInstructionGroupType::System;
    case 86:
      validate(in_str, "Vector", enum_type_name);
      return EInstructionGroupType::Vector;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstructionGroupType::General;
  }

  EInstructionGroupType try_string_to_EInstructionGroupType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "Float");
      return EInstructionGroupType::Float;
    case 71:
      okay = (in_str == "General");
      return EInstructionGroupType::General;
    case 83:
      okay = (in_str == "System");
      return EInstructionGroupType::System;
    case 86:
      okay = (in_str == "Vector");
      return EInstructionGroupType::Vector;
    default:
      okay = false;
      return EInstructionGroupType::General;
    }
    return EInstructionGroupType::General;
  }


  unsigned char EInstructionExtensionTypeSize = 19;

  const string EInstructionExtensionType_to_string(EInstructionExtensionType in_enum)
  {
    switch (in_enum) {
    case EInstructionExtensionType::Default: return "Default";
    case EInstructionExtensionType::RV32I: return "RV32I";
    case EInstructionExtensionType::RV64I: return "RV64I";
    case EInstructionExtensionType::RV32A: return "RV32A";
    case EInstructionExtensionType::RV64A: return "RV64A";
    case EInstructionExtensionType::RV32M: return "RV32M";
    case EInstructionExtensionType::RV64M: return "RV64M";
    case EInstructionExtensionType::RV32F: return "RV32F";
    case EInstructionExtensionType::RV64F: return "RV64F";
    case EInstructionExtensionType::RV32D: return "RV32D";
    case EInstructionExtensionType::RV64D: return "RV64D";
    case EInstructionExtensionType::RV32Q: return "RV32Q";
    case EInstructionExtensionType::RV64Q: return "RV64Q";
    case EInstructionExtensionType::Zicsr: return "Zicsr";
    case EInstructionExtensionType::Zifencei: return "Zifencei";
    case EInstructionExtensionType::RV32C: return "RV32C";
    case EInstructionExtensionType::RV64C: return "RV64C";
    case EInstructionExtensionType::RV128C: return "RV128C";
    case EInstructionExtensionType::RV64Priv: return "RV64Priv";
    default:
      unknown_enum_value("EInstructionExtensionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstructionExtensionType string_to_EInstructionExtensionType(const string& in_str)
  {
    string enum_type_name = "EInstructionExtensionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "Zicsr", enum_type_name);
      return EInstructionExtensionType::Zicsr;
    case 10:
      validate(in_str, "RV128C", enum_type_name);
      return EInstructionExtensionType::RV128C;
    case 11:
      validate(in_str, "Zifencei", enum_type_name);
      return EInstructionExtensionType::Zifencei;
    case 20:
      validate(in_str, "Default", enum_type_name);
      return EInstructionExtensionType::Default;
    case 99:
      validate(in_str, "RV32Q", enum_type_name);
      return EInstructionExtensionType::RV32Q;
    case 100:
      validate(in_str, "RV64Priv", enum_type_name);
      return EInstructionExtensionType::RV64Priv;
    case 101:
      validate(in_str, "RV64Q", enum_type_name);
      return EInstructionExtensionType::RV64Q;
    case 112:
      validate(in_str, "RV64D", enum_type_name);
      return EInstructionExtensionType::RV64D;
    case 113:
      validate(in_str, "RV32C", enum_type_name);
      return EInstructionExtensionType::RV32C;
    case 114:
      validate(in_str, "RV64F", enum_type_name);
      return EInstructionExtensionType::RV64F;
    case 115:
      validate(in_str, "RV32A", enum_type_name);
      return EInstructionExtensionType::RV32A;
    case 116:
      validate(in_str, "RV32F", enum_type_name);
      return EInstructionExtensionType::RV32F;
    case 117:
      validate(in_str, "RV64A", enum_type_name);
      return EInstructionExtensionType::RV64A;
    case 118:
      validate(in_str, "RV32D", enum_type_name);
      return EInstructionExtensionType::RV32D;
    case 119:
      validate(in_str, "RV64C", enum_type_name);
      return EInstructionExtensionType::RV64C;
    case 121:
      validate(in_str, "RV64M", enum_type_name);
      return EInstructionExtensionType::RV64M;
    case 123:
      validate(in_str, "RV32I", enum_type_name);
      return EInstructionExtensionType::RV32I;
    case 125:
      validate(in_str, "RV64I", enum_type_name);
      return EInstructionExtensionType::RV64I;
    case 127:
      validate(in_str, "RV32M", enum_type_name);
      return EInstructionExtensionType::RV32M;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstructionExtensionType::Default;
  }

  EInstructionExtensionType try_string_to_EInstructionExtensionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "Zicsr");
      return EInstructionExtensionType::Zicsr;
    case 10:
      okay = (in_str == "RV128C");
      return EInstructionExtensionType::RV128C;
    case 11:
      okay = (in_str == "Zifencei");
      return EInstructionExtensionType::Zifencei;
    case 20:
      okay = (in_str == "Default");
      return EInstructionExtensionType::Default;
    case 99:
      okay = (in_str == "RV32Q");
      return EInstructionExtensionType::RV32Q;
    case 100:
      okay = (in_str == "RV64Priv");
      return EInstructionExtensionType::RV64Priv;
    case 101:
      okay = (in_str == "RV64Q");
      return EInstructionExtensionType::RV64Q;
    case 112:
      okay = (in_str == "RV64D");
      return EInstructionExtensionType::RV64D;
    case 113:
      okay = (in_str == "RV32C");
      return EInstructionExtensionType::RV32C;
    case 114:
      okay = (in_str == "RV64F");
      return EInstructionExtensionType::RV64F;
    case 115:
      okay = (in_str == "RV32A");
      return EInstructionExtensionType::RV32A;
    case 116:
      okay = (in_str == "RV32F");
      return EInstructionExtensionType::RV32F;
    case 117:
      okay = (in_str == "RV64A");
      return EInstructionExtensionType::RV64A;
    case 118:
      okay = (in_str == "RV32D");
      return EInstructionExtensionType::RV32D;
    case 119:
      okay = (in_str == "RV64C");
      return EInstructionExtensionType::RV64C;
    case 121:
      okay = (in_str == "RV64M");
      return EInstructionExtensionType::RV64M;
    case 123:
      okay = (in_str == "RV32I");
      return EInstructionExtensionType::RV32I;
    case 125:
      okay = (in_str == "RV64I");
      return EInstructionExtensionType::RV64I;
    case 127:
      okay = (in_str == "RV32M");
      return EInstructionExtensionType::RV32M;
    default:
      okay = false;
      return EInstructionExtensionType::Default;
    }
    return EInstructionExtensionType::Default;
  }


  unsigned char EMemOrderingTypeSize = 6;

  const string EMemOrderingType_to_string(EMemOrderingType in_enum)
  {
    switch (in_enum) {
    case EMemOrderingType::Init: return "Init";
    case EMemOrderingType::Atomic: return "Atomic";
    case EMemOrderingType::AtomicRW: return "AtomicRW";
    case EMemOrderingType::Ordered: return "Ordered";
    case EMemOrderingType::LimitedOrdered: return "LimitedOrdered";
    case EMemOrderingType::OrderedRW: return "OrderedRW";
    default:
      unknown_enum_value("EMemOrderingType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemOrderingType string_to_EMemOrderingType(const string& in_str)
  {
    string enum_type_name = "EMemOrderingType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 0:
      validate(in_str, "Ordered", enum_type_name);
      return EMemOrderingType::Ordered;
    case 3:
      validate(in_str, "LimitedOrdered", enum_type_name);
      return EMemOrderingType::LimitedOrdered;
    case 22:
      validate(in_str, "AtomicRW", enum_type_name);
      return EMemOrderingType::AtomicRW;
    case 29:
      validate(in_str, "OrderedRW", enum_type_name);
      return EMemOrderingType::OrderedRW;
    case 53:
      validate(in_str, "Atomic", enum_type_name);
      return EMemOrderingType::Atomic;
    case 61:
      validate(in_str, "Init", enum_type_name);
      return EMemOrderingType::Init;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemOrderingType::Init;
  }

  EMemOrderingType try_string_to_EMemOrderingType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 0:
      okay = (in_str == "Ordered");
      return EMemOrderingType::Ordered;
    case 3:
      okay = (in_str == "LimitedOrdered");
      return EMemOrderingType::LimitedOrdered;
    case 22:
      okay = (in_str == "AtomicRW");
      return EMemOrderingType::AtomicRW;
    case 29:
      okay = (in_str == "OrderedRW");
      return EMemOrderingType::OrderedRW;
    case 53:
      okay = (in_str == "Atomic");
      return EMemOrderingType::Atomic;
    case 61:
      okay = (in_str == "Init");
      return EMemOrderingType::Init;
    default:
      okay = false;
      return EMemOrderingType::Init;
    }
    return EMemOrderingType::Init;
  }


  unsigned char EExceptionVectorTypeSize = 2;

  const string EExceptionVectorType_to_string(EExceptionVectorType in_enum)
  {
    switch (in_enum) {
    case EExceptionVectorType::DefaultMachineModeVector: return "DefaultMachineModeVector";
    case EExceptionVectorType::DefaultSupervisorModeVector: return "DefaultSupervisorModeVector";
    default:
      unknown_enum_value("EExceptionVectorType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionVectorType string_to_EExceptionVectorType(const string& in_str)
  {
    string enum_type_name = "EExceptionVectorType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 77:
      validate(in_str, "DefaultMachineModeVector", enum_type_name);
      return EExceptionVectorType::DefaultMachineModeVector;
    case 83:
      validate(in_str, "DefaultSupervisorModeVector", enum_type_name);
      return EExceptionVectorType::DefaultSupervisorModeVector;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionVectorType::DefaultMachineModeVector;
  }

  EExceptionVectorType try_string_to_EExceptionVectorType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 77:
      okay = (in_str == "DefaultMachineModeVector");
      return EExceptionVectorType::DefaultMachineModeVector;
    case 83:
      okay = (in_str == "DefaultSupervisorModeVector");
      return EExceptionVectorType::DefaultSupervisorModeVector;
    default:
      okay = false;
      return EExceptionVectorType::DefaultMachineModeVector;
    }
    return EExceptionVectorType::DefaultMachineModeVector;
  }


  unsigned char ESystemOpTypeSize = 1;

  const string ESystemOpType_to_string(ESystemOpType in_enum)
  {
    switch (in_enum) {
    case ESystemOpType::None: return "None";
    default:
      unknown_enum_value("ESystemOpType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESystemOpType string_to_ESystemOpType(const string& in_str)
  {
    string enum_type_name = "ESystemOpType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 78:
      validate(in_str, "None", enum_type_name);
      return ESystemOpType::None;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESystemOpType::None;
  }

  ESystemOpType try_string_to_ESystemOpType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 78:
      okay = (in_str == "None");
      return ESystemOpType::None;
    default:
      okay = false;
      return ESystemOpType::None;
    }
    return ESystemOpType::None;
  }


  unsigned char EMemoryAttributeTypeSize = 3;

  const string EMemoryAttributeType_to_string(EMemoryAttributeType in_enum)
  {
    switch (in_enum) {
    case EMemoryAttributeType::Device: return "Device";
    case EMemoryAttributeType::NormalCacheable: return "NormalCacheable";
    case EMemoryAttributeType::NormalNonCacheable: return "NormalNonCacheable";
    default:
      unknown_enum_value("EMemoryAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemoryAttributeType string_to_EMemoryAttributeType(const string& in_str)
  {
    string enum_type_name = "EMemoryAttributeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(6 < size ? 6 : 6 % size);

    switch (hash_value) {
    case 67:
      validate(in_str, "NormalCacheable", enum_type_name);
      return EMemoryAttributeType::NormalCacheable;
    case 68:
      validate(in_str, "Device", enum_type_name);
      return EMemoryAttributeType::Device;
    case 78:
      validate(in_str, "NormalNonCacheable", enum_type_name);
      return EMemoryAttributeType::NormalNonCacheable;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemoryAttributeType::Device;
  }

  EMemoryAttributeType try_string_to_EMemoryAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(6 < size ? 6 : 6 % size);

    switch (hash_value) {
    case 67:
      okay = (in_str == "NormalCacheable");
      return EMemoryAttributeType::NormalCacheable;
    case 68:
      okay = (in_str == "Device");
      return EMemoryAttributeType::Device;
    case 78:
      okay = (in_str == "NormalNonCacheable");
      return EMemoryAttributeType::NormalNonCacheable;
    default:
      okay = false;
      return EMemoryAttributeType::Device;
    }
    return EMemoryAttributeType::Device;
  }


  unsigned char EVmInfoBoolTypeSize = 3;

  const string EVmInfoBoolType_to_string(EVmInfoBoolType in_enum)
  {
    switch (in_enum) {
    case EVmInfoBoolType::MODE: return "MODE";
    case EVmInfoBoolType::MPRV: return "MPRV";
    case EVmInfoBoolType::TVM: return "TVM";
    default:
      unknown_enum_value("EVmInfoBoolType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmInfoBoolType string_to_EVmInfoBoolType(const string& in_str)
  {
    string enum_type_name = "EVmInfoBoolType";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 79:
      validate(in_str, "MODE", enum_type_name);
      return EVmInfoBoolType::MODE;
    case 80:
      validate(in_str, "MPRV", enum_type_name);
      return EVmInfoBoolType::MPRV;
    case 86:
      validate(in_str, "TVM", enum_type_name);
      return EVmInfoBoolType::TVM;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmInfoBoolType::MODE;
  }

  EVmInfoBoolType try_string_to_EVmInfoBoolType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 79:
      okay = (in_str == "MODE");
      return EVmInfoBoolType::MODE;
    case 80:
      okay = (in_str == "MPRV");
      return EVmInfoBoolType::MPRV;
    case 86:
      okay = (in_str == "TVM");
      return EVmInfoBoolType::TVM;
    default:
      okay = false;
      return EVmInfoBoolType::MODE;
    }
    return EVmInfoBoolType::MODE;
  }

}
