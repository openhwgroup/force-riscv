//
// Copyright (C) [2020] Futurewei Technologies, Inc.
//
// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
// FIT FOR A PARTICULAR PURPOSE.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/*  !!! NOTICE !!!
    This file is automatically generated by the script: utils/enum_classes/create_enum_files.py
    Please do not modify this file manually.  Instead, modify the above mentioned script to re-generate this file.
*/

#include <Enums.h>

#include <GenException.h>

#include <sstream>

using namespace std;

namespace Force {


  /*!
    Report an unknown enum value of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
  */
  static void unknown_enum_value(const string& enum_type_name, unsigned long long value)
  {
    stringstream err_stream;
    err_stream << "Unknown " << enum_type_name << " enum value: " << dec << value;
    throw EnumTypeError(err_stream.str());
  }

  /*!
    Report an unknown enum name of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
  */
  static void unknown_enum_name(const string& enum_type_name, const string& enum_name)
  {
    stringstream err_stream;
    err_stream << "Unknown " << enum_type_name << " enum name: " << enum_name;
    throw EnumTypeError(err_stream.str());
  }

  /*!
    Throw an exception if in_str and enum_name are not identical.
  */
  static void validate(const string& specified_enum_name, const string& expected_enum_name, const string& enum_type_name)
  {
    if (specified_enum_name != expected_enum_name) {
      unknown_enum_name(enum_type_name, specified_enum_name);
    }
  }


  unsigned char ELimitTypeSize = 13;

  const string ELimitType_to_string(ELimitType in_enum)
  {
    switch (in_enum) {
    case ELimitType::ThreadsLimit: return "ThreadsLimit";
    case ELimitType::CoresLimit: return "CoresLimit";
    case ELimitType::ChipsLimit: return "ChipsLimit";
    case ELimitType::PhysicalAddressLimit: return "PhysicalAddressLimit";
    case ELimitType::MaxInstructions: return "MaxInstructions";
    case ELimitType::PerMonRegisterNumber: return "PerMonRegisterNumber";
    case ELimitType::DependencyHistoryLimit: return "DependencyHistoryLimit";
    case ELimitType::BranchNotTakenLimit: return "BranchNotTakenLimit";
    case ELimitType::SpeculativeBntLevelLimit: return "SpeculativeBntLevelLimit";
    case ELimitType::MaxPhysicalVectorLen: return "MaxPhysicalVectorLen";
    case ELimitType::ErrRegisterNumber: return "ErrRegisterNumber";
    case ELimitType::SpeculativeBntInstructionLimit: return "SpeculativeBntInstructionLimit";
    case ELimitType::MaxVectorElementWidth: return "MaxVectorElementWidth";
    default:
      unknown_enum_value("ELimitType", (unsigned char)(in_enum));
    }
    return "";
  }

  ELimitType string_to_ELimitType(const string& in_str)
  {
    string enum_type_name = "ELimitType";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(26 < size ? 26 : 26 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "ChipsLimit", enum_type_name);
      return ELimitType::ChipsLimit;
    case 2:
      validate(in_str, "MaxVectorElementWidth", enum_type_name);
      return ELimitType::MaxVectorElementWidth;
    case 6:
      validate(in_str, "CoresLimit", enum_type_name);
      return ELimitType::CoresLimit;
    case 8:
      validate(in_str, "MaxInstructions", enum_type_name);
      return ELimitType::MaxInstructions;
    case 9:
      validate(in_str, "PhysicalAddressLimit", enum_type_name);
      return ELimitType::PhysicalAddressLimit;
    case 11:
      validate(in_str, "DependencyHistoryLimit", enum_type_name);
      return ELimitType::DependencyHistoryLimit;
    case 18:
      validate(in_str, "MaxPhysicalVectorLen", enum_type_name);
      return ELimitType::MaxPhysicalVectorLen;
    case 21:
      validate(in_str, "SpeculativeBntLevelLimit", enum_type_name);
      return ELimitType::SpeculativeBntLevelLimit;
    case 23:
      validate(in_str, "ErrRegisterNumber", enum_type_name);
      return ELimitType::ErrRegisterNumber;
    case 25:
      validate(in_str, "SpeculativeBntInstructionLimit", enum_type_name);
      return ELimitType::SpeculativeBntInstructionLimit;
    case 26:
      validate(in_str, "ThreadsLimit", enum_type_name);
      return ELimitType::ThreadsLimit;
    case 29:
      validate(in_str, "BranchNotTakenLimit", enum_type_name);
      return ELimitType::BranchNotTakenLimit;
    case 55:
      validate(in_str, "PerMonRegisterNumber", enum_type_name);
      return ELimitType::PerMonRegisterNumber;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ELimitType::ThreadsLimit;
  }

  ELimitType try_string_to_ELimitType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(26 < size ? 26 : 26 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "ChipsLimit");
      return ELimitType::ChipsLimit;
    case 2:
      okay = (in_str == "MaxVectorElementWidth");
      return ELimitType::MaxVectorElementWidth;
    case 6:
      okay = (in_str == "CoresLimit");
      return ELimitType::CoresLimit;
    case 8:
      okay = (in_str == "MaxInstructions");
      return ELimitType::MaxInstructions;
    case 9:
      okay = (in_str == "PhysicalAddressLimit");
      return ELimitType::PhysicalAddressLimit;
    case 11:
      okay = (in_str == "DependencyHistoryLimit");
      return ELimitType::DependencyHistoryLimit;
    case 18:
      okay = (in_str == "MaxPhysicalVectorLen");
      return ELimitType::MaxPhysicalVectorLen;
    case 21:
      okay = (in_str == "SpeculativeBntLevelLimit");
      return ELimitType::SpeculativeBntLevelLimit;
    case 23:
      okay = (in_str == "ErrRegisterNumber");
      return ELimitType::ErrRegisterNumber;
    case 25:
      okay = (in_str == "SpeculativeBntInstructionLimit");
      return ELimitType::SpeculativeBntInstructionLimit;
    case 26:
      okay = (in_str == "ThreadsLimit");
      return ELimitType::ThreadsLimit;
    case 29:
      okay = (in_str == "BranchNotTakenLimit");
      return ELimitType::BranchNotTakenLimit;
    case 55:
      okay = (in_str == "PerMonRegisterNumber");
      return ELimitType::PerMonRegisterNumber;
    default:
      okay = false;
      return ELimitType::ThreadsLimit;
    }
    return ELimitType::ThreadsLimit;
  }


  unsigned char EOperandTypeSize = 20;

  const string EOperandType_to_string(EOperandType in_enum)
  {
    switch (in_enum) {
    case EOperandType::Constant: return "Constant";
    case EOperandType::Immediate: return "Immediate";
    case EOperandType::Choices: return "Choices";
    case EOperandType::Register: return "Register";
    case EOperandType::GPR: return "GPR";
    case EOperandType::GPRSP: return "GPRSP";
    case EOperandType::FPR: return "FPR";
    case EOperandType::SIMDSR: return "SIMDSR";
    case EOperandType::SIMDVR: return "SIMDVR";
    case EOperandType::SysReg: return "SysReg";
    case EOperandType::Branch: return "Branch";
    case EOperandType::LoadStore: return "LoadStore";
    case EOperandType::AuthBranch: return "AuthBranch";
    case EOperandType::AuthLoadStore: return "AuthLoadStore";
    case EOperandType::SystemOp: return "SystemOp";
    case EOperandType::VECREG: return "VECREG";
    case EOperandType::PREDREG: return "PREDREG";
    case EOperandType::ALU: return "ALU";
    case EOperandType::DataProcessing: return "DataProcessing";
    case EOperandType::VectorLayout: return "VectorLayout";
    default:
      unknown_enum_value("EOperandType", (unsigned char)(in_enum));
    }
    return "";
  }

  EOperandType string_to_EOperandType(const string& in_str)
  {
    string enum_type_name = "EOperandType";
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size) ^ in_str.at(12 < size ? 12 : 12 % size) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 65:
      validate(in_str, "ALU", enum_type_name);
      return EOperandType::ALU;
    case 70:
      validate(in_str, "FPR", enum_type_name);
      return EOperandType::FPR;
    case 71:
      validate(in_str, "GPR", enum_type_name);
      return EOperandType::GPR;
    case 73:
      validate(in_str, "SIMDSR", enum_type_name);
      return EOperandType::SIMDSR;
    case 76:
      validate(in_str, "SIMDVR", enum_type_name);
      return EOperandType::SIMDVR;
    case 79:
      validate(in_str, "SysReg", enum_type_name);
      return EOperandType::SysReg;
    case 80:
      validate(in_str, "PREDREG", enum_type_name);
      return EOperandType::PREDREG;
    case 81:
      validate(in_str, "GPRSP", enum_type_name);
      return EOperandType::GPRSP;
    case 83:
      validate(in_str, "Branch", enum_type_name);
      return EOperandType::Branch;
    case 86:
      validate(in_str, "VECREG", enum_type_name);
      return EOperandType::VECREG;
    case 89:
      validate(in_str, "DataProcessing", enum_type_name);
      return EOperandType::DataProcessing;
    case 92:
      validate(in_str, "VectorLayout", enum_type_name);
      return EOperandType::VectorLayout;
    case 94:
      validate(in_str, "AuthBranch", enum_type_name);
      return EOperandType::AuthBranch;
    case 97:
      validate(in_str, "Constant", enum_type_name);
      return EOperandType::Constant;
    case 100:
      validate(in_str, "LoadStore", enum_type_name);
      return EOperandType::LoadStore;
    case 101:
      validate(in_str, "Immediate", enum_type_name);
      return EOperandType::Immediate;
    case 104:
      validate(in_str, "AuthLoadStore", enum_type_name);
      return EOperandType::AuthLoadStore;
    case 109:
      validate(in_str, "SystemOp", enum_type_name);
      return EOperandType::SystemOp;
    case 116:
      validate(in_str, "Register", enum_type_name);
      return EOperandType::Register;
    case 117:
      validate(in_str, "Choices", enum_type_name);
      return EOperandType::Choices;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EOperandType::Constant;
  }

  EOperandType try_string_to_EOperandType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size) ^ in_str.at(12 < size ? 12 : 12 % size) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 65:
      okay = (in_str == "ALU");
      return EOperandType::ALU;
    case 70:
      okay = (in_str == "FPR");
      return EOperandType::FPR;
    case 71:
      okay = (in_str == "GPR");
      return EOperandType::GPR;
    case 73:
      okay = (in_str == "SIMDSR");
      return EOperandType::SIMDSR;
    case 76:
      okay = (in_str == "SIMDVR");
      return EOperandType::SIMDVR;
    case 79:
      okay = (in_str == "SysReg");
      return EOperandType::SysReg;
    case 80:
      okay = (in_str == "PREDREG");
      return EOperandType::PREDREG;
    case 81:
      okay = (in_str == "GPRSP");
      return EOperandType::GPRSP;
    case 83:
      okay = (in_str == "Branch");
      return EOperandType::Branch;
    case 86:
      okay = (in_str == "VECREG");
      return EOperandType::VECREG;
    case 89:
      okay = (in_str == "DataProcessing");
      return EOperandType::DataProcessing;
    case 92:
      okay = (in_str == "VectorLayout");
      return EOperandType::VectorLayout;
    case 94:
      okay = (in_str == "AuthBranch");
      return EOperandType::AuthBranch;
    case 97:
      okay = (in_str == "Constant");
      return EOperandType::Constant;
    case 100:
      okay = (in_str == "LoadStore");
      return EOperandType::LoadStore;
    case 101:
      okay = (in_str == "Immediate");
      return EOperandType::Immediate;
    case 104:
      okay = (in_str == "AuthLoadStore");
      return EOperandType::AuthLoadStore;
    case 109:
      okay = (in_str == "SystemOp");
      return EOperandType::SystemOp;
    case 116:
      okay = (in_str == "Register");
      return EOperandType::Register;
    case 117:
      okay = (in_str == "Choices");
      return EOperandType::Choices;
    default:
      okay = false;
      return EOperandType::Constant;
    }
    return EOperandType::Constant;
  }


  unsigned char EMemDataTypeSize = 4;

  const string EMemDataType_to_string(EMemDataType in_enum)
  {
    switch (in_enum) {
    case EMemDataType::Init: return "Init";
    case EMemDataType::Instruction: return "Instruction";
    case EMemDataType::Data: return "Data";
    case EMemDataType::Both: return "Both";
    default:
      unknown_enum_value("EMemDataType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemDataType string_to_EMemDataType(const string& in_str)
  {
    string enum_type_name = "EMemDataType";
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 66:
      validate(in_str, "Both", enum_type_name);
      return EMemDataType::Both;
    case 68:
      validate(in_str, "Data", enum_type_name);
      return EMemDataType::Data;
    case 73:
      validate(in_str, "Init", enum_type_name);
      return EMemDataType::Init;
    case 114:
      validate(in_str, "Instruction", enum_type_name);
      return EMemDataType::Instruction;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemDataType::Init;
  }

  EMemDataType try_string_to_EMemDataType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 66:
      okay = (in_str == "Both");
      return EMemDataType::Both;
    case 68:
      okay = (in_str == "Data");
      return EMemDataType::Data;
    case 73:
      okay = (in_str == "Init");
      return EMemDataType::Init;
    case 114:
      okay = (in_str == "Instruction");
      return EMemDataType::Instruction;
    default:
      okay = false;
      return EMemDataType::Init;
    }
    return EMemDataType::Init;
  }


  unsigned char ERegAttrTypeSize = 6;

  const string ERegAttrType_to_string(ERegAttrType in_enum)
  {
    switch (in_enum) {
    case ERegAttrType::Read: return "Read";
    case ERegAttrType::Write: return "Write";
    case ERegAttrType::ReadWrite: return "ReadWrite";
    case ERegAttrType::HasValue: return "HasValue";
    case ERegAttrType::Unpredictable: return "Unpredictable";
    case ERegAttrType::UpdatedFromISS: return "UpdatedFromISS";
    default:
      unknown_enum_value("ERegAttrType", (unsigned char)(in_enum));
    }
    return "";
  }

  ERegAttrType string_to_ERegAttrType(const string& in_str)
  {
    string enum_type_name = "ERegAttrType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      validate(in_str, "UpdatedFromISS", enum_type_name);
      return ERegAttrType::UpdatedFromISS;
    case 99:
      validate(in_str, "Unpredictable", enum_type_name);
      return ERegAttrType::Unpredictable;
    case 100:
      validate(in_str, "Read", enum_type_name);
      return ERegAttrType::Read;
    case 101:
      validate(in_str, "HasValue", enum_type_name);
      return ERegAttrType::HasValue;
    case 105:
      validate(in_str, "Write", enum_type_name);
      return ERegAttrType::Write;
    case 116:
      validate(in_str, "ReadWrite", enum_type_name);
      return ERegAttrType::ReadWrite;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERegAttrType::Read;
  }

  ERegAttrType try_string_to_ERegAttrType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      okay = (in_str == "UpdatedFromISS");
      return ERegAttrType::UpdatedFromISS;
    case 99:
      okay = (in_str == "Unpredictable");
      return ERegAttrType::Unpredictable;
    case 100:
      okay = (in_str == "Read");
      return ERegAttrType::Read;
    case 101:
      okay = (in_str == "HasValue");
      return ERegAttrType::HasValue;
    case 105:
      okay = (in_str == "Write");
      return ERegAttrType::Write;
    case 116:
      okay = (in_str == "ReadWrite");
      return ERegAttrType::ReadWrite;
    default:
      okay = false;
      return ERegAttrType::Read;
    }
    return ERegAttrType::Read;
  }


  unsigned char EMemAccessTypeSize = 4;

  const string EMemAccessType_to_string(EMemAccessType in_enum)
  {
    switch (in_enum) {
    case EMemAccessType::Unknown: return "Unknown";
    case EMemAccessType::Read: return "Read";
    case EMemAccessType::Write: return "Write";
    case EMemAccessType::ReadWrite: return "ReadWrite";
    default:
      unknown_enum_value("EMemAccessType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemAccessType string_to_EMemAccessType(const string& in_str)
  {
    string enum_type_name = "EMemAccessType";
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 82:
      validate(in_str, "Read", enum_type_name);
      return EMemAccessType::Read;
    case 87:
      validate(in_str, "ReadWrite", enum_type_name);
      return EMemAccessType::ReadWrite;
    case 101:
      validate(in_str, "Write", enum_type_name);
      return EMemAccessType::Write;
    case 111:
      validate(in_str, "Unknown", enum_type_name);
      return EMemAccessType::Unknown;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemAccessType::Unknown;
  }

  EMemAccessType try_string_to_EMemAccessType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 82:
      okay = (in_str == "Read");
      return EMemAccessType::Read;
    case 87:
      okay = (in_str == "ReadWrite");
      return EMemAccessType::ReadWrite;
    case 101:
      okay = (in_str == "Write");
      return EMemAccessType::Write;
    case 111:
      okay = (in_str == "Unknown");
      return EMemAccessType::Unknown;
    default:
      okay = false;
      return EMemAccessType::Unknown;
    }
    return EMemAccessType::Unknown;
  }


  unsigned char EGenAgentTypeSize = 8;

  const string EGenAgentType_to_string(EGenAgentType in_enum)
  {
    switch (in_enum) {
    case EGenAgentType::GenInstructionAgent: return "GenInstructionAgent";
    case EGenAgentType::GenSequenceAgent: return "GenSequenceAgent";
    case EGenAgentType::GenVirtualMemoryAgent: return "GenVirtualMemoryAgent";
    case EGenAgentType::GenQueryAgent: return "GenQueryAgent";
    case EGenAgentType::GenStateAgent: return "GenStateAgent";
    case EGenAgentType::GenExceptionAgent: return "GenExceptionAgent";
    case EGenAgentType::GenCallBackAgent: return "GenCallBackAgent";
    case EGenAgentType::GenStateTransitionAgent: return "GenStateTransitionAgent";
    default:
      unknown_enum_value("EGenAgentType", (unsigned char)(in_enum));
    }
    return "";
  }

  EGenAgentType string_to_EGenAgentType(const string& in_str)
  {
    string enum_type_name = "EGenAgentType";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 7:
      validate(in_str, "GenStateTransitionAgent", enum_type_name);
      return EGenAgentType::GenStateTransitionAgent;
    case 16:
      validate(in_str, "GenQueryAgent", enum_type_name);
      return EGenAgentType::GenQueryAgent;
    case 18:
      validate(in_str, "GenStateAgent", enum_type_name);
      return EGenAgentType::GenStateAgent;
    case 34:
      validate(in_str, "GenCallBackAgent", enum_type_name);
      return EGenAgentType::GenCallBackAgent;
    case 49:
      validate(in_str, "GenExceptionAgent", enum_type_name);
      return EGenAgentType::GenExceptionAgent;
    case 55:
      validate(in_str, "GenVirtualMemoryAgent", enum_type_name);
      return EGenAgentType::GenVirtualMemoryAgent;
    case 60:
      validate(in_str, "GenInstructionAgent", enum_type_name);
      return EGenAgentType::GenInstructionAgent;
    case 61:
      validate(in_str, "GenSequenceAgent", enum_type_name);
      return EGenAgentType::GenSequenceAgent;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EGenAgentType::GenInstructionAgent;
  }

  EGenAgentType try_string_to_EGenAgentType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 7:
      okay = (in_str == "GenStateTransitionAgent");
      return EGenAgentType::GenStateTransitionAgent;
    case 16:
      okay = (in_str == "GenQueryAgent");
      return EGenAgentType::GenQueryAgent;
    case 18:
      okay = (in_str == "GenStateAgent");
      return EGenAgentType::GenStateAgent;
    case 34:
      okay = (in_str == "GenCallBackAgent");
      return EGenAgentType::GenCallBackAgent;
    case 49:
      okay = (in_str == "GenExceptionAgent");
      return EGenAgentType::GenExceptionAgent;
    case 55:
      okay = (in_str == "GenVirtualMemoryAgent");
      return EGenAgentType::GenVirtualMemoryAgent;
    case 60:
      okay = (in_str == "GenInstructionAgent");
      return EGenAgentType::GenInstructionAgent;
    case 61:
      okay = (in_str == "GenSequenceAgent");
      return EGenAgentType::GenSequenceAgent;
    default:
      okay = false;
      return EGenAgentType::GenInstructionAgent;
    }
    return EGenAgentType::GenInstructionAgent;
  }


  unsigned char EChoicesTypeSize = 5;

  const string EChoicesType_to_string(EChoicesType in_enum)
  {
    switch (in_enum) {
    case EChoicesType::OperandChoices: return "OperandChoices";
    case EChoicesType::RegisterFieldValueChoices: return "RegisterFieldValueChoices";
    case EChoicesType::PagingChoices: return "PagingChoices";
    case EChoicesType::GeneralChoices: return "GeneralChoices";
    case EChoicesType::DependenceChoices: return "DependenceChoices";
    default:
      unknown_enum_value("EChoicesType", (unsigned char)(in_enum));
    }
    return "";
  }

  EChoicesType string_to_EChoicesType(const string& in_str)
  {
    string enum_type_name = "EChoicesType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      validate(in_str, "DependenceChoices", enum_type_name);
      return EChoicesType::DependenceChoices;
    case 71:
      validate(in_str, "GeneralChoices", enum_type_name);
      return EChoicesType::GeneralChoices;
    case 79:
      validate(in_str, "OperandChoices", enum_type_name);
      return EChoicesType::OperandChoices;
    case 80:
      validate(in_str, "PagingChoices", enum_type_name);
      return EChoicesType::PagingChoices;
    case 82:
      validate(in_str, "RegisterFieldValueChoices", enum_type_name);
      return EChoicesType::RegisterFieldValueChoices;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EChoicesType::OperandChoices;
  }

  EChoicesType try_string_to_EChoicesType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      okay = (in_str == "DependenceChoices");
      return EChoicesType::DependenceChoices;
    case 71:
      okay = (in_str == "GeneralChoices");
      return EChoicesType::GeneralChoices;
    case 79:
      okay = (in_str == "OperandChoices");
      return EChoicesType::OperandChoices;
    case 80:
      okay = (in_str == "PagingChoices");
      return EChoicesType::PagingChoices;
    case 82:
      okay = (in_str == "RegisterFieldValueChoices");
      return EChoicesType::RegisterFieldValueChoices;
    default:
      okay = false;
      return EChoicesType::OperandChoices;
    }
    return EChoicesType::OperandChoices;
  }


  unsigned char ERegisterTypeSize = 11;

  const string ERegisterType_to_string(ERegisterType in_enum)
  {
    switch (in_enum) {
    case ERegisterType::GPR: return "GPR";
    case ERegisterType::FPR: return "FPR";
    case ERegisterType::SIMDR: return "SIMDR";
    case ERegisterType::SIMDVR: return "SIMDVR";
    case ERegisterType::VECREG: return "VECREG";
    case ERegisterType::PREDREG: return "PREDREG";
    case ERegisterType::SysReg: return "SysReg";
    case ERegisterType::SP: return "SP";
    case ERegisterType::ZR: return "ZR";
    case ERegisterType::PC: return "PC";
    case ERegisterType::Internal: return "Internal";
    default:
      unknown_enum_value("ERegisterType", (unsigned char)(in_enum));
    }
    return "";
  }

  ERegisterType string_to_ERegisterType(const string& in_str)
  {
    string enum_type_name = "ERegisterType";
    size_t size = in_str.size();
    char hash_value = in_str.at(5 < size ? 5 : 5 % size) ^ in_str.at(6 < size ? 6 : 6 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "SIMDVR", enum_type_name);
      return ERegisterType::SIMDVR;
    case 2:
      validate(in_str, "PREDREG", enum_type_name);
      return ERegisterType::PREDREG;
    case 3:
      validate(in_str, "SP", enum_type_name);
      return ERegisterType::SP;
    case 8:
      validate(in_str, "ZR", enum_type_name);
      return ERegisterType::ZR;
    case 15:
      validate(in_str, "Internal", enum_type_name);
      return ERegisterType::Internal;
    case 17:
      validate(in_str, "VECREG", enum_type_name);
      return ERegisterType::VECREG;
    case 19:
      validate(in_str, "PC", enum_type_name);
      return ERegisterType::PC;
    case 20:
      validate(in_str, "FPR", enum_type_name);
      return ERegisterType::FPR;
    case 21:
      validate(in_str, "GPR", enum_type_name);
      return ERegisterType::GPR;
    case 26:
      validate(in_str, "SIMDR", enum_type_name);
      return ERegisterType::SIMDR;
    case 52:
      validate(in_str, "SysReg", enum_type_name);
      return ERegisterType::SysReg;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERegisterType::GPR;
  }

  ERegisterType try_string_to_ERegisterType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(5 < size ? 5 : 5 % size) ^ in_str.at(6 < size ? 6 : 6 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "SIMDVR");
      return ERegisterType::SIMDVR;
    case 2:
      okay = (in_str == "PREDREG");
      return ERegisterType::PREDREG;
    case 3:
      okay = (in_str == "SP");
      return ERegisterType::SP;
    case 8:
      okay = (in_str == "ZR");
      return ERegisterType::ZR;
    case 15:
      okay = (in_str == "Internal");
      return ERegisterType::Internal;
    case 17:
      okay = (in_str == "VECREG");
      return ERegisterType::VECREG;
    case 19:
      okay = (in_str == "PC");
      return ERegisterType::PC;
    case 20:
      okay = (in_str == "FPR");
      return ERegisterType::FPR;
    case 21:
      okay = (in_str == "GPR");
      return ERegisterType::GPR;
    case 26:
      okay = (in_str == "SIMDR");
      return ERegisterType::SIMDR;
    case 52:
      okay = (in_str == "SysReg");
      return ERegisterType::SysReg;
    default:
      okay = false;
      return ERegisterType::GPR;
    }
    return ERegisterType::GPR;
  }


  unsigned char EConstraintTypeSize = 2;

  const string EConstraintType_to_string(EConstraintType in_enum)
  {
    switch (in_enum) {
    case EConstraintType::Value: return "Value";
    case EConstraintType::Range: return "Range";
    default:
      unknown_enum_value("EConstraintType", (unsigned char)(in_enum));
    }
    return "";
  }

  EConstraintType string_to_EConstraintType(const string& in_str)
  {
    string enum_type_name = "EConstraintType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 82:
      validate(in_str, "Range", enum_type_name);
      return EConstraintType::Range;
    case 86:
      validate(in_str, "Value", enum_type_name);
      return EConstraintType::Value;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EConstraintType::Value;
  }

  EConstraintType try_string_to_EConstraintType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 82:
      okay = (in_str == "Range");
      return EConstraintType::Range;
    case 86:
      okay = (in_str == "Value");
      return EConstraintType::Value;
    default:
      okay = false;
      return EConstraintType::Value;
    }
    return EConstraintType::Value;
  }


  unsigned char EConstraintResultTypeSize = 3;

  const string EConstraintResultType_to_string(EConstraintResultType in_enum)
  {
    switch (in_enum) {
    case EConstraintResultType::Consumed: return "Consumed";
    case EConstraintResultType::Replace: return "Replace";
    case EConstraintResultType::Remove: return "Remove";
    default:
      unknown_enum_value("EConstraintResultType", (unsigned char)(in_enum));
    }
    return "";
  }

  EConstraintResultType string_to_EConstraintResultType(const string& in_str)
  {
    string enum_type_name = "EConstraintResultType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 109:
      validate(in_str, "Remove", enum_type_name);
      return EConstraintResultType::Remove;
    case 110:
      validate(in_str, "Consumed", enum_type_name);
      return EConstraintResultType::Consumed;
    case 112:
      validate(in_str, "Replace", enum_type_name);
      return EConstraintResultType::Replace;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EConstraintResultType::Consumed;
  }

  EConstraintResultType try_string_to_EConstraintResultType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 109:
      okay = (in_str == "Remove");
      return EConstraintResultType::Remove;
    case 110:
      okay = (in_str == "Consumed");
      return EConstraintResultType::Consumed;
    case 112:
      okay = (in_str == "Replace");
      return EConstraintResultType::Replace;
    default:
      okay = false;
      return EConstraintResultType::Consumed;
    }
    return EConstraintResultType::Consumed;
  }


  unsigned char EConstraintMoveDirectionSize = 2;

  const string EConstraintMoveDirection_to_string(EConstraintMoveDirection in_enum)
  {
    switch (in_enum) {
    case EConstraintMoveDirection::Shrink: return "Shrink";
    case EConstraintMoveDirection::Expand: return "Expand";
    default:
      unknown_enum_value("EConstraintMoveDirection", (unsigned char)(in_enum));
    }
    return "";
  }

  EConstraintMoveDirection string_to_EConstraintMoveDirection(const string& in_str)
  {
    string enum_type_name = "EConstraintMoveDirection";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      validate(in_str, "Expand", enum_type_name);
      return EConstraintMoveDirection::Expand;
    case 83:
      validate(in_str, "Shrink", enum_type_name);
      return EConstraintMoveDirection::Shrink;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EConstraintMoveDirection::Shrink;
  }

  EConstraintMoveDirection try_string_to_EConstraintMoveDirection(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      okay = (in_str == "Expand");
      return EConstraintMoveDirection::Expand;
    case 83:
      okay = (in_str == "Shrink");
      return EConstraintMoveDirection::Shrink;
    default:
      okay = false;
      return EConstraintMoveDirection::Shrink;
    }
    return EConstraintMoveDirection::Shrink;
  }


  unsigned char ETranslationResultTypeSize = 3;

  const string ETranslationResultType_to_string(ETranslationResultType in_enum)
  {
    switch (in_enum) {
    case ETranslationResultType::NotMapped: return "NotMapped";
    case ETranslationResultType::Mapped: return "Mapped";
    case ETranslationResultType::AddressError: return "AddressError";
    default:
      unknown_enum_value("ETranslationResultType", (unsigned char)(in_enum));
    }
    return "";
  }

  ETranslationResultType string_to_ETranslationResultType(const string& in_str)
  {
    string enum_type_name = "ETranslationResultType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "AddressError", enum_type_name);
      return ETranslationResultType::AddressError;
    case 77:
      validate(in_str, "Mapped", enum_type_name);
      return ETranslationResultType::Mapped;
    case 78:
      validate(in_str, "NotMapped", enum_type_name);
      return ETranslationResultType::NotMapped;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ETranslationResultType::NotMapped;
  }

  ETranslationResultType try_string_to_ETranslationResultType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "AddressError");
      return ETranslationResultType::AddressError;
    case 77:
      okay = (in_str == "Mapped");
      return ETranslationResultType::Mapped;
    case 78:
      okay = (in_str == "NotMapped");
      return ETranslationResultType::NotMapped;
    default:
      okay = false;
      return ETranslationResultType::NotMapped;
    }
    return ETranslationResultType::NotMapped;
  }


  unsigned char EVmStateTypeSize = 4;

  const string EVmStateType_to_string(EVmStateType in_enum)
  {
    switch (in_enum) {
    case EVmStateType::Uninitialized: return "Uninitialized";
    case EVmStateType::Invalid: return "Invalid";
    case EVmStateType::Initialized: return "Initialized";
    case EVmStateType::Active: return "Active";
    default:
      unknown_enum_value("EVmStateType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmStateType string_to_EVmStateType(const string& in_str)
  {
    string enum_type_name = "EVmStateType";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 97:
      validate(in_str, "Invalid", enum_type_name);
      return EVmStateType::Invalid;
    case 105:
      validate(in_str, "Active", enum_type_name);
      return EVmStateType::Active;
    case 110:
      validate(in_str, "Uninitialized", enum_type_name);
      return EVmStateType::Uninitialized;
    case 116:
      validate(in_str, "Initialized", enum_type_name);
      return EVmStateType::Initialized;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmStateType::Uninitialized;
  }

  EVmStateType try_string_to_EVmStateType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 97:
      okay = (in_str == "Invalid");
      return EVmStateType::Invalid;
    case 105:
      okay = (in_str == "Active");
      return EVmStateType::Active;
    case 110:
      okay = (in_str == "Uninitialized");
      return EVmStateType::Uninitialized;
    case 116:
      okay = (in_str == "Initialized");
      return EVmStateType::Initialized;
    default:
      okay = false;
      return EVmStateType::Uninitialized;
    }
    return EVmStateType::Uninitialized;
  }


  unsigned char EVmStateBitsSize = 2;

  const string EVmStateBits_to_string(EVmStateBits in_enum)
  {
    switch (in_enum) {
    case EVmStateBits::ActiveMask: return "ActiveMask";
    case EVmStateBits::InitMask: return "InitMask";
    default:
      unknown_enum_value("EVmStateBits", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmStateBits string_to_EVmStateBits(const string& in_str)
  {
    string enum_type_name = "EVmStateBits";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "ActiveMask", enum_type_name);
      return EVmStateBits::ActiveMask;
    case 73:
      validate(in_str, "InitMask", enum_type_name);
      return EVmStateBits::InitMask;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmStateBits::ActiveMask;
  }

  EVmStateBits try_string_to_EVmStateBits(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "ActiveMask");
      return EVmStateBits::ActiveMask;
    case 73:
      okay = (in_str == "InitMask");
      return EVmStateBits::InitMask;
    default:
      okay = false;
      return EVmStateBits::ActiveMask;
    }
    return EVmStateBits::ActiveMask;
  }


  unsigned char EAddrModeStateTypeSize = 2;

  const string EAddrModeStateType_to_string(EAddrModeStateType in_enum)
  {
    switch (in_enum) {
    case EAddrModeStateType::Free: return "Free";
    case EAddrModeStateType::Mapped: return "Mapped";
    default:
      unknown_enum_value("EAddrModeStateType", (unsigned char)(in_enum));
    }
    return "";
  }

  EAddrModeStateType string_to_EAddrModeStateType(const string& in_str)
  {
    string enum_type_name = "EAddrModeStateType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "Free", enum_type_name);
      return EAddrModeStateType::Free;
    case 77:
      validate(in_str, "Mapped", enum_type_name);
      return EAddrModeStateType::Mapped;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EAddrModeStateType::Free;
  }

  EAddrModeStateType try_string_to_EAddrModeStateType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "Free");
      return EAddrModeStateType::Free;
    case 77:
      okay = (in_str == "Mapped");
      return EAddrModeStateType::Mapped;
    default:
      okay = false;
      return EAddrModeStateType::Free;
    }
    return EAddrModeStateType::Free;
  }


  unsigned char ESequenceTypeSize = 27;

  const string ESequenceType_to_string(ESequenceType in_enum)
  {
    switch (in_enum) {
    case ESequenceType::BootLoading: return "BootLoading";
    case ESequenceType::EndOfTest: return "EndOfTest";
    case ESequenceType::Summary: return "Summary";
    case ESequenceType::LoadRegister: return "LoadRegister";
    case ESequenceType::CommitInstruction: return "CommitInstruction";
    case ESequenceType::JumpToStart: return "JumpToStart";
    case ESequenceType::BranchToTarget: return "BranchToTarget";
    case ESequenceType::InitialSetup: return "InitialSetup";
    case ESequenceType::RegisterReservation: return "RegisterReservation";
    case ESequenceType::EscapeCollision: return "EscapeCollision";
    case ESequenceType::BranchNotTaken: return "BranchNotTaken";
    case ESequenceType::BntNode: return "BntNode";
    case ESequenceType::ReExecution: return "ReExecution";
    case ESequenceType::UpdatePeState: return "UpdatePeState";
    case ESequenceType::UpdateRegisterField: return "UpdateRegisterField";
    case ESequenceType::SetRegister: return "SetRegister";
    case ESequenceType::ConfirmSpace: return "ConfirmSpace";
    case ESequenceType::ReloadRegister: return "ReloadRegister";
    case ESequenceType::BatchReloadRegisters: return "BatchReloadRegisters";
    case ESequenceType::SpeculativeBntNode: return "SpeculativeBntNode";
    case ESequenceType::ThreadSummary: return "ThreadSummary";
    case ESequenceType::InitializeAddrTables: return "InitializeAddrTables";
    case ESequenceType::LoadLargeRegister: return "LoadLargeRegister";
    case ESequenceType::BeginRestoreLoop: return "BeginRestoreLoop";
    case ESequenceType::EndRestoreLoop: return "EndRestoreLoop";
    case ESequenceType::RestoreLoopState: return "RestoreLoopState";
    case ESequenceType::LoopReconverge: return "LoopReconverge";
    default:
      unknown_enum_value("ESequenceType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESequenceType string_to_ESequenceType(const string& in_str)
  {
    string enum_type_name = "ESequenceType";
    size_t size = in_str.size();
    char hash_value = in_str.at(8 < size ? 8 : 8 % size) ^ in_str.at(16 < size ? 16 : 16 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "LoopReconverge", enum_type_name);
      return ESequenceType::LoopReconverge;
    case 2:
      validate(in_str, "UpdateRegisterField", enum_type_name);
      return ESequenceType::UpdateRegisterField;
    case 6:
      validate(in_str, "BootLoading", enum_type_name);
      return ESequenceType::BootLoading;
    case 7:
      validate(in_str, "EndOfTest", enum_type_name);
      return ESequenceType::EndOfTest;
    case 8:
      validate(in_str, "ThreadSummary", enum_type_name);
      return ESequenceType::ThreadSummary;
    case 10:
      validate(in_str, "ReExecution", enum_type_name);
      return ESequenceType::ReExecution;
    case 11:
      validate(in_str, "ReloadRegister", enum_type_name);
      return ESequenceType::ReloadRegister;
    case 12:
      validate(in_str, "InitialSetup", enum_type_name);
      return ESequenceType::InitialSetup;
    case 13:
      validate(in_str, "SpeculativeBntNode", enum_type_name);
      return ESequenceType::SpeculativeBntNode;
    case 14:
      validate(in_str, "JumpToStart", enum_type_name);
      return ESequenceType::JumpToStart;
    case 19:
      validate(in_str, "SetRegister", enum_type_name);
      return ESequenceType::SetRegister;
    case 21:
      validate(in_str, "BranchNotTaken", enum_type_name);
      return ESequenceType::BranchNotTaken;
    case 22:
      validate(in_str, "EndRestoreLoop", enum_type_name);
      return ESequenceType::EndRestoreLoop;
    case 23:
      validate(in_str, "LoadLargeRegister", enum_type_name);
      return ESequenceType::LoadLargeRegister;
    case 24:
      {
        char hash_value_24 = in_str.at(0);

        switch (hash_value_24) {
        case 73:
          validate(in_str, "InitializeAddrTables", enum_type_name);
          return ESequenceType::InitializeAddrTables;
        case 83:
          validate(in_str, "Summary", enum_type_name);
          return ESequenceType::Summary;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 25:
      validate(in_str, "ConfirmSpace", enum_type_name);
      return ESequenceType::ConfirmSpace;
    case 26:
      validate(in_str, "BntNode", enum_type_name);
      return ESequenceType::BntNode;
    case 27:
      validate(in_str, "BatchReloadRegisters", enum_type_name);
      return ESequenceType::BatchReloadRegisters;
    case 29:
      validate(in_str, "CommitInstruction", enum_type_name);
      return ESequenceType::CommitInstruction;
    case 31:
      validate(in_str, "EscapeCollision", enum_type_name);
      return ESequenceType::EscapeCollision;
    case 33:
      validate(in_str, "LoadRegister", enum_type_name);
      return ESequenceType::LoadRegister;
    case 50:
      validate(in_str, "UpdatePeState", enum_type_name);
      return ESequenceType::UpdatePeState;
    case 53:
      validate(in_str, "BranchToTarget", enum_type_name);
      return ESequenceType::BranchToTarget;
    case 54:
      validate(in_str, "BeginRestoreLoop", enum_type_name);
      return ESequenceType::BeginRestoreLoop;
    case 59:
      validate(in_str, "RegisterReservation", enum_type_name);
      return ESequenceType::RegisterReservation;
    case 61:
      validate(in_str, "RestoreLoopState", enum_type_name);
      return ESequenceType::RestoreLoopState;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESequenceType::BootLoading;
  }

  ESequenceType try_string_to_ESequenceType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(8 < size ? 8 : 8 % size) ^ in_str.at(16 < size ? 16 : 16 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "LoopReconverge");
      return ESequenceType::LoopReconverge;
    case 2:
      okay = (in_str == "UpdateRegisterField");
      return ESequenceType::UpdateRegisterField;
    case 6:
      okay = (in_str == "BootLoading");
      return ESequenceType::BootLoading;
    case 7:
      okay = (in_str == "EndOfTest");
      return ESequenceType::EndOfTest;
    case 8:
      okay = (in_str == "ThreadSummary");
      return ESequenceType::ThreadSummary;
    case 10:
      okay = (in_str == "ReExecution");
      return ESequenceType::ReExecution;
    case 11:
      okay = (in_str == "ReloadRegister");
      return ESequenceType::ReloadRegister;
    case 12:
      okay = (in_str == "InitialSetup");
      return ESequenceType::InitialSetup;
    case 13:
      okay = (in_str == "SpeculativeBntNode");
      return ESequenceType::SpeculativeBntNode;
    case 14:
      okay = (in_str == "JumpToStart");
      return ESequenceType::JumpToStart;
    case 19:
      okay = (in_str == "SetRegister");
      return ESequenceType::SetRegister;
    case 21:
      okay = (in_str == "BranchNotTaken");
      return ESequenceType::BranchNotTaken;
    case 22:
      okay = (in_str == "EndRestoreLoop");
      return ESequenceType::EndRestoreLoop;
    case 23:
      okay = (in_str == "LoadLargeRegister");
      return ESequenceType::LoadLargeRegister;
    case 24:
      {
        char hash_value_24 = in_str.at(0);

        switch (hash_value_24) {
        case 73:
          okay = (in_str == "InitializeAddrTables");
          return ESequenceType::InitializeAddrTables;
        case 83:
          okay = (in_str == "Summary");
          return ESequenceType::Summary;
        default:
          okay = false;
          return ESequenceType::BootLoading;
        }
      }
    case 25:
      okay = (in_str == "ConfirmSpace");
      return ESequenceType::ConfirmSpace;
    case 26:
      okay = (in_str == "BntNode");
      return ESequenceType::BntNode;
    case 27:
      okay = (in_str == "BatchReloadRegisters");
      return ESequenceType::BatchReloadRegisters;
    case 29:
      okay = (in_str == "CommitInstruction");
      return ESequenceType::CommitInstruction;
    case 31:
      okay = (in_str == "EscapeCollision");
      return ESequenceType::EscapeCollision;
    case 33:
      okay = (in_str == "LoadRegister");
      return ESequenceType::LoadRegister;
    case 50:
      okay = (in_str == "UpdatePeState");
      return ESequenceType::UpdatePeState;
    case 53:
      okay = (in_str == "BranchToTarget");
      return ESequenceType::BranchToTarget;
    case 54:
      okay = (in_str == "BeginRestoreLoop");
      return ESequenceType::BeginRestoreLoop;
    case 59:
      okay = (in_str == "RegisterReservation");
      return ESequenceType::RegisterReservation;
    case 61:
      okay = (in_str == "RestoreLoopState");
      return ESequenceType::RestoreLoopState;
    default:
      okay = false;
      return ESequenceType::BootLoading;
    }
    return ESequenceType::BootLoading;
  }


  unsigned char ECallBackTypeSize = 2;

  const string ECallBackType_to_string(ECallBackType in_enum)
  {
    switch (in_enum) {
    case ECallBackType::Bnt: return "Bnt";
    case ECallBackType::Eret: return "Eret";
    default:
      unknown_enum_value("ECallBackType", (unsigned char)(in_enum));
    }
    return "";
  }

  ECallBackType string_to_ECallBackType(const string& in_str)
  {
    string enum_type_name = "ECallBackType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      validate(in_str, "Bnt", enum_type_name);
      return ECallBackType::Bnt;
    case 69:
      validate(in_str, "Eret", enum_type_name);
      return ECallBackType::Eret;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ECallBackType::Bnt;
  }

  ECallBackType try_string_to_ECallBackType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      okay = (in_str == "Bnt");
      return ECallBackType::Bnt;
    case 69:
      okay = (in_str == "Eret");
      return ECallBackType::Eret;
    default:
      okay = false;
      return ECallBackType::Bnt;
    }
    return ECallBackType::Bnt;
  }


  unsigned char EExtendTypeSize = 5;

  const string EExtendType_to_string(EExtendType in_enum)
  {
    switch (in_enum) {
    case EExtendType::UXTW: return "UXTW";
    case EExtendType::LSL: return "LSL";
    case EExtendType::SXTW: return "SXTW";
    case EExtendType::SXTX: return "SXTX";
    case EExtendType::UXTX: return "UXTX";
    default:
      unknown_enum_value("EExtendType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExtendType string_to_EExtendType(const string& in_str)
  {
    string enum_type_name = "EExtendType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 0:
      validate(in_str, "LSL", enum_type_name);
      return EExtendType::LSL;
    case 2:
      validate(in_str, "UXTW", enum_type_name);
      return EExtendType::UXTW;
    case 4:
      validate(in_str, "SXTW", enum_type_name);
      return EExtendType::SXTW;
    case 11:
      validate(in_str, "SXTX", enum_type_name);
      return EExtendType::SXTX;
    case 13:
      validate(in_str, "UXTX", enum_type_name);
      return EExtendType::UXTX;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExtendType::UXTW;
  }

  EExtendType try_string_to_EExtendType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 0:
      okay = (in_str == "LSL");
      return EExtendType::LSL;
    case 2:
      okay = (in_str == "UXTW");
      return EExtendType::UXTW;
    case 4:
      okay = (in_str == "SXTW");
      return EExtendType::SXTW;
    case 11:
      okay = (in_str == "SXTX");
      return EExtendType::SXTX;
    case 13:
      okay = (in_str == "UXTX");
      return EExtendType::UXTX;
    default:
      okay = false;
      return EExtendType::UXTW;
    }
    return EExtendType::UXTW;
  }


  unsigned char EVmRequestTypeSize = 9;

  const string EVmRequestType_to_string(EVmRequestType in_enum)
  {
    switch (in_enum) {
    case EVmRequestType::GenPA: return "GenPA";
    case EVmRequestType::GenVA: return "GenVA";
    case EVmRequestType::GenVAforPA: return "GenVAforPA";
    case EVmRequestType::GenPage: return "GenPage";
    case EVmRequestType::GenFreePage: return "GenFreePage";
    case EVmRequestType::PhysicalRegion: return "PhysicalRegion";
    case EVmRequestType::GenVMVA: return "GenVMVA";
    case EVmRequestType::GenVmContext: return "GenVmContext";
    case EVmRequestType::UpdateVm: return "UpdateVm";
    default:
      unknown_enum_value("EVmRequestType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmRequestType string_to_EVmRequestType(const string& in_str)
  {
    string enum_type_name = "EVmRequestType";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(5 < size ? 5 : 5 % size);

    switch (hash_value) {
    case 0:
      validate(in_str, "GenVMVA", enum_type_name);
      return EVmRequestType::GenVMVA;
    case 4:
      validate(in_str, "UpdateVm", enum_type_name);
      return EVmRequestType::UpdateVm;
    case 16:
      validate(in_str, "PhysicalRegion", enum_type_name);
      return EVmRequestType::PhysicalRegion;
    case 17:
      validate(in_str, "GenVA", enum_type_name);
      return EVmRequestType::GenVA;
    case 21:
      validate(in_str, "GenVmContext", enum_type_name);
      return EVmRequestType::GenVmContext;
    case 23:
      validate(in_str, "GenPA", enum_type_name);
      return EVmRequestType::GenPA;
    case 35:
      validate(in_str, "GenFreePage", enum_type_name);
      return EVmRequestType::GenFreePage;
    case 48:
      validate(in_str, "GenVAforPA", enum_type_name);
      return EVmRequestType::GenVAforPA;
    case 55:
      validate(in_str, "GenPage", enum_type_name);
      return EVmRequestType::GenPage;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmRequestType::GenPA;
  }

  EVmRequestType try_string_to_EVmRequestType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(5 < size ? 5 : 5 % size);

    switch (hash_value) {
    case 0:
      okay = (in_str == "GenVMVA");
      return EVmRequestType::GenVMVA;
    case 4:
      okay = (in_str == "UpdateVm");
      return EVmRequestType::UpdateVm;
    case 16:
      okay = (in_str == "PhysicalRegion");
      return EVmRequestType::PhysicalRegion;
    case 17:
      okay = (in_str == "GenVA");
      return EVmRequestType::GenVA;
    case 21:
      okay = (in_str == "GenVmContext");
      return EVmRequestType::GenVmContext;
    case 23:
      okay = (in_str == "GenPA");
      return EVmRequestType::GenPA;
    case 35:
      okay = (in_str == "GenFreePage");
      return EVmRequestType::GenFreePage;
    case 48:
      okay = (in_str == "GenVAforPA");
      return EVmRequestType::GenVAforPA;
    case 55:
      okay = (in_str == "GenPage");
      return EVmRequestType::GenPage;
    default:
      okay = false;
      return EVmRequestType::GenPA;
    }
    return EVmRequestType::GenPA;
  }


  unsigned char EInstrBoolAttrTypeSize = 10;

  const string EInstrBoolAttrType_to_string(EInstrBoolAttrType in_enum)
  {
    switch (in_enum) {
    case EInstrBoolAttrType::NoSkip: return "NoSkip";
    case EInstrBoolAttrType::NoRestriction: return "NoRestriction";
    case EInstrBoolAttrType::UnalignedPC: return "UnalignedPC";
    case EInstrBoolAttrType::AlignedData: return "AlignedData";
    case EInstrBoolAttrType::AlignedSP: return "AlignedSP";
    case EInstrBoolAttrType::NoBnt: return "NoBnt";
    case EInstrBoolAttrType::NoPreamble: return "NoPreamble";
    case EInstrBoolAttrType::SpeculativeBnt: return "SpeculativeBnt";
    case EInstrBoolAttrType::NoDataAbort: return "NoDataAbort";
    case EInstrBoolAttrType::SharedTarget: return "SharedTarget";
    default:
      unknown_enum_value("EInstrBoolAttrType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstrBoolAttrType string_to_EInstrBoolAttrType(const string& in_str)
  {
    string enum_type_name = "EInstrBoolAttrType";
    size_t size = in_str.size();
    char hash_value = in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 80:
      validate(in_str, "AlignedSP", enum_type_name);
      return EInstrBoolAttrType::AlignedSP;
    case 83:
      validate(in_str, "NoSkip", enum_type_name);
      return EInstrBoolAttrType::NoSkip;
    case 97:
      validate(in_str, "AlignedData", enum_type_name);
      return EInstrBoolAttrType::AlignedData;
    case 99:
      validate(in_str, "NoRestriction", enum_type_name);
      return EInstrBoolAttrType::NoRestriction;
    case 100:
      validate(in_str, "UnalignedPC", enum_type_name);
      return EInstrBoolAttrType::UnalignedPC;
    case 105:
      validate(in_str, "SpeculativeBnt", enum_type_name);
      return EInstrBoolAttrType::SpeculativeBnt;
    case 108:
      validate(in_str, "NoPreamble", enum_type_name);
      return EInstrBoolAttrType::NoPreamble;
    case 110:
      validate(in_str, "NoBnt", enum_type_name);
      return EInstrBoolAttrType::NoBnt;
    case 111:
      validate(in_str, "NoDataAbort", enum_type_name);
      return EInstrBoolAttrType::NoDataAbort;
    case 114:
      validate(in_str, "SharedTarget", enum_type_name);
      return EInstrBoolAttrType::SharedTarget;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstrBoolAttrType::NoSkip;
  }

  EInstrBoolAttrType try_string_to_EInstrBoolAttrType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 80:
      okay = (in_str == "AlignedSP");
      return EInstrBoolAttrType::AlignedSP;
    case 83:
      okay = (in_str == "NoSkip");
      return EInstrBoolAttrType::NoSkip;
    case 97:
      okay = (in_str == "AlignedData");
      return EInstrBoolAttrType::AlignedData;
    case 99:
      okay = (in_str == "NoRestriction");
      return EInstrBoolAttrType::NoRestriction;
    case 100:
      okay = (in_str == "UnalignedPC");
      return EInstrBoolAttrType::UnalignedPC;
    case 105:
      okay = (in_str == "SpeculativeBnt");
      return EInstrBoolAttrType::SpeculativeBnt;
    case 108:
      okay = (in_str == "NoPreamble");
      return EInstrBoolAttrType::NoPreamble;
    case 110:
      okay = (in_str == "NoBnt");
      return EInstrBoolAttrType::NoBnt;
    case 111:
      okay = (in_str == "NoDataAbort");
      return EInstrBoolAttrType::NoDataAbort;
    case 114:
      okay = (in_str == "SharedTarget");
      return EInstrBoolAttrType::SharedTarget;
    default:
      okay = false;
      return EInstrBoolAttrType::NoSkip;
    }
    return EInstrBoolAttrType::NoSkip;
  }


  unsigned char EInstrConstraintAttrTypeSize = 3;

  const string EInstrConstraintAttrType_to_string(EInstrConstraintAttrType in_enum)
  {
    switch (in_enum) {
    case EInstrConstraintAttrType::LSTarget: return "LSTarget";
    case EInstrConstraintAttrType::BRTarget: return "BRTarget";
    case EInstrConstraintAttrType::CondTaken: return "CondTaken";
    default:
      unknown_enum_value("EInstrConstraintAttrType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstrConstraintAttrType string_to_EInstrConstraintAttrType(const string& in_str)
  {
    string enum_type_name = "EInstrConstraintAttrType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      validate(in_str, "BRTarget", enum_type_name);
      return EInstrConstraintAttrType::BRTarget;
    case 67:
      validate(in_str, "CondTaken", enum_type_name);
      return EInstrConstraintAttrType::CondTaken;
    case 76:
      validate(in_str, "LSTarget", enum_type_name);
      return EInstrConstraintAttrType::LSTarget;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstrConstraintAttrType::LSTarget;
  }

  EInstrConstraintAttrType try_string_to_EInstrConstraintAttrType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      okay = (in_str == "BRTarget");
      return EInstrConstraintAttrType::BRTarget;
    case 67:
      okay = (in_str == "CondTaken");
      return EInstrConstraintAttrType::CondTaken;
    case 76:
      okay = (in_str == "LSTarget");
      return EInstrConstraintAttrType::LSTarget;
    default:
      okay = false;
      return EInstrConstraintAttrType::LSTarget;
    }
    return EInstrConstraintAttrType::LSTarget;
  }


  unsigned char EBntAttributeTypeSize = 3;

  const string EBntAttributeType_to_string(EBntAttributeType in_enum)
  {
    switch (in_enum) {
    case EBntAttributeType::Taken: return "Taken";
    case EBntAttributeType::Conditional: return "Conditional";
    case EBntAttributeType::Accurate: return "Accurate";
    default:
      unknown_enum_value("EBntAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EBntAttributeType string_to_EBntAttributeType(const string& in_str)
  {
    string enum_type_name = "EBntAttributeType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "Accurate", enum_type_name);
      return EBntAttributeType::Accurate;
    case 67:
      validate(in_str, "Conditional", enum_type_name);
      return EBntAttributeType::Conditional;
    case 84:
      validate(in_str, "Taken", enum_type_name);
      return EBntAttributeType::Taken;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EBntAttributeType::Taken;
  }

  EBntAttributeType try_string_to_EBntAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "Accurate");
      return EBntAttributeType::Accurate;
    case 67:
      okay = (in_str == "Conditional");
      return EBntAttributeType::Conditional;
    case 84:
      okay = (in_str == "Taken");
      return EBntAttributeType::Taken;
    default:
      okay = false;
      return EBntAttributeType::Taken;
    }
    return EBntAttributeType::Taken;
  }


  unsigned char EAluOperationTypeSize = 3;

  const string EAluOperationType_to_string(EAluOperationType in_enum)
  {
    switch (in_enum) {
    case EAluOperationType::Unknown: return "Unknown";
    case EAluOperationType::ADD: return "ADD";
    case EAluOperationType::SUB: return "SUB";
    default:
      unknown_enum_value("EAluOperationType", (unsigned char)(in_enum));
    }
    return "";
  }

  EAluOperationType string_to_EAluOperationType(const string& in_str)
  {
    string enum_type_name = "EAluOperationType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "ADD", enum_type_name);
      return EAluOperationType::ADD;
    case 83:
      validate(in_str, "SUB", enum_type_name);
      return EAluOperationType::SUB;
    case 85:
      validate(in_str, "Unknown", enum_type_name);
      return EAluOperationType::Unknown;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EAluOperationType::Unknown;
  }

  EAluOperationType try_string_to_EAluOperationType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "ADD");
      return EAluOperationType::ADD;
    case 83:
      okay = (in_str == "SUB");
      return EAluOperationType::SUB;
    case 85:
      okay = (in_str == "Unknown");
      return EAluOperationType::Unknown;
    default:
      okay = false;
      return EAluOperationType::Unknown;
    }
    return EAluOperationType::Unknown;
  }


  unsigned char EDataProcessingOperationTypeSize = 71;

  const string EDataProcessingOperationType_to_string(EDataProcessingOperationType in_enum)
  {
    switch (in_enum) {
    case EDataProcessingOperationType::Unknown: return "Unknown";
    case EDataProcessingOperationType::MulAdd: return "MulAdd";
    case EDataProcessingOperationType::Mul: return "Mul";
    case EDataProcessingOperationType::UDiv: return "UDiv";
    case EDataProcessingOperationType::SDiv: return "SDiv";
    case EDataProcessingOperationType::AddWithCarry: return "AddWithCarry";
    case EDataProcessingOperationType::SubWithCarry: return "SubWithCarry";
    case EDataProcessingOperationType::AndShift32: return "AndShift32";
    case EDataProcessingOperationType::AndShift64: return "AndShift64";
    case EDataProcessingOperationType::BicClearShift32: return "BicClearShift32";
    case EDataProcessingOperationType::BicClearShift64: return "BicClearShift64";
    case EDataProcessingOperationType::EonExcOrNotShift32: return "EonExcOrNotShift32";
    case EDataProcessingOperationType::EonExcOrNotShift64: return "EonExcOrNotShift64";
    case EDataProcessingOperationType::EorExcOrShift32: return "EorExcOrShift32";
    case EDataProcessingOperationType::EorExcOrShift64: return "EorExcOrShift64";
    case EDataProcessingOperationType::OrrIncOrShift32: return "OrrIncOrShift32";
    case EDataProcessingOperationType::OrrIncOrShift64: return "OrrIncOrShift64";
    case EDataProcessingOperationType::MvnNotShift32: return "MvnNotShift32";
    case EDataProcessingOperationType::MvnNotShift64: return "MvnNotShift64";
    case EDataProcessingOperationType::OrnIncOrNotShift32: return "OrnIncOrNotShift32";
    case EDataProcessingOperationType::OrnIncOrNotShift64: return "OrnIncOrNotShift64";
    case EDataProcessingOperationType::MsubMulSub32: return "MsubMulSub32";
    case EDataProcessingOperationType::MsubMulSub64: return "MsubMulSub64";
    case EDataProcessingOperationType::MnegMulNot32: return "MnegMulNot32";
    case EDataProcessingOperationType::MnegMulNot64: return "MnegMulNot64";
    case EDataProcessingOperationType::SmaddlSigMulAddLong: return "SmaddlSigMulAddLong";
    case EDataProcessingOperationType::SmsublSigMulSubLong: return "SmsublSigMulSubLong";
    case EDataProcessingOperationType::SmneglSigMulNotLong: return "SmneglSigMulNotLong";
    case EDataProcessingOperationType::SmullSigMulLong: return "SmullSigMulLong";
    case EDataProcessingOperationType::SmulhSigMulHigh: return "SmulhSigMulHigh";
    case EDataProcessingOperationType::UmaddlMulAddLong: return "UmaddlMulAddLong";
    case EDataProcessingOperationType::UmsublMulSubLong: return "UmsublMulSubLong";
    case EDataProcessingOperationType::UmneglMulNotLong: return "UmneglMulNotLong";
    case EDataProcessingOperationType::UmullMulLong: return "UmullMulLong";
    case EDataProcessingOperationType::UmulhMulHigh: return "UmulhMulHigh";
    case EDataProcessingOperationType::AndImm32: return "AndImm32";
    case EDataProcessingOperationType::AndImm64: return "AndImm64";
    case EDataProcessingOperationType::EorExcOrImm32: return "EorExcOrImm32";
    case EDataProcessingOperationType::EorExcOrImm64: return "EorExcOrImm64";
    case EDataProcessingOperationType::OrrIncOrImm32: return "OrrIncOrImm32";
    case EDataProcessingOperationType::OrrIncOrImm64: return "OrrIncOrImm64";
    case EDataProcessingOperationType::AddExt32: return "AddExt32";
    case EDataProcessingOperationType::AddExt64: return "AddExt64";
    case EDataProcessingOperationType::AddShift32: return "AddShift32";
    case EDataProcessingOperationType::AddShift64: return "AddShift64";
    case EDataProcessingOperationType::SubExt32: return "SubExt32";
    case EDataProcessingOperationType::SubExt64: return "SubExt64";
    case EDataProcessingOperationType::SubShift32: return "SubShift32";
    case EDataProcessingOperationType::SubShift64: return "SubShift64";
    case EDataProcessingOperationType::AddsAddSetFlagsExt32: return "AddsAddSetFlagsExt32";
    case EDataProcessingOperationType::AddsAddSetFlagsExt64: return "AddsAddSetFlagsExt64";
    case EDataProcessingOperationType::AddsAddSetFlagsShift32: return "AddsAddSetFlagsShift32";
    case EDataProcessingOperationType::AddsAddSetFlagsShift64: return "AddsAddSetFlagsShift64";
    case EDataProcessingOperationType::SubsSubSetFlagsExt32: return "SubsSubSetFlagsExt32";
    case EDataProcessingOperationType::SubsSubSetFlagsExt64: return "SubsSubSetFlagsExt64";
    case EDataProcessingOperationType::SubsSubSetFlagsShift32: return "SubsSubSetFlagsShift32";
    case EDataProcessingOperationType::SubsSubSetFlagsShift64: return "SubsSubSetFlagsShift64";
    case EDataProcessingOperationType::NegNegateShift32: return "NegNegateShift32";
    case EDataProcessingOperationType::NegNegateShift64: return "NegNegateShift64";
    case EDataProcessingOperationType::NegsNegateSetFlagsShift32: return "NegsNegateSetFlagsShift32";
    case EDataProcessingOperationType::NegsNegateSetFlagsShift64: return "NegsNegateSetFlagsShift64";
    case EDataProcessingOperationType::NgcNegateWithCarry32: return "NgcNegateWithCarry32";
    case EDataProcessingOperationType::NgcNegateWithCarry64: return "NgcNegateWithCarry64";
    case EDataProcessingOperationType::NgcsNegateWithCarrySetFlags32: return "NgcsNegateWithCarrySetFlags32";
    case EDataProcessingOperationType::NgcsNegateWithCarrySetFlags64: return "NgcsNegateWithCarrySetFlags64";
    case EDataProcessingOperationType::AndsAndSetFlagsShift32: return "AndsAndSetFlagsShift32";
    case EDataProcessingOperationType::AndsAndSetFlagsShift64: return "AndsAndSetFlagsShift64";
    case EDataProcessingOperationType::AndsAndSetFlagsImm32: return "AndsAndSetFlagsImm32";
    case EDataProcessingOperationType::AndsAndSetFlagsImm64: return "AndsAndSetFlagsImm64";
    case EDataProcessingOperationType::BicsClearSetFlagsShift32: return "BicsClearSetFlagsShift32";
    case EDataProcessingOperationType::BicsClearSetFlagsShift64: return "BicsClearSetFlagsShift64";
    default:
      unknown_enum_value("EDataProcessingOperationType", (unsigned char)(in_enum));
    }
    return "";
  }

  EDataProcessingOperationType string_to_EDataProcessingOperationType(const string& in_str)
  {
    string enum_type_name = "EDataProcessingOperationType";
    size_t size = in_str.size();
    char hash_value = in_str.at(13 < size ? 13 : 13 % size) ^ in_str.at(18 < size ? 18 : 18 % size) ^ in_str.at(22 < size ? 22 : 22 % size);

    switch (hash_value) {
    case 1:
      {
        size_t size_1 = in_str.size();
        char hash_value_1 = in_str.at(1 < size_1 ? 1 : 1 % size_1);

        switch (hash_value_1) {
        case 100:
          validate(in_str, "AddShift64", enum_type_name);
          return EDataProcessingOperationType::AddShift64;
        case 110:
          validate(in_str, "AndShift64", enum_type_name);
          return EDataProcessingOperationType::AndShift64;
        case 111:
          validate(in_str, "EorExcOrShift64", enum_type_name);
          return EDataProcessingOperationType::EorExcOrShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 2:
      {
        char hash_value_2 = in_str.at(0);

        switch (hash_value_2) {
        case 66:
          validate(in_str, "BicClearShift32", enum_type_name);
          return EDataProcessingOperationType::BicClearShift32;
        case 83:
          validate(in_str, "SubShift32", enum_type_name);
          return EDataProcessingOperationType::SubShift32;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 4:
      {
        size_t size_4 = in_str.size();
        char hash_value_4 = in_str.at(1 < size_4 ? 1 : 1 % size_4);

        switch (hash_value_4) {
        case 100:
          validate(in_str, "AddShift32", enum_type_name);
          return EDataProcessingOperationType::AddShift32;
        case 110:
          validate(in_str, "AndShift32", enum_type_name);
          return EDataProcessingOperationType::AndShift32;
        case 111:
          validate(in_str, "EorExcOrShift32", enum_type_name);
          return EDataProcessingOperationType::EorExcOrShift32;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 7:
      {
        char hash_value_7 = in_str.at(0);

        switch (hash_value_7) {
        case 66:
          validate(in_str, "BicClearShift64", enum_type_name);
          return EDataProcessingOperationType::BicClearShift64;
        case 83:
          validate(in_str, "SubShift64", enum_type_name);
          return EDataProcessingOperationType::SubShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 8:
      validate(in_str, "OrrIncOrShift32", enum_type_name);
      return EDataProcessingOperationType::OrrIncOrShift32;
    case 13:
      validate(in_str, "OrrIncOrShift64", enum_type_name);
      return EDataProcessingOperationType::OrrIncOrShift64;
    case 19:
      validate(in_str, "NgcNegateWithCarry32", enum_type_name);
      return EDataProcessingOperationType::NgcNegateWithCarry32;
    case 22:
      validate(in_str, "NgcNegateWithCarry64", enum_type_name);
      return EDataProcessingOperationType::NgcNegateWithCarry64;
    case 32:
      validate(in_str, "SubExt64", enum_type_name);
      return EDataProcessingOperationType::SubExt64;
    case 35:
      validate(in_str, "AddExt32", enum_type_name);
      return EDataProcessingOperationType::AddExt32;
    case 37:
      validate(in_str, "SubExt32", enum_type_name);
      return EDataProcessingOperationType::SubExt32;
    case 38:
      validate(in_str, "AddExt64", enum_type_name);
      return EDataProcessingOperationType::AddExt64;
    case 41:
      validate(in_str, "MsubMulSub64", enum_type_name);
      return EDataProcessingOperationType::MsubMulSub64;
    case 44:
      validate(in_str, "MsubMulSub32", enum_type_name);
      return EDataProcessingOperationType::MsubMulSub32;
    case 48:
      {
        size_t size_48 = in_str.size();
        char hash_value_48 = in_str.at(1 < size_48 ? 1 : 1 % size_48);

        switch (hash_value_48) {
        case 100:
          validate(in_str, "AddsAddSetFlagsExt32", enum_type_name);
          return EDataProcessingOperationType::AddsAddSetFlagsExt32;
        case 110:
          validate(in_str, "AndsAndSetFlagsImm32", enum_type_name);
          return EDataProcessingOperationType::AndsAndSetFlagsImm32;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 49:
      validate(in_str, "MnegMulNot32", enum_type_name);
      return EDataProcessingOperationType::MnegMulNot32;
    case 50:
      validate(in_str, "BicsClearSetFlagsShift64", enum_type_name);
      return EDataProcessingOperationType::BicsClearSetFlagsShift64;
    case 51:
      validate(in_str, "SubsSubSetFlagsExt64", enum_type_name);
      return EDataProcessingOperationType::SubsSubSetFlagsExt64;
    case 52:
      validate(in_str, "MnegMulNot64", enum_type_name);
      return EDataProcessingOperationType::MnegMulNot64;
    case 53:
      {
        size_t size_53 = in_str.size();
        char hash_value_53 = in_str.at(1 < size_53 ? 1 : 1 % size_53);

        switch (hash_value_53) {
        case 100:
          validate(in_str, "AddsAddSetFlagsExt64", enum_type_name);
          return EDataProcessingOperationType::AddsAddSetFlagsExt64;
        case 110:
          validate(in_str, "AndsAndSetFlagsImm64", enum_type_name);
          return EDataProcessingOperationType::AndsAndSetFlagsImm64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 54:
      validate(in_str, "SubsSubSetFlagsExt32", enum_type_name);
      return EDataProcessingOperationType::SubsSubSetFlagsExt32;
    case 55:
      validate(in_str, "BicsClearSetFlagsShift32", enum_type_name);
      return EDataProcessingOperationType::BicsClearSetFlagsShift32;
    case 58:
      validate(in_str, "AndImm32", enum_type_name);
      return EDataProcessingOperationType::AndImm32;
    case 63:
      validate(in_str, "AndImm64", enum_type_name);
      return EDataProcessingOperationType::AndImm64;
    case 64:
      {
        size_t size_64 = in_str.size();
        char hash_value_64 = in_str.at(1 < size_64 ? 1 : 1 % size_64) ^ in_str.at(20 < size_64 ? 20 : 20 % size_64);

        switch (hash_value_64) {
        case 82:
          validate(in_str, "AddsAddSetFlagsShift64", enum_type_name);
          return EDataProcessingOperationType::AddsAddSetFlagsShift64;
        case 87:
          validate(in_str, "AddsAddSetFlagsShift32", enum_type_name);
          return EDataProcessingOperationType::AddsAddSetFlagsShift32;
        case 88:
          validate(in_str, "AndsAndSetFlagsShift64", enum_type_name);
          return EDataProcessingOperationType::AndsAndSetFlagsShift64;
        case 93:
          validate(in_str, "AndsAndSetFlagsShift32", enum_type_name);
          return EDataProcessingOperationType::AndsAndSetFlagsShift32;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 65:
      {
        size_t size_65 = in_str.size();
        char hash_value_65 = in_str.at(11 < size_65 ? 11 : 11 % size_65);

        switch (hash_value_65) {
        case 51:
          validate(in_str, "OrrIncOrImm32", enum_type_name);
          return EDataProcessingOperationType::OrrIncOrImm32;
        case 54:
          validate(in_str, "OrrIncOrImm64", enum_type_name);
          return EDataProcessingOperationType::OrrIncOrImm64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 67:
      validate(in_str, "UmaddlMulAddLong", enum_type_name);
      return EDataProcessingOperationType::UmaddlMulAddLong;
    case 68:
      {
        char hash_value_68 = in_str.at(0);

        switch (hash_value_68) {
        case 83:
          validate(in_str, "SDiv", enum_type_name);
          return EDataProcessingOperationType::SDiv;
        case 85:
          validate(in_str, "UDiv", enum_type_name);
          return EDataProcessingOperationType::UDiv;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 72:
      {
        size_t size_72 = in_str.size();
        char hash_value_72 = in_str.at(16 < size_72 ? 16 : 16 % size_72);

        switch (hash_value_72) {
        case 51:
          validate(in_str, "OrnIncOrNotShift32", enum_type_name);
          return EDataProcessingOperationType::OrnIncOrNotShift32;
        case 54:
          validate(in_str, "OrnIncOrNotShift64", enum_type_name);
          return EDataProcessingOperationType::OrnIncOrNotShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 75:
      {
        size_t size_75 = in_str.size();
        char hash_value_75 = in_str.at(11 < size_75 ? 11 : 11 % size_75);

        switch (hash_value_75) {
        case 51:
          validate(in_str, "EorExcOrImm32", enum_type_name);
          return EDataProcessingOperationType::EorExcOrImm32;
        case 54:
          validate(in_str, "EorExcOrImm64", enum_type_name);
          return EDataProcessingOperationType::EorExcOrImm64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 76:
      validate(in_str, "UmneglMulNotLong", enum_type_name);
      return EDataProcessingOperationType::UmneglMulNotLong;
    case 77:
      validate(in_str, "Mul", enum_type_name);
      return EDataProcessingOperationType::Mul;
    case 81:
      validate(in_str, "UmsublMulSubLong", enum_type_name);
      return EDataProcessingOperationType::UmsublMulSubLong;
    case 82:
      {
        size_t size_82 = in_str.size();
        char hash_value_82 = in_str.at(20 < size_82 ? 20 : 20 % size_82);

        switch (hash_value_82) {
        case 51:
          validate(in_str, "SubsSubSetFlagsShift32", enum_type_name);
          return EDataProcessingOperationType::SubsSubSetFlagsShift32;
        case 54:
          validate(in_str, "SubsSubSetFlagsShift64", enum_type_name);
          return EDataProcessingOperationType::SubsSubSetFlagsShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 84:
      {
        size_t size_84 = in_str.size();
        char hash_value_84 = in_str.at(16 < size_84 ? 16 : 16 % size_84);

        switch (hash_value_84) {
        case 51:
          validate(in_str, "EonExcOrNotShift32", enum_type_name);
          return EDataProcessingOperationType::EonExcOrNotShift32;
        case 54:
          validate(in_str, "EonExcOrNotShift64", enum_type_name);
          return EDataProcessingOperationType::EonExcOrNotShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 87:
      {
        size_t size_87 = in_str.size();
        char hash_value_87 = in_str.at(27 < size_87 ? 27 : 27 % size_87);

        switch (hash_value_87) {
        case 51:
          validate(in_str, "NgcsNegateWithCarrySetFlags32", enum_type_name);
          return EDataProcessingOperationType::NgcsNegateWithCarrySetFlags32;
        case 54:
          validate(in_str, "NgcsNegateWithCarrySetFlags64", enum_type_name);
          return EDataProcessingOperationType::NgcsNegateWithCarrySetFlags64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 92:
      validate(in_str, "MulAdd", enum_type_name);
      return EDataProcessingOperationType::MulAdd;
    case 95:
      {
        size_t size_95 = in_str.size();
        char hash_value_95 = in_str.at(11 < size_95 ? 11 : 11 % size_95);

        switch (hash_value_95) {
        case 51:
          validate(in_str, "MvnNotShift32", enum_type_name);
          return EDataProcessingOperationType::MvnNotShift32;
        case 54:
          validate(in_str, "MvnNotShift64", enum_type_name);
          return EDataProcessingOperationType::MvnNotShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 97:
      {
        size_t size_97 = in_str.size();
        char hash_value_97 = in_str.at(23 < size_97 ? 23 : 23 % size_97);

        switch (hash_value_97) {
        case 51:
          validate(in_str, "NegsNegateSetFlagsShift32", enum_type_name);
          return EDataProcessingOperationType::NegsNegateSetFlagsShift32;
        case 54:
          validate(in_str, "NegsNegateSetFlagsShift64", enum_type_name);
          return EDataProcessingOperationType::NegsNegateSetFlagsShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 101:
      validate(in_str, "SmullSigMulLong", enum_type_name);
      return EDataProcessingOperationType::SmullSigMulLong;
    case 103:
      {
        size_t size_103 = in_str.size();
        char hash_value_103 = in_str.at(2 < size_103 ? 2 : 2 % size_103);

        switch (hash_value_103) {
        case 97:
          validate(in_str, "SmaddlSigMulAddLong", enum_type_name);
          return EDataProcessingOperationType::SmaddlSigMulAddLong;
        case 115:
          validate(in_str, "SmsublSigMulSubLong", enum_type_name);
          return EDataProcessingOperationType::SmsublSigMulSubLong;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 108:
      validate(in_str, "SmulhSigMulHigh", enum_type_name);
      return EDataProcessingOperationType::SmulhSigMulHigh;
    case 109:
      validate(in_str, "SmneglSigMulNotLong", enum_type_name);
      return EDataProcessingOperationType::SmneglSigMulNotLong;
    case 111:
      {
        char hash_value_111 = in_str.at(0);

        switch (hash_value_111) {
        case 83:
          validate(in_str, "SubWithCarry", enum_type_name);
          return EDataProcessingOperationType::SubWithCarry;
        case 85:
          validate(in_str, "Unknown", enum_type_name);
          return EDataProcessingOperationType::Unknown;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 114:
      {
        size_t size_114 = in_str.size();
        char hash_value_114 = in_str.at(14 < size_114 ? 14 : 14 % size_114);

        switch (hash_value_114) {
        case 51:
          validate(in_str, "NegNegateShift32", enum_type_name);
          return EDataProcessingOperationType::NegNegateShift32;
        case 54:
          validate(in_str, "NegNegateShift64", enum_type_name);
          return EDataProcessingOperationType::NegNegateShift64;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 118:
      validate(in_str, "UmullMulLong", enum_type_name);
      return EDataProcessingOperationType::UmullMulLong;
    case 126:
      validate(in_str, "AddWithCarry", enum_type_name);
      return EDataProcessingOperationType::AddWithCarry;
    case 127:
      validate(in_str, "UmulhMulHigh", enum_type_name);
      return EDataProcessingOperationType::UmulhMulHigh;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EDataProcessingOperationType::Unknown;
  }

  EDataProcessingOperationType try_string_to_EDataProcessingOperationType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(13 < size ? 13 : 13 % size) ^ in_str.at(18 < size ? 18 : 18 % size) ^ in_str.at(22 < size ? 22 : 22 % size);

    switch (hash_value) {
    case 1:
      {
        size_t size_1 = in_str.size();
        char hash_value_1 = in_str.at(1 < size_1 ? 1 : 1 % size_1);

        switch (hash_value_1) {
        case 100:
          okay = (in_str == "AddShift64");
          return EDataProcessingOperationType::AddShift64;
        case 110:
          okay = (in_str == "AndShift64");
          return EDataProcessingOperationType::AndShift64;
        case 111:
          okay = (in_str == "EorExcOrShift64");
          return EDataProcessingOperationType::EorExcOrShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 2:
      {
        char hash_value_2 = in_str.at(0);

        switch (hash_value_2) {
        case 66:
          okay = (in_str == "BicClearShift32");
          return EDataProcessingOperationType::BicClearShift32;
        case 83:
          okay = (in_str == "SubShift32");
          return EDataProcessingOperationType::SubShift32;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 4:
      {
        size_t size_4 = in_str.size();
        char hash_value_4 = in_str.at(1 < size_4 ? 1 : 1 % size_4);

        switch (hash_value_4) {
        case 100:
          okay = (in_str == "AddShift32");
          return EDataProcessingOperationType::AddShift32;
        case 110:
          okay = (in_str == "AndShift32");
          return EDataProcessingOperationType::AndShift32;
        case 111:
          okay = (in_str == "EorExcOrShift32");
          return EDataProcessingOperationType::EorExcOrShift32;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 7:
      {
        char hash_value_7 = in_str.at(0);

        switch (hash_value_7) {
        case 66:
          okay = (in_str == "BicClearShift64");
          return EDataProcessingOperationType::BicClearShift64;
        case 83:
          okay = (in_str == "SubShift64");
          return EDataProcessingOperationType::SubShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 8:
      okay = (in_str == "OrrIncOrShift32");
      return EDataProcessingOperationType::OrrIncOrShift32;
    case 13:
      okay = (in_str == "OrrIncOrShift64");
      return EDataProcessingOperationType::OrrIncOrShift64;
    case 19:
      okay = (in_str == "NgcNegateWithCarry32");
      return EDataProcessingOperationType::NgcNegateWithCarry32;
    case 22:
      okay = (in_str == "NgcNegateWithCarry64");
      return EDataProcessingOperationType::NgcNegateWithCarry64;
    case 32:
      okay = (in_str == "SubExt64");
      return EDataProcessingOperationType::SubExt64;
    case 35:
      okay = (in_str == "AddExt32");
      return EDataProcessingOperationType::AddExt32;
    case 37:
      okay = (in_str == "SubExt32");
      return EDataProcessingOperationType::SubExt32;
    case 38:
      okay = (in_str == "AddExt64");
      return EDataProcessingOperationType::AddExt64;
    case 41:
      okay = (in_str == "MsubMulSub64");
      return EDataProcessingOperationType::MsubMulSub64;
    case 44:
      okay = (in_str == "MsubMulSub32");
      return EDataProcessingOperationType::MsubMulSub32;
    case 48:
      {
        size_t size_48 = in_str.size();
        char hash_value_48 = in_str.at(1 < size_48 ? 1 : 1 % size_48);

        switch (hash_value_48) {
        case 100:
          okay = (in_str == "AddsAddSetFlagsExt32");
          return EDataProcessingOperationType::AddsAddSetFlagsExt32;
        case 110:
          okay = (in_str == "AndsAndSetFlagsImm32");
          return EDataProcessingOperationType::AndsAndSetFlagsImm32;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 49:
      okay = (in_str == "MnegMulNot32");
      return EDataProcessingOperationType::MnegMulNot32;
    case 50:
      okay = (in_str == "BicsClearSetFlagsShift64");
      return EDataProcessingOperationType::BicsClearSetFlagsShift64;
    case 51:
      okay = (in_str == "SubsSubSetFlagsExt64");
      return EDataProcessingOperationType::SubsSubSetFlagsExt64;
    case 52:
      okay = (in_str == "MnegMulNot64");
      return EDataProcessingOperationType::MnegMulNot64;
    case 53:
      {
        size_t size_53 = in_str.size();
        char hash_value_53 = in_str.at(1 < size_53 ? 1 : 1 % size_53);

        switch (hash_value_53) {
        case 100:
          okay = (in_str == "AddsAddSetFlagsExt64");
          return EDataProcessingOperationType::AddsAddSetFlagsExt64;
        case 110:
          okay = (in_str == "AndsAndSetFlagsImm64");
          return EDataProcessingOperationType::AndsAndSetFlagsImm64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 54:
      okay = (in_str == "SubsSubSetFlagsExt32");
      return EDataProcessingOperationType::SubsSubSetFlagsExt32;
    case 55:
      okay = (in_str == "BicsClearSetFlagsShift32");
      return EDataProcessingOperationType::BicsClearSetFlagsShift32;
    case 58:
      okay = (in_str == "AndImm32");
      return EDataProcessingOperationType::AndImm32;
    case 63:
      okay = (in_str == "AndImm64");
      return EDataProcessingOperationType::AndImm64;
    case 64:
      {
        size_t size_64 = in_str.size();
        char hash_value_64 = in_str.at(1 < size_64 ? 1 : 1 % size_64) ^ in_str.at(20 < size_64 ? 20 : 20 % size_64);

        switch (hash_value_64) {
        case 82:
          okay = (in_str == "AddsAddSetFlagsShift64");
          return EDataProcessingOperationType::AddsAddSetFlagsShift64;
        case 87:
          okay = (in_str == "AddsAddSetFlagsShift32");
          return EDataProcessingOperationType::AddsAddSetFlagsShift32;
        case 88:
          okay = (in_str == "AndsAndSetFlagsShift64");
          return EDataProcessingOperationType::AndsAndSetFlagsShift64;
        case 93:
          okay = (in_str == "AndsAndSetFlagsShift32");
          return EDataProcessingOperationType::AndsAndSetFlagsShift32;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 65:
      {
        size_t size_65 = in_str.size();
        char hash_value_65 = in_str.at(11 < size_65 ? 11 : 11 % size_65);

        switch (hash_value_65) {
        case 51:
          okay = (in_str == "OrrIncOrImm32");
          return EDataProcessingOperationType::OrrIncOrImm32;
        case 54:
          okay = (in_str == "OrrIncOrImm64");
          return EDataProcessingOperationType::OrrIncOrImm64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 67:
      okay = (in_str == "UmaddlMulAddLong");
      return EDataProcessingOperationType::UmaddlMulAddLong;
    case 68:
      {
        char hash_value_68 = in_str.at(0);

        switch (hash_value_68) {
        case 83:
          okay = (in_str == "SDiv");
          return EDataProcessingOperationType::SDiv;
        case 85:
          okay = (in_str == "UDiv");
          return EDataProcessingOperationType::UDiv;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 72:
      {
        size_t size_72 = in_str.size();
        char hash_value_72 = in_str.at(16 < size_72 ? 16 : 16 % size_72);

        switch (hash_value_72) {
        case 51:
          okay = (in_str == "OrnIncOrNotShift32");
          return EDataProcessingOperationType::OrnIncOrNotShift32;
        case 54:
          okay = (in_str == "OrnIncOrNotShift64");
          return EDataProcessingOperationType::OrnIncOrNotShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 75:
      {
        size_t size_75 = in_str.size();
        char hash_value_75 = in_str.at(11 < size_75 ? 11 : 11 % size_75);

        switch (hash_value_75) {
        case 51:
          okay = (in_str == "EorExcOrImm32");
          return EDataProcessingOperationType::EorExcOrImm32;
        case 54:
          okay = (in_str == "EorExcOrImm64");
          return EDataProcessingOperationType::EorExcOrImm64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 76:
      okay = (in_str == "UmneglMulNotLong");
      return EDataProcessingOperationType::UmneglMulNotLong;
    case 77:
      okay = (in_str == "Mul");
      return EDataProcessingOperationType::Mul;
    case 81:
      okay = (in_str == "UmsublMulSubLong");
      return EDataProcessingOperationType::UmsublMulSubLong;
    case 82:
      {
        size_t size_82 = in_str.size();
        char hash_value_82 = in_str.at(20 < size_82 ? 20 : 20 % size_82);

        switch (hash_value_82) {
        case 51:
          okay = (in_str == "SubsSubSetFlagsShift32");
          return EDataProcessingOperationType::SubsSubSetFlagsShift32;
        case 54:
          okay = (in_str == "SubsSubSetFlagsShift64");
          return EDataProcessingOperationType::SubsSubSetFlagsShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 84:
      {
        size_t size_84 = in_str.size();
        char hash_value_84 = in_str.at(16 < size_84 ? 16 : 16 % size_84);

        switch (hash_value_84) {
        case 51:
          okay = (in_str == "EonExcOrNotShift32");
          return EDataProcessingOperationType::EonExcOrNotShift32;
        case 54:
          okay = (in_str == "EonExcOrNotShift64");
          return EDataProcessingOperationType::EonExcOrNotShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 87:
      {
        size_t size_87 = in_str.size();
        char hash_value_87 = in_str.at(27 < size_87 ? 27 : 27 % size_87);

        switch (hash_value_87) {
        case 51:
          okay = (in_str == "NgcsNegateWithCarrySetFlags32");
          return EDataProcessingOperationType::NgcsNegateWithCarrySetFlags32;
        case 54:
          okay = (in_str == "NgcsNegateWithCarrySetFlags64");
          return EDataProcessingOperationType::NgcsNegateWithCarrySetFlags64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 92:
      okay = (in_str == "MulAdd");
      return EDataProcessingOperationType::MulAdd;
    case 95:
      {
        size_t size_95 = in_str.size();
        char hash_value_95 = in_str.at(11 < size_95 ? 11 : 11 % size_95);

        switch (hash_value_95) {
        case 51:
          okay = (in_str == "MvnNotShift32");
          return EDataProcessingOperationType::MvnNotShift32;
        case 54:
          okay = (in_str == "MvnNotShift64");
          return EDataProcessingOperationType::MvnNotShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 97:
      {
        size_t size_97 = in_str.size();
        char hash_value_97 = in_str.at(23 < size_97 ? 23 : 23 % size_97);

        switch (hash_value_97) {
        case 51:
          okay = (in_str == "NegsNegateSetFlagsShift32");
          return EDataProcessingOperationType::NegsNegateSetFlagsShift32;
        case 54:
          okay = (in_str == "NegsNegateSetFlagsShift64");
          return EDataProcessingOperationType::NegsNegateSetFlagsShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 101:
      okay = (in_str == "SmullSigMulLong");
      return EDataProcessingOperationType::SmullSigMulLong;
    case 103:
      {
        size_t size_103 = in_str.size();
        char hash_value_103 = in_str.at(2 < size_103 ? 2 : 2 % size_103);

        switch (hash_value_103) {
        case 97:
          okay = (in_str == "SmaddlSigMulAddLong");
          return EDataProcessingOperationType::SmaddlSigMulAddLong;
        case 115:
          okay = (in_str == "SmsublSigMulSubLong");
          return EDataProcessingOperationType::SmsublSigMulSubLong;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 108:
      okay = (in_str == "SmulhSigMulHigh");
      return EDataProcessingOperationType::SmulhSigMulHigh;
    case 109:
      okay = (in_str == "SmneglSigMulNotLong");
      return EDataProcessingOperationType::SmneglSigMulNotLong;
    case 111:
      {
        char hash_value_111 = in_str.at(0);

        switch (hash_value_111) {
        case 83:
          okay = (in_str == "SubWithCarry");
          return EDataProcessingOperationType::SubWithCarry;
        case 85:
          okay = (in_str == "Unknown");
          return EDataProcessingOperationType::Unknown;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 114:
      {
        size_t size_114 = in_str.size();
        char hash_value_114 = in_str.at(14 < size_114 ? 14 : 14 % size_114);

        switch (hash_value_114) {
        case 51:
          okay = (in_str == "NegNegateShift32");
          return EDataProcessingOperationType::NegNegateShift32;
        case 54:
          okay = (in_str == "NegNegateShift64");
          return EDataProcessingOperationType::NegNegateShift64;
        default:
          okay = false;
          return EDataProcessingOperationType::Unknown;
        }
      }
    case 118:
      okay = (in_str == "UmullMulLong");
      return EDataProcessingOperationType::UmullMulLong;
    case 126:
      okay = (in_str == "AddWithCarry");
      return EDataProcessingOperationType::AddWithCarry;
    case 127:
      okay = (in_str == "UmulhMulHigh");
      return EDataProcessingOperationType::UmulhMulHigh;
    default:
      okay = false;
      return EDataProcessingOperationType::Unknown;
    }
    return EDataProcessingOperationType::Unknown;
  }


  unsigned char EPteTypeSize = 8;

  const string EPteType_to_string(EPteType in_enum)
  {
    switch (in_enum) {
    case EPteType::P4K: return "P4K";
    case EPteType::P16K: return "P16K";
    case EPteType::P64K: return "P64K";
    case EPteType::P2M: return "P2M";
    case EPteType::P32M: return "P32M";
    case EPteType::P512M: return "P512M";
    case EPteType::P1G: return "P1G";
    case EPteType::P512G: return "P512G";
    default:
      unknown_enum_value("EPteType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPteType string_to_EPteType(const string& in_str)
  {
    string enum_type_name = "EPteType";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 67:
      validate(in_str, "P512G", enum_type_name);
      return EPteType::P512G;
    case 71:
      validate(in_str, "P1G", enum_type_name);
      return EPteType::P1G;
    case 73:
      validate(in_str, "P512M", enum_type_name);
      return EPteType::P512M;
    case 75:
      validate(in_str, "P4K", enum_type_name);
      return EPteType::P4K;
    case 77:
      validate(in_str, "P2M", enum_type_name);
      return EPteType::P2M;
    case 81:
      validate(in_str, "P32M", enum_type_name);
      return EPteType::P32M;
    case 82:
      validate(in_str, "P64K", enum_type_name);
      return EPteType::P64K;
    case 87:
      validate(in_str, "P16K", enum_type_name);
      return EPteType::P16K;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPteType::P4K;
  }

  EPteType try_string_to_EPteType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 67:
      okay = (in_str == "P512G");
      return EPteType::P512G;
    case 71:
      okay = (in_str == "P1G");
      return EPteType::P1G;
    case 73:
      okay = (in_str == "P512M");
      return EPteType::P512M;
    case 75:
      okay = (in_str == "P4K");
      return EPteType::P4K;
    case 77:
      okay = (in_str == "P2M");
      return EPteType::P2M;
    case 81:
      okay = (in_str == "P32M");
      return EPteType::P32M;
    case 82:
      okay = (in_str == "P64K");
      return EPteType::P64K;
    case 87:
      okay = (in_str == "P16K");
      return EPteType::P16K;
    default:
      okay = false;
      return EPteType::P4K;
    }
    return EPteType::P4K;
  }


  unsigned char EPteCategoryTypeSize = 2;

  const string EPteCategoryType_to_string(EPteCategoryType in_enum)
  {
    switch (in_enum) {
    case EPteCategoryType::Page: return "Page";
    case EPteCategoryType::Table: return "Table";
    default:
      unknown_enum_value("EPteCategoryType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPteCategoryType string_to_EPteCategoryType(const string& in_str)
  {
    string enum_type_name = "EPteCategoryType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 80:
      validate(in_str, "Page", enum_type_name);
      return EPteCategoryType::Page;
    case 84:
      validate(in_str, "Table", enum_type_name);
      return EPteCategoryType::Table;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPteCategoryType::Page;
  }

  EPteCategoryType try_string_to_EPteCategoryType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 80:
      okay = (in_str == "Page");
      return EPteCategoryType::Page;
    case 84:
      okay = (in_str == "Table");
      return EPteCategoryType::Table;
    default:
      okay = false;
      return EPteCategoryType::Page;
    }
    return EPteCategoryType::Page;
  }


  unsigned char ENotificationTypeSize = 7;

  const string ENotificationType_to_string(ENotificationType in_enum)
  {
    switch (in_enum) {
    case ENotificationType::RegisterUpdate: return "RegisterUpdate";
    case ENotificationType::RegisterInitiation: return "RegisterInitiation";
    case ENotificationType::ChoiceUpdate: return "ChoiceUpdate";
    case ENotificationType::VariableUpdate: return "VariableUpdate";
    case ENotificationType::ConditionUpdate: return "ConditionUpdate";
    case ENotificationType::PhysicalRegionAdded: return "PhysicalRegionAdded";
    case ENotificationType::PCUpdate: return "PCUpdate";
    default:
      unknown_enum_value("ENotificationType", (unsigned char)(in_enum));
    }
    return "";
  }

  ENotificationType string_to_ENotificationType(const string& in_str)
  {
    string enum_type_name = "ENotificationType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 0:
      validate(in_str, "PCUpdate", enum_type_name);
      return ENotificationType::PCUpdate;
    case 2:
      validate(in_str, "PhysicalRegionAdded", enum_type_name);
      return ENotificationType::PhysicalRegionAdded;
    case 3:
      validate(in_str, "VariableUpdate", enum_type_name);
      return ENotificationType::VariableUpdate;
    case 7:
      validate(in_str, "RegisterUpdate", enum_type_name);
      return ENotificationType::RegisterUpdate;
    case 27:
      validate(in_str, "RegisterInitiation", enum_type_name);
      return ENotificationType::RegisterInitiation;
    case 39:
      validate(in_str, "ChoiceUpdate", enum_type_name);
      return ENotificationType::ChoiceUpdate;
    case 45:
      validate(in_str, "ConditionUpdate", enum_type_name);
      return ENotificationType::ConditionUpdate;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ENotificationType::RegisterUpdate;
  }

  ENotificationType try_string_to_ENotificationType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 0:
      okay = (in_str == "PCUpdate");
      return ENotificationType::PCUpdate;
    case 2:
      okay = (in_str == "PhysicalRegionAdded");
      return ENotificationType::PhysicalRegionAdded;
    case 3:
      okay = (in_str == "VariableUpdate");
      return ENotificationType::VariableUpdate;
    case 7:
      okay = (in_str == "RegisterUpdate");
      return ENotificationType::RegisterUpdate;
    case 27:
      okay = (in_str == "RegisterInitiation");
      return ENotificationType::RegisterInitiation;
    case 39:
      okay = (in_str == "ChoiceUpdate");
      return ENotificationType::ChoiceUpdate;
    case 45:
      okay = (in_str == "ConditionUpdate");
      return ENotificationType::ConditionUpdate;
    default:
      okay = false;
      return ENotificationType::RegisterUpdate;
    }
    return ENotificationType::RegisterUpdate;
  }


  unsigned char EPageRequestAttributeTypeSize = 7;

  const string EPageRequestAttributeType_to_string(EPageRequestAttributeType in_enum)
  {
    switch (in_enum) {
    case EPageRequestAttributeType::VA: return "VA";
    case EPageRequestAttributeType::IPA: return "IPA";
    case EPageRequestAttributeType::PA: return "PA";
    case EPageRequestAttributeType::PageSize: return "PageSize";
    case EPageRequestAttributeType::MemAttrArch: return "MemAttrArch";
    case EPageRequestAttributeType::MemAttrImpl: return "MemAttrImpl";
    case EPageRequestAttributeType::AliasPageId: return "AliasPageId";
    default:
      unknown_enum_value("EPageRequestAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPageRequestAttributeType string_to_EPageRequestAttributeType(const string& in_str)
  {
    string enum_type_name = "EPageRequestAttributeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 4:
      validate(in_str, "MemAttrImpl", enum_type_name);
      return EPageRequestAttributeType::MemAttrImpl;
    case 12:
      validate(in_str, "MemAttrArch", enum_type_name);
      return EPageRequestAttributeType::MemAttrArch;
    case 17:
      validate(in_str, "PA", enum_type_name);
      return EPageRequestAttributeType::PA;
    case 23:
      validate(in_str, "VA", enum_type_name);
      return EPageRequestAttributeType::VA;
    case 25:
      validate(in_str, "IPA", enum_type_name);
      return EPageRequestAttributeType::IPA;
    case 38:
      validate(in_str, "AliasPageId", enum_type_name);
      return EPageRequestAttributeType::AliasPageId;
    case 53:
      validate(in_str, "PageSize", enum_type_name);
      return EPageRequestAttributeType::PageSize;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPageRequestAttributeType::VA;
  }

  EPageRequestAttributeType try_string_to_EPageRequestAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 4:
      okay = (in_str == "MemAttrImpl");
      return EPageRequestAttributeType::MemAttrImpl;
    case 12:
      okay = (in_str == "MemAttrArch");
      return EPageRequestAttributeType::MemAttrArch;
    case 17:
      okay = (in_str == "PA");
      return EPageRequestAttributeType::PA;
    case 23:
      okay = (in_str == "VA");
      return EPageRequestAttributeType::VA;
    case 25:
      okay = (in_str == "IPA");
      return EPageRequestAttributeType::IPA;
    case 38:
      okay = (in_str == "AliasPageId");
      return EPageRequestAttributeType::AliasPageId;
    case 53:
      okay = (in_str == "PageSize");
      return EPageRequestAttributeType::PageSize;
    default:
      okay = false;
      return EPageRequestAttributeType::VA;
    }
    return EPageRequestAttributeType::VA;
  }


  unsigned char EPageGenAttributeTypeSize = 5;

  const string EPageGenAttributeType_to_string(EPageGenAttributeType in_enum)
  {
    switch (in_enum) {
    case EPageGenAttributeType::MemAttrImpl: return "MemAttrImpl";
    case EPageGenAttributeType::Invalid: return "Invalid";
    case EPageGenAttributeType::AddrSizeFault: return "AddrSizeFault";
    case EPageGenAttributeType::DataAccessPermission: return "DataAccessPermission";
    case EPageGenAttributeType::InstrAccessPermission: return "InstrAccessPermission";
    default:
      unknown_enum_value("EPageGenAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPageGenAttributeType string_to_EPageGenAttributeType(const string& in_str)
  {
    string enum_type_name = "EPageGenAttributeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 100:
      validate(in_str, "AddrSizeFault", enum_type_name);
      return EPageGenAttributeType::AddrSizeFault;
    case 109:
      validate(in_str, "MemAttrImpl", enum_type_name);
      return EPageGenAttributeType::MemAttrImpl;
    case 115:
      validate(in_str, "InstrAccessPermission", enum_type_name);
      return EPageGenAttributeType::InstrAccessPermission;
    case 116:
      validate(in_str, "DataAccessPermission", enum_type_name);
      return EPageGenAttributeType::DataAccessPermission;
    case 118:
      validate(in_str, "Invalid", enum_type_name);
      return EPageGenAttributeType::Invalid;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPageGenAttributeType::MemAttrImpl;
  }

  EPageGenAttributeType try_string_to_EPageGenAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 100:
      okay = (in_str == "AddrSizeFault");
      return EPageGenAttributeType::AddrSizeFault;
    case 109:
      okay = (in_str == "MemAttrImpl");
      return EPageGenAttributeType::MemAttrImpl;
    case 115:
      okay = (in_str == "InstrAccessPermission");
      return EPageGenAttributeType::InstrAccessPermission;
    case 116:
      okay = (in_str == "DataAccessPermission");
      return EPageGenAttributeType::DataAccessPermission;
    case 118:
      okay = (in_str == "Invalid");
      return EPageGenAttributeType::Invalid;
    default:
      okay = false;
      return EPageGenAttributeType::MemAttrImpl;
    }
    return EPageGenAttributeType::MemAttrImpl;
  }


  unsigned char EDataAccessPermissionTypeSize = 6;

  const string EDataAccessPermissionType_to_string(EDataAccessPermissionType in_enum)
  {
    switch (in_enum) {
    case EDataAccessPermissionType::ReadWrite: return "ReadWrite";
    case EDataAccessPermissionType::ReadOnly: return "ReadOnly";
    case EDataAccessPermissionType::ReadWriteNoUser: return "ReadWriteNoUser";
    case EDataAccessPermissionType::ReadOnlyNoUser: return "ReadOnlyNoUser";
    case EDataAccessPermissionType::ReadWriteUserOnly: return "ReadWriteUserOnly";
    case EDataAccessPermissionType::ReadOnlyUserOnly: return "ReadOnlyUserOnly";
    default:
      unknown_enum_value("EDataAccessPermissionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EDataAccessPermissionType string_to_EDataAccessPermissionType(const string& in_str)
  {
    string enum_type_name = "EDataAccessPermissionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(9 < size ? 9 : 9 % size);

    switch (hash_value) {
    case 78:
      validate(in_str, "ReadWriteNoUser", enum_type_name);
      return EDataAccessPermissionType::ReadWriteNoUser;
    case 82:
      validate(in_str, "ReadWrite", enum_type_name);
      return EDataAccessPermissionType::ReadWrite;
    case 85:
      validate(in_str, "ReadWriteUserOnly", enum_type_name);
      return EDataAccessPermissionType::ReadWriteUserOnly;
    case 101:
      validate(in_str, "ReadOnly", enum_type_name);
      return EDataAccessPermissionType::ReadOnly;
    case 111:
      validate(in_str, "ReadOnlyNoUser", enum_type_name);
      return EDataAccessPermissionType::ReadOnlyNoUser;
    case 115:
      validate(in_str, "ReadOnlyUserOnly", enum_type_name);
      return EDataAccessPermissionType::ReadOnlyUserOnly;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EDataAccessPermissionType::ReadWrite;
  }

  EDataAccessPermissionType try_string_to_EDataAccessPermissionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(9 < size ? 9 : 9 % size);

    switch (hash_value) {
    case 78:
      okay = (in_str == "ReadWriteNoUser");
      return EDataAccessPermissionType::ReadWriteNoUser;
    case 82:
      okay = (in_str == "ReadWrite");
      return EDataAccessPermissionType::ReadWrite;
    case 85:
      okay = (in_str == "ReadWriteUserOnly");
      return EDataAccessPermissionType::ReadWriteUserOnly;
    case 101:
      okay = (in_str == "ReadOnly");
      return EDataAccessPermissionType::ReadOnly;
    case 111:
      okay = (in_str == "ReadOnlyNoUser");
      return EDataAccessPermissionType::ReadOnlyNoUser;
    case 115:
      okay = (in_str == "ReadOnlyUserOnly");
      return EDataAccessPermissionType::ReadOnlyUserOnly;
    default:
      okay = false;
      return EDataAccessPermissionType::ReadWrite;
    }
    return EDataAccessPermissionType::ReadWrite;
  }


  unsigned char EInstrAccessPermissionTypeSize = 3;

  const string EInstrAccessPermissionType_to_string(EInstrAccessPermissionType in_enum)
  {
    switch (in_enum) {
    case EInstrAccessPermissionType::Execute: return "Execute";
    case EInstrAccessPermissionType::NoExecute: return "NoExecute";
    case EInstrAccessPermissionType::PrivilegedNoExecute: return "PrivilegedNoExecute";
    default:
      unknown_enum_value("EInstrAccessPermissionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstrAccessPermissionType string_to_EInstrAccessPermissionType(const string& in_str)
  {
    string enum_type_name = "EInstrAccessPermissionType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      validate(in_str, "Execute", enum_type_name);
      return EInstrAccessPermissionType::Execute;
    case 78:
      validate(in_str, "NoExecute", enum_type_name);
      return EInstrAccessPermissionType::NoExecute;
    case 80:
      validate(in_str, "PrivilegedNoExecute", enum_type_name);
      return EInstrAccessPermissionType::PrivilegedNoExecute;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstrAccessPermissionType::Execute;
  }

  EInstrAccessPermissionType try_string_to_EInstrAccessPermissionType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      okay = (in_str == "Execute");
      return EInstrAccessPermissionType::Execute;
    case 78:
      okay = (in_str == "NoExecute");
      return EInstrAccessPermissionType::NoExecute;
    case 80:
      okay = (in_str == "PrivilegedNoExecute");
      return EInstrAccessPermissionType::PrivilegedNoExecute;
    default:
      okay = false;
      return EInstrAccessPermissionType::Execute;
    }
    return EInstrAccessPermissionType::Execute;
  }


  unsigned char EGlobalStateTypeSize = 6;

  const string EGlobalStateType_to_string(EGlobalStateType in_enum)
  {
    switch (in_enum) {
    case EGlobalStateType::ResetPC: return "ResetPC";
    case EGlobalStateType::PageTableRegionSize: return "PageTableRegionSize";
    case EGlobalStateType::PageTableRegionAlign: return "PageTableRegionAlign";
    case EGlobalStateType::PageTableRegionStart: return "PageTableRegionStart";
    case EGlobalStateType::MemoryFillPattern: return "MemoryFillPattern";
    case EGlobalStateType::ElfMachine: return "ElfMachine";
    default:
      unknown_enum_value("EGlobalStateType", (unsigned char)(in_enum));
    }
    return "";
  }

  EGlobalStateType string_to_EGlobalStateType(const string& in_str)
  {
    string enum_type_name = "EGlobalStateType";
    size_t size = in_str.size();
    char hash_value = in_str.at(16 < size ? 16 : 16 % size);

    switch (hash_value) {
    case 104:
      validate(in_str, "ElfMachine", enum_type_name);
      return EGlobalStateType::ElfMachine;
    case 105:
      validate(in_str, "PageTableRegionSize", enum_type_name);
      return EGlobalStateType::PageTableRegionSize;
    case 108:
      validate(in_str, "PageTableRegionAlign", enum_type_name);
      return EGlobalStateType::PageTableRegionAlign;
    case 110:
      validate(in_str, "MemoryFillPattern", enum_type_name);
      return EGlobalStateType::MemoryFillPattern;
    case 115:
      validate(in_str, "ResetPC", enum_type_name);
      return EGlobalStateType::ResetPC;
    case 116:
      validate(in_str, "PageTableRegionStart", enum_type_name);
      return EGlobalStateType::PageTableRegionStart;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EGlobalStateType::ResetPC;
  }

  EGlobalStateType try_string_to_EGlobalStateType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(16 < size ? 16 : 16 % size);

    switch (hash_value) {
    case 104:
      okay = (in_str == "ElfMachine");
      return EGlobalStateType::ElfMachine;
    case 105:
      okay = (in_str == "PageTableRegionSize");
      return EGlobalStateType::PageTableRegionSize;
    case 108:
      okay = (in_str == "PageTableRegionAlign");
      return EGlobalStateType::PageTableRegionAlign;
    case 110:
      okay = (in_str == "MemoryFillPattern");
      return EGlobalStateType::MemoryFillPattern;
    case 115:
      okay = (in_str == "ResetPC");
      return EGlobalStateType::ResetPC;
    case 116:
      okay = (in_str == "PageTableRegionStart");
      return EGlobalStateType::PageTableRegionStart;
    default:
      okay = false;
      return EGlobalStateType::ResetPC;
    }
    return EGlobalStateType::ResetPC;
  }


  unsigned char EAddrTypeSize = 2;

  const string EAddrType_to_string(EAddrType in_enum)
  {
    switch (in_enum) {
    case EAddrType::DataAddr: return "DataAddr";
    case EAddrType::InstructionAddr: return "InstructionAddr";
    default:
      unknown_enum_value("EAddrType", (unsigned char)(in_enum));
    }
    return "";
  }

  EAddrType string_to_EAddrType(const string& in_str)
  {
    string enum_type_name = "EAddrType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      validate(in_str, "DataAddr", enum_type_name);
      return EAddrType::DataAddr;
    case 73:
      validate(in_str, "InstructionAddr", enum_type_name);
      return EAddrType::InstructionAddr;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EAddrType::DataAddr;
  }

  EAddrType try_string_to_EAddrType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      okay = (in_str == "DataAddr");
      return EAddrType::DataAddr;
    case 73:
      okay = (in_str == "InstructionAddr");
      return EAddrType::InstructionAddr;
    default:
      okay = false;
      return EAddrType::DataAddr;
    }
    return EAddrType::DataAddr;
  }


  unsigned char EBootElementActionTypeSize = 4;

  const string EBootElementActionType_to_string(EBootElementActionType in_enum)
  {
    switch (in_enum) {
    case EBootElementActionType::LoadRegister: return "LoadRegister";
    case EBootElementActionType::InstructionBarrier: return "InstructionBarrier";
    case EBootElementActionType::DataBarrier: return "DataBarrier";
    case EBootElementActionType::LoadLargeRegister: return "LoadLargeRegister";
    default:
      unknown_enum_value("EBootElementActionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EBootElementActionType string_to_EBootElementActionType(const string& in_str)
  {
    string enum_type_name = "EBootElementActionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 66:
      validate(in_str, "DataBarrier", enum_type_name);
      return EBootElementActionType::DataBarrier;
    case 76:
      validate(in_str, "LoadLargeRegister", enum_type_name);
      return EBootElementActionType::LoadLargeRegister;
    case 82:
      validate(in_str, "LoadRegister", enum_type_name);
      return EBootElementActionType::LoadRegister;
    case 114:
      validate(in_str, "InstructionBarrier", enum_type_name);
      return EBootElementActionType::InstructionBarrier;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EBootElementActionType::LoadRegister;
  }

  EBootElementActionType try_string_to_EBootElementActionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 66:
      okay = (in_str == "DataBarrier");
      return EBootElementActionType::DataBarrier;
    case 76:
      okay = (in_str == "LoadLargeRegister");
      return EBootElementActionType::LoadLargeRegister;
    case 82:
      okay = (in_str == "LoadRegister");
      return EBootElementActionType::LoadRegister;
    case 114:
      okay = (in_str == "InstructionBarrier");
      return EBootElementActionType::InstructionBarrier;
    default:
      okay = false;
      return EBootElementActionType::LoadRegister;
    }
    return EBootElementActionType::LoadRegister;
  }


  unsigned char EQueryTypeSize = 23;

  const string EQueryType_to_string(EQueryType in_enum)
  {
    switch (in_enum) {
    case EQueryType::RegisterIndex: return "RegisterIndex";
    case EQueryType::RegisterReloadValue: return "RegisterReloadValue";
    case EQueryType::InstructionRecord: return "InstructionRecord";
    case EQueryType::RegisterInfo: return "RegisterInfo";
    case EQueryType::GenState: return "GenState";
    case EQueryType::PageInfo: return "PageInfo";
    case EQueryType::BranchOffset: return "BranchOffset";
    case EQueryType::RegisterFieldInfo: return "RegisterFieldInfo";
    case EQueryType::ChoicesTreeInfo: return "ChoicesTreeInfo";
    case EQueryType::SimpleExceptionsHistory: return "SimpleExceptionsHistory";
    case EQueryType::AdvancedExceptionsHistory: return "AdvancedExceptionsHistory";
    case EQueryType::MaxAddress: return "MaxAddress";
    case EQueryType::ValidAddressMask: return "ValidAddressMask";
    case EQueryType::HandlerSetMemory: return "HandlerSetMemory";
    case EQueryType::ExceptionVectorBaseAddress: return "ExceptionVectorBaseAddress";
    case EQueryType::ResourceEntropy: return "ResourceEntropy";
    case EQueryType::SoftwareStepPrivLevs: return "SoftwareStepPrivLevs";
    case EQueryType::SoftwareStepReady: return "SoftwareStepReady";
    case EQueryType::PickedValue: return "PickedValue";
    case EQueryType::GetVmContextDelta: return "GetVmContextDelta";
    case EQueryType::RestoreLoopContext: return "RestoreLoopContext";
    case EQueryType::GenData: return "GenData";
    case EQueryType::GetVmCurrentContext: return "GetVmCurrentContext";
    default:
      unknown_enum_value("EQueryType", (unsigned char)(in_enum));
    }
    return "";
  }

  EQueryType string_to_EQueryType(const string& in_str)
  {
    string enum_type_name = "EQueryType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(20 < size ? 20 : 20 % size);

    switch (hash_value) {
    case 65:
      validate(in_str, "SoftwareStepReady", enum_type_name);
      return EQueryType::SoftwareStepReady;
    case 66:
      validate(in_str, "ExceptionVectorBaseAddress", enum_type_name);
      return EQueryType::ExceptionVectorBaseAddress;
    case 68:
      validate(in_str, "AdvancedExceptionsHistory", enum_type_name);
      return EQueryType::AdvancedExceptionsHistory;
    case 69:
      validate(in_str, "BranchOffset", enum_type_name);
      return EQueryType::BranchOffset;
    case 70:
      validate(in_str, "PickedValue", enum_type_name);
      return EQueryType::PickedValue;
    case 71:
      validate(in_str, "RegisterIndex", enum_type_name);
      return EQueryType::RegisterIndex;
    case 72:
      validate(in_str, "GenData", enum_type_name);
      return EQueryType::GenData;
    case 73:
      validate(in_str, "ChoicesTreeInfo", enum_type_name);
      return EQueryType::ChoicesTreeInfo;
    case 74:
      validate(in_str, "HandlerSetMemory", enum_type_name);
      return EQueryType::HandlerSetMemory;
    case 78:
      validate(in_str, "InstructionRecord", enum_type_name);
      return EQueryType::InstructionRecord;
    case 80:
      validate(in_str, "RegisterReloadValue", enum_type_name);
      return EQueryType::RegisterReloadValue;
    case 81:
      validate(in_str, "SimpleExceptionsHistory", enum_type_name);
      return EQueryType::SimpleExceptionsHistory;
    case 82:
      validate(in_str, "RestoreLoopContext", enum_type_name);
      return EQueryType::RestoreLoopContext;
    case 83:
      validate(in_str, "ResourceEntropy", enum_type_name);
      return EQueryType::ResourceEntropy;
    case 86:
      validate(in_str, "GetVmCurrentContext", enum_type_name);
      return EQueryType::GetVmCurrentContext;
    case 92:
      validate(in_str, "RegisterFieldInfo", enum_type_name);
      return EQueryType::RegisterFieldInfo;
    case 93:
      validate(in_str, "GenState", enum_type_name);
      return EQueryType::GenState;
    case 94:
      validate(in_str, "ValidAddressMask", enum_type_name);
      return EQueryType::ValidAddressMask;
    case 101:
      validate(in_str, "GetVmContextDelta", enum_type_name);
      return EQueryType::GetVmContextDelta;
    case 102:
      validate(in_str, "SoftwareStepPrivLevs", enum_type_name);
      return EQueryType::SoftwareStepPrivLevs;
    case 120:
      validate(in_str, "MaxAddress", enum_type_name);
      return EQueryType::MaxAddress;
    case 124:
      validate(in_str, "RegisterInfo", enum_type_name);
      return EQueryType::RegisterInfo;
    case 126:
      validate(in_str, "PageInfo", enum_type_name);
      return EQueryType::PageInfo;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EQueryType::RegisterIndex;
  }

  EQueryType try_string_to_EQueryType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(20 < size ? 20 : 20 % size);

    switch (hash_value) {
    case 65:
      okay = (in_str == "SoftwareStepReady");
      return EQueryType::SoftwareStepReady;
    case 66:
      okay = (in_str == "ExceptionVectorBaseAddress");
      return EQueryType::ExceptionVectorBaseAddress;
    case 68:
      okay = (in_str == "AdvancedExceptionsHistory");
      return EQueryType::AdvancedExceptionsHistory;
    case 69:
      okay = (in_str == "BranchOffset");
      return EQueryType::BranchOffset;
    case 70:
      okay = (in_str == "PickedValue");
      return EQueryType::PickedValue;
    case 71:
      okay = (in_str == "RegisterIndex");
      return EQueryType::RegisterIndex;
    case 72:
      okay = (in_str == "GenData");
      return EQueryType::GenData;
    case 73:
      okay = (in_str == "ChoicesTreeInfo");
      return EQueryType::ChoicesTreeInfo;
    case 74:
      okay = (in_str == "HandlerSetMemory");
      return EQueryType::HandlerSetMemory;
    case 78:
      okay = (in_str == "InstructionRecord");
      return EQueryType::InstructionRecord;
    case 80:
      okay = (in_str == "RegisterReloadValue");
      return EQueryType::RegisterReloadValue;
    case 81:
      okay = (in_str == "SimpleExceptionsHistory");
      return EQueryType::SimpleExceptionsHistory;
    case 82:
      okay = (in_str == "RestoreLoopContext");
      return EQueryType::RestoreLoopContext;
    case 83:
      okay = (in_str == "ResourceEntropy");
      return EQueryType::ResourceEntropy;
    case 86:
      okay = (in_str == "GetVmCurrentContext");
      return EQueryType::GetVmCurrentContext;
    case 92:
      okay = (in_str == "RegisterFieldInfo");
      return EQueryType::RegisterFieldInfo;
    case 93:
      okay = (in_str == "GenState");
      return EQueryType::GenState;
    case 94:
      okay = (in_str == "ValidAddressMask");
      return EQueryType::ValidAddressMask;
    case 101:
      okay = (in_str == "GetVmContextDelta");
      return EQueryType::GetVmContextDelta;
    case 102:
      okay = (in_str == "SoftwareStepPrivLevs");
      return EQueryType::SoftwareStepPrivLevs;
    case 120:
      okay = (in_str == "MaxAddress");
      return EQueryType::MaxAddress;
    case 124:
      okay = (in_str == "RegisterInfo");
      return EQueryType::RegisterInfo;
    case 126:
      okay = (in_str == "PageInfo");
      return EQueryType::PageInfo;
    default:
      okay = false;
      return EQueryType::RegisterIndex;
    }
    return EQueryType::RegisterIndex;
  }


  unsigned int EGenModeTypeSize = 15;

  const string EGenModeType_to_string(EGenModeType in_enum)
  {
    switch (in_enum) {
    case EGenModeType::NoIss: return "NoIss";
    case EGenModeType::SimOff: return "SimOff";
    case EGenModeType::NoEscape: return "NoEscape";
    case EGenModeType::NoJump: return "NoJump";
    case EGenModeType::ReExe: return "ReExe";
    case EGenModeType::Exception: return "Exception";
    case EGenModeType::NoSkip: return "NoSkip";
    case EGenModeType::InLoop: return "InLoop";
    case EGenModeType::DelayInit: return "DelayInit";
    case EGenModeType::LowPower: return "LowPower";
    case EGenModeType::Filler: return "Filler";
    case EGenModeType::Speculative: return "Speculative";
    case EGenModeType::AddressShortage: return "AddressShortage";
    case EGenModeType::RecordingState: return "RecordingState";
    case EGenModeType::RestoreStateLoop: return "RestoreStateLoop";
    default:
      unknown_enum_value("EGenModeType", (unsigned int)(in_enum));
    }
    return "";
  }

  EGenModeType string_to_EGenModeType(const string& in_str)
  {
    string enum_type_name = "EGenModeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 4:
      validate(in_str, "NoJump", enum_type_name);
      return EGenModeType::NoJump;
    case 5:
      validate(in_str, "InLoop", enum_type_name);
      return EGenModeType::InLoop;
    case 7:
      validate(in_str, "NoIss", enum_type_name);
      return EGenModeType::NoIss;
    case 11:
      validate(in_str, "NoEscape", enum_type_name);
      return EGenModeType::NoEscape;
    case 23:
      validate(in_str, "ReExe", enum_type_name);
      return EGenModeType::ReExe;
    case 29:
      validate(in_str, "NoSkip", enum_type_name);
      return EGenModeType::NoSkip;
    case 33:
      validate(in_str, "RestoreStateLoop", enum_type_name);
      return EGenModeType::RestoreStateLoop;
    case 37:
      validate(in_str, "AddressShortage", enum_type_name);
      return EGenModeType::AddressShortage;
    case 38:
      validate(in_str, "Exception", enum_type_name);
      return EGenModeType::Exception;
    case 40:
      validate(in_str, "DelayInit", enum_type_name);
      return EGenModeType::DelayInit;
    case 42:
      validate(in_str, "Filler", enum_type_name);
      return EGenModeType::Filler;
    case 49:
      validate(in_str, "RecordingState", enum_type_name);
      return EGenModeType::RecordingState;
    case 54:
      validate(in_str, "Speculative", enum_type_name);
      return EGenModeType::Speculative;
    case 59:
      validate(in_str, "LowPower", enum_type_name);
      return EGenModeType::LowPower;
    case 62:
      validate(in_str, "SimOff", enum_type_name);
      return EGenModeType::SimOff;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EGenModeType::NoIss;
  }

  EGenModeType try_string_to_EGenModeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 4:
      okay = (in_str == "NoJump");
      return EGenModeType::NoJump;
    case 5:
      okay = (in_str == "InLoop");
      return EGenModeType::InLoop;
    case 7:
      okay = (in_str == "NoIss");
      return EGenModeType::NoIss;
    case 11:
      okay = (in_str == "NoEscape");
      return EGenModeType::NoEscape;
    case 23:
      okay = (in_str == "ReExe");
      return EGenModeType::ReExe;
    case 29:
      okay = (in_str == "NoSkip");
      return EGenModeType::NoSkip;
    case 33:
      okay = (in_str == "RestoreStateLoop");
      return EGenModeType::RestoreStateLoop;
    case 37:
      okay = (in_str == "AddressShortage");
      return EGenModeType::AddressShortage;
    case 38:
      okay = (in_str == "Exception");
      return EGenModeType::Exception;
    case 40:
      okay = (in_str == "DelayInit");
      return EGenModeType::DelayInit;
    case 42:
      okay = (in_str == "Filler");
      return EGenModeType::Filler;
    case 49:
      okay = (in_str == "RecordingState");
      return EGenModeType::RecordingState;
    case 54:
      okay = (in_str == "Speculative");
      return EGenModeType::Speculative;
    case 59:
      okay = (in_str == "LowPower");
      return EGenModeType::LowPower;
    case 62:
      okay = (in_str == "SimOff");
      return EGenModeType::SimOff;
    default:
      okay = false;
      return EGenModeType::NoIss;
    }
    return EGenModeType::NoIss;
  }


  unsigned char EGenStateTypeSize = 14;

  const string EGenStateType_to_string(EGenStateType in_enum)
  {
    switch (in_enum) {
    case EGenStateType::GenMode: return "GenMode";
    case EGenStateType::PC: return "PC";
    case EGenStateType::InitialPC: return "InitialPC";
    case EGenStateType::BootPC: return "BootPC";
    case EGenStateType::EL: return "EL";
    case EGenStateType::Loop: return "Loop";
    case EGenStateType::CPSR: return "CPSR";
    case EGenStateType::LinearBlock: return "LinearBlock";
    case EGenStateType::LastPC: return "LastPC";
    case EGenStateType::BntHook: return "BntHook";
    case EGenStateType::PostLoopAddress: return "PostLoopAddress";
    case EGenStateType::LoopReconvergeAddress: return "LoopReconvergeAddress";
    case EGenStateType::PrivilegeLevel: return "PrivilegeLevel";
    case EGenStateType::Endianness: return "Endianness";
    default:
      unknown_enum_value("EGenStateType", (unsigned char)(in_enum));
    }
    return "";
  }

  EGenStateType string_to_EGenStateType(const string& in_str)
  {
    string enum_type_name = "EGenStateType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(11 < size ? 11 : 11 % size);

    switch (hash_value) {
    case 0:
      validate(in_str, "LinearBlock", enum_type_name);
      return EGenStateType::LinearBlock;
    case 1:
      validate(in_str, "BootPC", enum_type_name);
      return EGenStateType::BootPC;
    case 9:
      validate(in_str, "EL", enum_type_name);
      return EGenStateType::EL;
    case 15:
      validate(in_str, "LastPC", enum_type_name);
      return EGenStateType::LastPC;
    case 17:
      validate(in_str, "CPSR", enum_type_name);
      return EGenStateType::CPSR;
    case 19:
      validate(in_str, "PC", enum_type_name);
      return EGenStateType::PC;
    case 32:
      validate(in_str, "InitialPC", enum_type_name);
      return EGenStateType::InitialPC;
    case 34:
      validate(in_str, "PostLoopAddress", enum_type_name);
      return EGenStateType::PostLoopAddress;
    case 38:
      validate(in_str, "PrivilegeLevel", enum_type_name);
      return EGenStateType::PrivilegeLevel;
    case 40:
      validate(in_str, "GenMode", enum_type_name);
      return EGenStateType::GenMode;
    case 43:
      validate(in_str, "Endianness", enum_type_name);
      return EGenStateType::Endianness;
    case 45:
      validate(in_str, "BntHook", enum_type_name);
      return EGenStateType::BntHook;
    case 60:
      validate(in_str, "Loop", enum_type_name);
      return EGenStateType::Loop;
    case 62:
      validate(in_str, "LoopReconvergeAddress", enum_type_name);
      return EGenStateType::LoopReconvergeAddress;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EGenStateType::GenMode;
  }

  EGenStateType try_string_to_EGenStateType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(11 < size ? 11 : 11 % size);

    switch (hash_value) {
    case 0:
      okay = (in_str == "LinearBlock");
      return EGenStateType::LinearBlock;
    case 1:
      okay = (in_str == "BootPC");
      return EGenStateType::BootPC;
    case 9:
      okay = (in_str == "EL");
      return EGenStateType::EL;
    case 15:
      okay = (in_str == "LastPC");
      return EGenStateType::LastPC;
    case 17:
      okay = (in_str == "CPSR");
      return EGenStateType::CPSR;
    case 19:
      okay = (in_str == "PC");
      return EGenStateType::PC;
    case 32:
      okay = (in_str == "InitialPC");
      return EGenStateType::InitialPC;
    case 34:
      okay = (in_str == "PostLoopAddress");
      return EGenStateType::PostLoopAddress;
    case 38:
      okay = (in_str == "PrivilegeLevel");
      return EGenStateType::PrivilegeLevel;
    case 40:
      okay = (in_str == "GenMode");
      return EGenStateType::GenMode;
    case 43:
      okay = (in_str == "Endianness");
      return EGenStateType::Endianness;
    case 45:
      okay = (in_str == "BntHook");
      return EGenStateType::BntHook;
    case 60:
      okay = (in_str == "Loop");
      return EGenStateType::Loop;
    case 62:
      okay = (in_str == "LoopReconvergeAddress");
      return EGenStateType::LoopReconvergeAddress;
    default:
      okay = false;
      return EGenStateType::GenMode;
    }
    return EGenStateType::GenMode;
  }


  unsigned char EGenStateActionTypeSize = 5;

  const string EGenStateActionType_to_string(EGenStateActionType in_enum)
  {
    switch (in_enum) {
    case EGenStateActionType::Push: return "Push";
    case EGenStateActionType::Pop: return "Pop";
    case EGenStateActionType::Set: return "Set";
    case EGenStateActionType::Enable: return "Enable";
    case EGenStateActionType::Disable: return "Disable";
    default:
      unknown_enum_value("EGenStateActionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EGenStateActionType string_to_EGenStateActionType(const string& in_str)
  {
    string enum_type_name = "EGenStateActionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 101:
      validate(in_str, "Set", enum_type_name);
      return EGenStateActionType::Set;
    case 105:
      validate(in_str, "Disable", enum_type_name);
      return EGenStateActionType::Disable;
    case 110:
      validate(in_str, "Enable", enum_type_name);
      return EGenStateActionType::Enable;
    case 111:
      validate(in_str, "Pop", enum_type_name);
      return EGenStateActionType::Pop;
    case 117:
      validate(in_str, "Push", enum_type_name);
      return EGenStateActionType::Push;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EGenStateActionType::Push;
  }

  EGenStateActionType try_string_to_EGenStateActionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 101:
      okay = (in_str == "Set");
      return EGenStateActionType::Set;
    case 105:
      okay = (in_str == "Disable");
      return EGenStateActionType::Disable;
    case 110:
      okay = (in_str == "Enable");
      return EGenStateActionType::Enable;
    case 111:
      okay = (in_str == "Pop");
      return EGenStateActionType::Pop;
    case 117:
      okay = (in_str == "Push");
      return EGenStateActionType::Push;
    default:
      okay = false;
      return EGenStateActionType::Push;
    }
    return EGenStateActionType::Push;
  }


  unsigned char EGenExceptionDetatilTypeSize = 1;

  const string EGenExceptionDetatilType_to_string(EGenExceptionDetatilType in_enum)
  {
    switch (in_enum) {
    case EGenExceptionDetatilType::RegisterNotInitSetValue: return "RegisterNotInitSetValue";
    default:
      unknown_enum_value("EGenExceptionDetatilType", (unsigned char)(in_enum));
    }
    return "";
  }

  EGenExceptionDetatilType string_to_EGenExceptionDetatilType(const string& in_str)
  {
    string enum_type_name = "EGenExceptionDetatilType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 82:
      validate(in_str, "RegisterNotInitSetValue", enum_type_name);
      return EGenExceptionDetatilType::RegisterNotInitSetValue;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EGenExceptionDetatilType::RegisterNotInitSetValue;
  }

  EGenExceptionDetatilType try_string_to_EGenExceptionDetatilType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 82:
      okay = (in_str == "RegisterNotInitSetValue");
      return EGenExceptionDetatilType::RegisterNotInitSetValue;
    default:
      okay = false;
      return EGenExceptionDetatilType::RegisterNotInitSetValue;
    }
    return EGenExceptionDetatilType::RegisterNotInitSetValue;
  }


  unsigned char EExceptionRequestTypeSize = 3;

  const string EExceptionRequestType_to_string(EExceptionRequestType in_enum)
  {
    switch (in_enum) {
    case EExceptionRequestType::HandleException: return "HandleException";
    case EExceptionRequestType::SystemCall: return "SystemCall";
    case EExceptionRequestType::UpdateHandlerInfo: return "UpdateHandlerInfo";
    default:
      unknown_enum_value("EExceptionRequestType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionRequestType string_to_EExceptionRequestType(const string& in_str)
  {
    string enum_type_name = "EExceptionRequestType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      validate(in_str, "HandleException", enum_type_name);
      return EExceptionRequestType::HandleException;
    case 83:
      validate(in_str, "SystemCall", enum_type_name);
      return EExceptionRequestType::SystemCall;
    case 85:
      validate(in_str, "UpdateHandlerInfo", enum_type_name);
      return EExceptionRequestType::UpdateHandlerInfo;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionRequestType::HandleException;
  }

  EExceptionRequestType try_string_to_EExceptionRequestType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      okay = (in_str == "HandleException");
      return EExceptionRequestType::HandleException;
    case 83:
      okay = (in_str == "SystemCall");
      return EExceptionRequestType::SystemCall;
    case 85:
      okay = (in_str == "UpdateHandlerInfo");
      return EExceptionRequestType::UpdateHandlerInfo;
    default:
      okay = false;
      return EExceptionRequestType::HandleException;
    }
    return EExceptionRequestType::HandleException;
  }


  unsigned char EExceptionEventTypeSize = 1;

  const string EExceptionEventType_to_string(EExceptionEventType in_enum)
  {
    switch (in_enum) {
    case EExceptionEventType::ExceptionReturn: return "ExceptionReturn";
    default:
      unknown_enum_value("EExceptionEventType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionEventType string_to_EExceptionEventType(const string& in_str)
  {
    string enum_type_name = "EExceptionEventType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      validate(in_str, "ExceptionReturn", enum_type_name);
      return EExceptionEventType::ExceptionReturn;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionEventType::ExceptionReturn;
  }

  EExceptionEventType try_string_to_EExceptionEventType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      okay = (in_str == "ExceptionReturn");
      return EExceptionEventType::ExceptionReturn;
    default:
      okay = false;
      return EExceptionEventType::ExceptionReturn;
    }
    return EExceptionEventType::ExceptionReturn;
  }


  unsigned char EExceptionConstraintTypeSize = 6;

  const string EExceptionConstraintType_to_string(EExceptionConstraintType in_enum)
  {
    switch (in_enum) {
    case EExceptionConstraintType::Allow: return "Allow";
    case EExceptionConstraintType::Prevent: return "Prevent";
    case EExceptionConstraintType::Trigger: return "Trigger";
    case EExceptionConstraintType::PreventHard: return "PreventHard";
    case EExceptionConstraintType::TriggerHard: return "TriggerHard";
    case EExceptionConstraintType::Invalid: return "Invalid";
    default:
      unknown_enum_value("EExceptionConstraintType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionConstraintType string_to_EExceptionConstraintType(const string& in_str)
  {
    string enum_type_name = "EExceptionConstraintType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 34:
      validate(in_str, "Prevent", enum_type_name);
      return EExceptionConstraintType::Prevent;
    case 38:
      validate(in_str, "Trigger", enum_type_name);
      return EExceptionConstraintType::Trigger;
    case 39:
      validate(in_str, "Invalid", enum_type_name);
      return EExceptionConstraintType::Invalid;
    case 46:
      validate(in_str, "Allow", enum_type_name);
      return EExceptionConstraintType::Allow;
    case 49:
      validate(in_str, "PreventHard", enum_type_name);
      return EExceptionConstraintType::PreventHard;
    case 53:
      validate(in_str, "TriggerHard", enum_type_name);
      return EExceptionConstraintType::TriggerHard;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionConstraintType::Allow;
  }

  EExceptionConstraintType try_string_to_EExceptionConstraintType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(8 < size ? 8 : 8 % size);

    switch (hash_value) {
    case 34:
      okay = (in_str == "Prevent");
      return EExceptionConstraintType::Prevent;
    case 38:
      okay = (in_str == "Trigger");
      return EExceptionConstraintType::Trigger;
    case 39:
      okay = (in_str == "Invalid");
      return EExceptionConstraintType::Invalid;
    case 46:
      okay = (in_str == "Allow");
      return EExceptionConstraintType::Allow;
    case 49:
      okay = (in_str == "PreventHard");
      return EExceptionConstraintType::PreventHard;
    case 53:
      okay = (in_str == "TriggerHard");
      return EExceptionConstraintType::TriggerHard;
    default:
      okay = false;
      return EExceptionConstraintType::Allow;
    }
    return EExceptionConstraintType::Allow;
  }


  unsigned char EPhysicalRegionTypeSize = 6;

  const string EPhysicalRegionType_to_string(EPhysicalRegionType in_enum)
  {
    switch (in_enum) {
    case EPhysicalRegionType::HandlerMemory: return "HandlerMemory";
    case EPhysicalRegionType::ExceptionStack: return "ExceptionStack";
    case EPhysicalRegionType::PageTable: return "PageTable";
    case EPhysicalRegionType::BootRegion: return "BootRegion";
    case EPhysicalRegionType::AddressTable: return "AddressTable";
    case EPhysicalRegionType::ResetRegion: return "ResetRegion";
    default:
      unknown_enum_value("EPhysicalRegionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPhysicalRegionType string_to_EPhysicalRegionType(const string& in_str)
  {
    string enum_type_name = "EPhysicalRegionType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "AddressTable", enum_type_name);
      return EPhysicalRegionType::AddressTable;
    case 66:
      validate(in_str, "BootRegion", enum_type_name);
      return EPhysicalRegionType::BootRegion;
    case 69:
      validate(in_str, "ExceptionStack", enum_type_name);
      return EPhysicalRegionType::ExceptionStack;
    case 72:
      validate(in_str, "HandlerMemory", enum_type_name);
      return EPhysicalRegionType::HandlerMemory;
    case 80:
      validate(in_str, "PageTable", enum_type_name);
      return EPhysicalRegionType::PageTable;
    case 82:
      validate(in_str, "ResetRegion", enum_type_name);
      return EPhysicalRegionType::ResetRegion;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPhysicalRegionType::HandlerMemory;
  }

  EPhysicalRegionType try_string_to_EPhysicalRegionType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "AddressTable");
      return EPhysicalRegionType::AddressTable;
    case 66:
      okay = (in_str == "BootRegion");
      return EPhysicalRegionType::BootRegion;
    case 69:
      okay = (in_str == "ExceptionStack");
      return EPhysicalRegionType::ExceptionStack;
    case 72:
      okay = (in_str == "HandlerMemory");
      return EPhysicalRegionType::HandlerMemory;
    case 80:
      okay = (in_str == "PageTable");
      return EPhysicalRegionType::PageTable;
    case 82:
      okay = (in_str == "ResetRegion");
      return EPhysicalRegionType::ResetRegion;
    default:
      okay = false;
      return EPhysicalRegionType::HandlerMemory;
    }
    return EPhysicalRegionType::HandlerMemory;
  }


  unsigned char EDataTypeSize = 12;

  const string EDataType_to_string(EDataType in_enum)
  {
    switch (in_enum) {
    case EDataType::INT8: return "INT8";
    case EDataType::INT16: return "INT16";
    case EDataType::INT32: return "INT32";
    case EDataType::INT64: return "INT64";
    case EDataType::FIX8: return "FIX8";
    case EDataType::FIX16: return "FIX16";
    case EDataType::FIX32: return "FIX32";
    case EDataType::FIX64: return "FIX64";
    case EDataType::FP8: return "FP8";
    case EDataType::FP16: return "FP16";
    case EDataType::FP32: return "FP32";
    case EDataType::FP64: return "FP64";
    default:
      unknown_enum_value("EDataType", (unsigned char)(in_enum));
    }
    return "";
  }

  EDataType string_to_EDataType(const string& in_str)
  {
    string enum_type_name = "EDataType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "FP32", enum_type_name);
      return EDataType::FP32;
    case 2:
      validate(in_str, "FP64", enum_type_name);
      return EDataType::FP64;
    case 7:
      validate(in_str, "FP16", enum_type_name);
      return EDataType::FP16;
    case 96:
      validate(in_str, "FIX8", enum_type_name);
      return EDataType::FIX8;
    case 98:
      validate(in_str, "INT64", enum_type_name);
      return EDataType::INT64;
    case 101:
      validate(in_str, "INT16", enum_type_name);
      return EDataType::INT16;
    case 103:
      validate(in_str, "INT32", enum_type_name);
      return EDataType::INT32;
    case 105:
      validate(in_str, "FIX16", enum_type_name);
      return EDataType::FIX16;
    case 107:
      validate(in_str, "FIX32", enum_type_name);
      return EDataType::FIX32;
    case 108:
      validate(in_str, "INT8", enum_type_name);
      return EDataType::INT8;
    case 110:
      validate(in_str, "FIX64", enum_type_name);
      return EDataType::FIX64;
    case 126:
      validate(in_str, "FP8", enum_type_name);
      return EDataType::FP8;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EDataType::INT8;
  }

  EDataType try_string_to_EDataType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "FP32");
      return EDataType::FP32;
    case 2:
      okay = (in_str == "FP64");
      return EDataType::FP64;
    case 7:
      okay = (in_str == "FP16");
      return EDataType::FP16;
    case 96:
      okay = (in_str == "FIX8");
      return EDataType::FIX8;
    case 98:
      okay = (in_str == "INT64");
      return EDataType::INT64;
    case 101:
      okay = (in_str == "INT16");
      return EDataType::INT16;
    case 103:
      okay = (in_str == "INT32");
      return EDataType::INT32;
    case 105:
      okay = (in_str == "FIX16");
      return EDataType::FIX16;
    case 107:
      okay = (in_str == "FIX32");
      return EDataType::FIX32;
    case 108:
      okay = (in_str == "INT8");
      return EDataType::INT8;
    case 110:
      okay = (in_str == "FIX64");
      return EDataType::FIX64;
    case 126:
      okay = (in_str == "FP8");
      return EDataType::FP8;
    default:
      okay = false;
      return EDataType::INT8;
    }
    return EDataType::INT8;
  }


  unsigned char EDumpTypeSize = 6;

  const string EDumpType_to_string(EDumpType in_enum)
  {
    switch (in_enum) {
    case EDumpType::Asm: return "Asm";
    case EDumpType::Elf: return "Elf";
    case EDumpType::Mem: return "Mem";
    case EDumpType::Page: return "Page";
    case EDumpType::FailOnly: return "FailOnly";
    case EDumpType::Handlers: return "Handlers";
    default:
      unknown_enum_value("EDumpType", (unsigned char)(in_enum));
    }
    return "";
  }

  EDumpType string_to_EDumpType(const string& in_str)
  {
    string enum_type_name = "EDumpType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "Asm", enum_type_name);
      return EDumpType::Asm;
    case 69:
      validate(in_str, "Elf", enum_type_name);
      return EDumpType::Elf;
    case 70:
      validate(in_str, "FailOnly", enum_type_name);
      return EDumpType::FailOnly;
    case 72:
      validate(in_str, "Handlers", enum_type_name);
      return EDumpType::Handlers;
    case 77:
      validate(in_str, "Mem", enum_type_name);
      return EDumpType::Mem;
    case 80:
      validate(in_str, "Page", enum_type_name);
      return EDumpType::Page;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EDumpType::Asm;
  }

  EDumpType try_string_to_EDumpType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "Asm");
      return EDumpType::Asm;
    case 69:
      okay = (in_str == "Elf");
      return EDumpType::Elf;
    case 70:
      okay = (in_str == "FailOnly");
      return EDumpType::FailOnly;
    case 72:
      okay = (in_str == "Handlers");
      return EDumpType::Handlers;
    case 77:
      okay = (in_str == "Mem");
      return EDumpType::Mem;
    case 80:
      okay = (in_str == "Page");
      return EDumpType::Page;
    default:
      okay = false;
      return EDumpType::Asm;
    }
    return EDumpType::Asm;
  }


  unsigned char EResourceTypeSize = 3;

  const string EResourceType_to_string(EResourceType in_enum)
  {
    switch (in_enum) {
    case EResourceType::GPR: return "GPR";
    case EResourceType::FPR: return "FPR";
    case EResourceType::PREDREG: return "PREDREG";
    default:
      unknown_enum_value("EResourceType", (unsigned char)(in_enum));
    }
    return "";
  }

  EResourceType string_to_EResourceType(const string& in_str)
  {
    string enum_type_name = "EResourceType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "FPR", enum_type_name);
      return EResourceType::FPR;
    case 71:
      validate(in_str, "GPR", enum_type_name);
      return EResourceType::GPR;
    case 80:
      validate(in_str, "PREDREG", enum_type_name);
      return EResourceType::PREDREG;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EResourceType::GPR;
  }

  EResourceType try_string_to_EResourceType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FPR");
      return EResourceType::FPR;
    case 71:
      okay = (in_str == "GPR");
      return EResourceType::GPR;
    case 80:
      okay = (in_str == "PREDREG");
      return EResourceType::PREDREG;
    default:
      okay = false;
      return EResourceType::GPR;
    }
    return EResourceType::GPR;
  }


  unsigned char EDependencyTypeSize = 3;

  const string EDependencyType_to_string(EDependencyType in_enum)
  {
    switch (in_enum) {
    case EDependencyType::OnSource: return "OnSource";
    case EDependencyType::OnTarget: return "OnTarget";
    case EDependencyType::NoDependency: return "NoDependency";
    default:
      unknown_enum_value("EDependencyType", (unsigned char)(in_enum));
    }
    return "";
  }

  EDependencyType string_to_EDependencyType(const string& in_str)
  {
    string enum_type_name = "EDependencyType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 68:
      validate(in_str, "NoDependency", enum_type_name);
      return EDependencyType::NoDependency;
    case 83:
      validate(in_str, "OnSource", enum_type_name);
      return EDependencyType::OnSource;
    case 84:
      validate(in_str, "OnTarget", enum_type_name);
      return EDependencyType::OnTarget;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EDependencyType::OnSource;
  }

  EDependencyType try_string_to_EDependencyType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 68:
      okay = (in_str == "NoDependency");
      return EDependencyType::NoDependency;
    case 83:
      okay = (in_str == "OnSource");
      return EDependencyType::OnSource;
    case 84:
      okay = (in_str == "OnTarget");
      return EDependencyType::OnTarget;
    default:
      okay = false;
      return EDependencyType::OnSource;
    }
    return EDependencyType::OnSource;
  }


  unsigned char EAccessAgeTypeSize = 3;

  const string EAccessAgeType_to_string(EAccessAgeType in_enum)
  {
    switch (in_enum) {
    case EAccessAgeType::Invalid: return "Invalid";
    case EAccessAgeType::Read: return "Read";
    case EAccessAgeType::Write: return "Write";
    default:
      unknown_enum_value("EAccessAgeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EAccessAgeType string_to_EAccessAgeType(const string& in_str)
  {
    string enum_type_name = "EAccessAgeType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 73:
      validate(in_str, "Invalid", enum_type_name);
      return EAccessAgeType::Invalid;
    case 82:
      validate(in_str, "Read", enum_type_name);
      return EAccessAgeType::Read;
    case 87:
      validate(in_str, "Write", enum_type_name);
      return EAccessAgeType::Write;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EAccessAgeType::Invalid;
  }

  EAccessAgeType try_string_to_EAccessAgeType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 73:
      okay = (in_str == "Invalid");
      return EAccessAgeType::Invalid;
    case 82:
      okay = (in_str == "Read");
      return EAccessAgeType::Read;
    case 87:
      okay = (in_str == "Write");
      return EAccessAgeType::Write;
    default:
      okay = false;
      return EAccessAgeType::Invalid;
    }
    return EAccessAgeType::Invalid;
  }


  unsigned char EEntropyStateTypeSize = 3;

  const string EEntropyStateType_to_string(EEntropyStateType in_enum)
  {
    switch (in_enum) {
    case EEntropyStateType::WarmUp: return "WarmUp";
    case EEntropyStateType::Stable: return "Stable";
    case EEntropyStateType::CoolDown: return "CoolDown";
    default:
      unknown_enum_value("EEntropyStateType", (unsigned char)(in_enum));
    }
    return "";
  }

  EEntropyStateType string_to_EEntropyStateType(const string& in_str)
  {
    string enum_type_name = "EEntropyStateType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 67:
      validate(in_str, "CoolDown", enum_type_name);
      return EEntropyStateType::CoolDown;
    case 83:
      validate(in_str, "Stable", enum_type_name);
      return EEntropyStateType::Stable;
    case 87:
      validate(in_str, "WarmUp", enum_type_name);
      return EEntropyStateType::WarmUp;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EEntropyStateType::WarmUp;
  }

  EEntropyStateType try_string_to_EEntropyStateType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 67:
      okay = (in_str == "CoolDown");
      return EEntropyStateType::CoolDown;
    case 83:
      okay = (in_str == "Stable");
      return EEntropyStateType::Stable;
    case 87:
      okay = (in_str == "WarmUp");
      return EEntropyStateType::WarmUp;
    default:
      okay = false;
      return EEntropyStateType::WarmUp;
    }
    return EEntropyStateType::WarmUp;
  }


  unsigned char EVariableTypeSize = 3;

  const string EVariableType_to_string(EVariableType in_enum)
  {
    switch (in_enum) {
    case EVariableType::Choice: return "Choice";
    case EVariableType::Value: return "Value";
    case EVariableType::String: return "String";
    default:
      unknown_enum_value("EVariableType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVariableType string_to_EVariableType(const string& in_str)
  {
    string enum_type_name = "EVariableType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 67:
      validate(in_str, "Choice", enum_type_name);
      return EVariableType::Choice;
    case 83:
      validate(in_str, "String", enum_type_name);
      return EVariableType::String;
    case 86:
      validate(in_str, "Value", enum_type_name);
      return EVariableType::Value;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVariableType::Choice;
  }

  EVariableType try_string_to_EVariableType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 67:
      okay = (in_str == "Choice");
      return EVariableType::Choice;
    case 83:
      okay = (in_str == "String");
      return EVariableType::String;
    case 86:
      okay = (in_str == "Value");
      return EVariableType::Value;
    default:
      okay = false;
      return EVariableType::Choice;
    }
    return EVariableType::Choice;
  }


  unsigned char EAddressSolutionFilterTypeSize = 3;

  const string EAddressSolutionFilterType_to_string(EAddressSolutionFilterType in_enum)
  {
    switch (in_enum) {
    case EAddressSolutionFilterType::BaseDependency: return "BaseDependency";
    case EAddressSolutionFilterType::IndexDependency: return "IndexDependency";
    case EAddressSolutionFilterType::SpAlignment: return "SpAlignment";
    default:
      unknown_enum_value("EAddressSolutionFilterType", (unsigned char)(in_enum));
    }
    return "";
  }

  EAddressSolutionFilterType string_to_EAddressSolutionFilterType(const string& in_str)
  {
    string enum_type_name = "EAddressSolutionFilterType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      validate(in_str, "BaseDependency", enum_type_name);
      return EAddressSolutionFilterType::BaseDependency;
    case 73:
      validate(in_str, "IndexDependency", enum_type_name);
      return EAddressSolutionFilterType::IndexDependency;
    case 83:
      validate(in_str, "SpAlignment", enum_type_name);
      return EAddressSolutionFilterType::SpAlignment;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EAddressSolutionFilterType::BaseDependency;
  }

  EAddressSolutionFilterType try_string_to_EAddressSolutionFilterType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      okay = (in_str == "BaseDependency");
      return EAddressSolutionFilterType::BaseDependency;
    case 73:
      okay = (in_str == "IndexDependency");
      return EAddressSolutionFilterType::IndexDependency;
    case 83:
      okay = (in_str == "SpAlignment");
      return EAddressSolutionFilterType::SpAlignment;
    default:
      okay = false;
      return EAddressSolutionFilterType::BaseDependency;
    }
    return EAddressSolutionFilterType::BaseDependency;
  }


  unsigned char ECallBackTemplateTypeSize = 4;

  const string ECallBackTemplateType_to_string(ECallBackTemplateType in_enum)
  {
    switch (in_enum) {
    case ECallBackTemplateType::SetBntSeq: return "SetBntSeq";
    case ECallBackTemplateType::RunBntSeq: return "RunBntSeq";
    case ECallBackTemplateType::SetEretPreambleSeq: return "SetEretPreambleSeq";
    case ECallBackTemplateType::RunEretPreambleSeq: return "RunEretPreambleSeq";
    default:
      unknown_enum_value("ECallBackTemplateType", (unsigned char)(in_enum));
    }
    return "";
  }

  ECallBackTemplateType string_to_ECallBackTemplateType(const string& in_str)
  {
    string enum_type_name = "ECallBackTemplateType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 16:
      validate(in_str, "RunBntSeq", enum_type_name);
      return ECallBackTemplateType::RunBntSeq;
    case 17:
      validate(in_str, "SetBntSeq", enum_type_name);
      return ECallBackTemplateType::SetBntSeq;
    case 22:
      validate(in_str, "SetEretPreambleSeq", enum_type_name);
      return ECallBackTemplateType::SetEretPreambleSeq;
    case 23:
      validate(in_str, "RunEretPreambleSeq", enum_type_name);
      return ECallBackTemplateType::RunEretPreambleSeq;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ECallBackTemplateType::SetBntSeq;
  }

  ECallBackTemplateType try_string_to_ECallBackTemplateType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 16:
      okay = (in_str == "RunBntSeq");
      return ECallBackTemplateType::RunBntSeq;
    case 17:
      okay = (in_str == "SetBntSeq");
      return ECallBackTemplateType::SetBntSeq;
    case 22:
      okay = (in_str == "SetEretPreambleSeq");
      return ECallBackTemplateType::SetEretPreambleSeq;
    case 23:
      okay = (in_str == "RunEretPreambleSeq");
      return ECallBackTemplateType::RunEretPreambleSeq;
    default:
      okay = false;
      return ECallBackTemplateType::SetBntSeq;
    }
    return ECallBackTemplateType::SetBntSeq;
  }


  unsigned char ERegReserveTypeSize = 3;

  const string ERegReserveType_to_string(ERegReserveType in_enum)
  {
    switch (in_enum) {
    case ERegReserveType::User: return "User";
    case ERegReserveType::Exception: return "Exception";
    case ERegReserveType::Unpredictable: return "Unpredictable";
    default:
      unknown_enum_value("ERegReserveType", (unsigned char)(in_enum));
    }
    return "";
  }

  ERegReserveType string_to_ERegReserveType(const string& in_str)
  {
    string enum_type_name = "ERegReserveType";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 110:
      validate(in_str, "Unpredictable", enum_type_name);
      return ERegReserveType::Unpredictable;
    case 115:
      validate(in_str, "User", enum_type_name);
      return ERegReserveType::User;
    case 120:
      validate(in_str, "Exception", enum_type_name);
      return ERegReserveType::Exception;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERegReserveType::User;
  }

  ERegReserveType try_string_to_ERegReserveType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 110:
      okay = (in_str == "Unpredictable");
      return ERegReserveType::Unpredictable;
    case 115:
      okay = (in_str == "User");
      return ERegReserveType::User;
    case 120:
      okay = (in_str == "Exception");
      return ERegReserveType::Exception;
    default:
      okay = false;
      return ERegReserveType::User;
    }
    return ERegReserveType::User;
  }


  unsigned char EDataAlignedTypeSize = 3;

  const string EDataAlignedType_to_string(EDataAlignedType in_enum)
  {
    switch (in_enum) {
    case EDataAlignedType::SingleDataAligned: return "SingleDataAligned";
    case EDataAlignedType::Unaligned: return "Unaligned";
    case EDataAlignedType::WholeDataAligned: return "WholeDataAligned";
    default:
      unknown_enum_value("EDataAlignedType", (unsigned char)(in_enum));
    }
    return "";
  }

  EDataAlignedType string_to_EDataAlignedType(const string& in_str)
  {
    string enum_type_name = "EDataAlignedType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 83:
      validate(in_str, "SingleDataAligned", enum_type_name);
      return EDataAlignedType::SingleDataAligned;
    case 85:
      validate(in_str, "Unaligned", enum_type_name);
      return EDataAlignedType::Unaligned;
    case 87:
      validate(in_str, "WholeDataAligned", enum_type_name);
      return EDataAlignedType::WholeDataAligned;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EDataAlignedType::SingleDataAligned;
  }

  EDataAlignedType try_string_to_EDataAlignedType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 83:
      okay = (in_str == "SingleDataAligned");
      return EDataAlignedType::SingleDataAligned;
    case 85:
      okay = (in_str == "Unaligned");
      return EDataAlignedType::Unaligned;
    case 87:
      okay = (in_str == "WholeDataAligned");
      return EDataAlignedType::WholeDataAligned;
    default:
      okay = false;
      return EDataAlignedType::SingleDataAligned;
    }
    return EDataAlignedType::SingleDataAligned;
  }


  unsigned char ESpeculativeBntActionTypeSize = 3;

  const string ESpeculativeBntActionType_to_string(ESpeculativeBntActionType in_enum)
  {
    switch (in_enum) {
    case ESpeculativeBntActionType::Execute: return "Execute";
    case ESpeculativeBntActionType::Restore: return "Restore";
    case ESpeculativeBntActionType::Pop: return "Pop";
    default:
      unknown_enum_value("ESpeculativeBntActionType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESpeculativeBntActionType string_to_ESpeculativeBntActionType(const string& in_str)
  {
    string enum_type_name = "ESpeculativeBntActionType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      validate(in_str, "Execute", enum_type_name);
      return ESpeculativeBntActionType::Execute;
    case 80:
      validate(in_str, "Pop", enum_type_name);
      return ESpeculativeBntActionType::Pop;
    case 82:
      validate(in_str, "Restore", enum_type_name);
      return ESpeculativeBntActionType::Restore;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESpeculativeBntActionType::Execute;
  }

  ESpeculativeBntActionType try_string_to_ESpeculativeBntActionType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 69:
      okay = (in_str == "Execute");
      return ESpeculativeBntActionType::Execute;
    case 80:
      okay = (in_str == "Pop");
      return ESpeculativeBntActionType::Pop;
    case 82:
      okay = (in_str == "Restore");
      return ESpeculativeBntActionType::Restore;
    default:
      okay = false;
      return ESpeculativeBntActionType::Execute;
    }
    return ESpeculativeBntActionType::Execute;
  }


  unsigned char EResourcePeStateTypeSize = 4;

  const string EResourcePeStateType_to_string(EResourcePeStateType in_enum)
  {
    switch (in_enum) {
    case EResourcePeStateType::RegisterPeState: return "RegisterPeState";
    case EResourcePeStateType::MemoryPeState: return "MemoryPeState";
    case EResourcePeStateType::DependencePeState: return "DependencePeState";
    case EResourcePeStateType::ExceptionPeState: return "ExceptionPeState";
    default:
      unknown_enum_value("EResourcePeStateType", (unsigned char)(in_enum));
    }
    return "";
  }

  EResourcePeStateType string_to_EResourcePeStateType(const string& in_str)
  {
    string enum_type_name = "EResourcePeStateType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      validate(in_str, "DependencePeState", enum_type_name);
      return EResourcePeStateType::DependencePeState;
    case 69:
      validate(in_str, "ExceptionPeState", enum_type_name);
      return EResourcePeStateType::ExceptionPeState;
    case 77:
      validate(in_str, "MemoryPeState", enum_type_name);
      return EResourcePeStateType::MemoryPeState;
    case 82:
      validate(in_str, "RegisterPeState", enum_type_name);
      return EResourcePeStateType::RegisterPeState;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EResourcePeStateType::RegisterPeState;
  }

  EResourcePeStateType try_string_to_EResourcePeStateType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      okay = (in_str == "DependencePeState");
      return EResourcePeStateType::DependencePeState;
    case 69:
      okay = (in_str == "ExceptionPeState");
      return EResourcePeStateType::ExceptionPeState;
    case 77:
      okay = (in_str == "MemoryPeState");
      return EResourcePeStateType::MemoryPeState;
    case 82:
      okay = (in_str == "RegisterPeState");
      return EResourcePeStateType::RegisterPeState;
    default:
      okay = false;
      return EResourcePeStateType::RegisterPeState;
    }
    return EResourcePeStateType::RegisterPeState;
  }


  unsigned char EReloadingMethodTypeSize = 2;

  const string EReloadingMethodType_to_string(EReloadingMethodType in_enum)
  {
    switch (in_enum) {
    case EReloadingMethodType::Move: return "Move";
    case EReloadingMethodType::Load: return "Load";
    default:
      unknown_enum_value("EReloadingMethodType", (unsigned char)(in_enum));
    }
    return "";
  }

  EReloadingMethodType string_to_EReloadingMethodType(const string& in_str)
  {
    string enum_type_name = "EReloadingMethodType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 76:
      validate(in_str, "Load", enum_type_name);
      return EReloadingMethodType::Load;
    case 77:
      validate(in_str, "Move", enum_type_name);
      return EReloadingMethodType::Move;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EReloadingMethodType::Move;
  }

  EReloadingMethodType try_string_to_EReloadingMethodType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 76:
      okay = (in_str == "Load");
      return EReloadingMethodType::Load;
    case 77:
      okay = (in_str == "Move");
      return EReloadingMethodType::Move;
    default:
      okay = false;
      return EReloadingMethodType::Move;
    }
    return EReloadingMethodType::Move;
  }


  unsigned char ESpAlignedTypeSize = 2;

  const string ESpAlignedType_to_string(ESpAlignedType in_enum)
  {
    switch (in_enum) {
    case ESpAlignedType::Aligned: return "Aligned";
    case ESpAlignedType::Unaligned: return "Unaligned";
    default:
      unknown_enum_value("ESpAlignedType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESpAlignedType string_to_ESpAlignedType(const string& in_str)
  {
    string enum_type_name = "ESpAlignedType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "Aligned", enum_type_name);
      return ESpAlignedType::Aligned;
    case 85:
      validate(in_str, "Unaligned", enum_type_name);
      return ESpAlignedType::Unaligned;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESpAlignedType::Aligned;
  }

  ESpAlignedType try_string_to_ESpAlignedType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "Aligned");
      return ESpAlignedType::Aligned;
    case 85:
      okay = (in_str == "Unaligned");
      return ESpAlignedType::Unaligned;
    default:
      okay = false;
      return ESpAlignedType::Aligned;
    }
    return ESpAlignedType::Aligned;
  }


  unsigned char ERestoreExclusionGroupSize = 5;

  const string ERestoreExclusionGroup_to_string(ERestoreExclusionGroup in_enum)
  {
    switch (in_enum) {
    case ERestoreExclusionGroup::GPR: return "GPR";
    case ERestoreExclusionGroup::SIMDFP: return "SIMDFP";
    case ERestoreExclusionGroup::VECREG: return "VECREG";
    case ERestoreExclusionGroup::System: return "System";
    case ERestoreExclusionGroup::Memory: return "Memory";
    default:
      unknown_enum_value("ERestoreExclusionGroup", (unsigned char)(in_enum));
    }
    return "";
  }

  ERestoreExclusionGroup string_to_ERestoreExclusionGroup(const string& in_str)
  {
    string enum_type_name = "ERestoreExclusionGroup";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 69:
      validate(in_str, "VECREG", enum_type_name);
      return ERestoreExclusionGroup::VECREG;
    case 73:
      validate(in_str, "SIMDFP", enum_type_name);
      return ERestoreExclusionGroup::SIMDFP;
    case 80:
      validate(in_str, "GPR", enum_type_name);
      return ERestoreExclusionGroup::GPR;
    case 101:
      validate(in_str, "Memory", enum_type_name);
      return ERestoreExclusionGroup::Memory;
    case 121:
      validate(in_str, "System", enum_type_name);
      return ERestoreExclusionGroup::System;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERestoreExclusionGroup::GPR;
  }

  ERestoreExclusionGroup try_string_to_ERestoreExclusionGroup(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 69:
      okay = (in_str == "VECREG");
      return ERestoreExclusionGroup::VECREG;
    case 73:
      okay = (in_str == "SIMDFP");
      return ERestoreExclusionGroup::SIMDFP;
    case 80:
      okay = (in_str == "GPR");
      return ERestoreExclusionGroup::GPR;
    case 101:
      okay = (in_str == "Memory");
      return ERestoreExclusionGroup::Memory;
    case 121:
      okay = (in_str == "System");
      return ERestoreExclusionGroup::System;
    default:
      okay = false;
      return ERestoreExclusionGroup::GPR;
    }
    return ERestoreExclusionGroup::GPR;
  }


  unsigned char ESchedulingStateSize = 3;

  const string ESchedulingState_to_string(ESchedulingState in_enum)
  {
    switch (in_enum) {
    case ESchedulingState::Random: return "Random";
    case ESchedulingState::Finishing: return "Finishing";
    case ESchedulingState::Locked: return "Locked";
    default:
      unknown_enum_value("ESchedulingState", (unsigned char)(in_enum));
    }
    return "";
  }

  ESchedulingState string_to_ESchedulingState(const string& in_str)
  {
    string enum_type_name = "ESchedulingState";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "Finishing", enum_type_name);
      return ESchedulingState::Finishing;
    case 76:
      validate(in_str, "Locked", enum_type_name);
      return ESchedulingState::Locked;
    case 82:
      validate(in_str, "Random", enum_type_name);
      return ESchedulingState::Random;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESchedulingState::Random;
  }

  ESchedulingState try_string_to_ESchedulingState(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "Finishing");
      return ESchedulingState::Finishing;
    case 76:
      okay = (in_str == "Locked");
      return ESchedulingState::Locked;
    case 82:
      okay = (in_str == "Random");
      return ESchedulingState::Random;
    default:
      okay = false;
      return ESchedulingState::Random;
    }
    return ESchedulingState::Random;
  }


  unsigned char ERestoreGroupSize = 5;

  const string ERestoreGroup_to_string(ERestoreGroup in_enum)
  {
    switch (in_enum) {
    case ERestoreGroup::GPR: return "GPR";
    case ERestoreGroup::VECREG: return "VECREG";
    case ERestoreGroup::PREDREG: return "PREDREG";
    case ERestoreGroup::System: return "System";
    case ERestoreGroup::Memory: return "Memory";
    default:
      unknown_enum_value("ERestoreGroup", (unsigned char)(in_enum));
    }
    return "";
  }

  ERestoreGroup string_to_ERestoreGroup(const string& in_str)
  {
    string enum_type_name = "ERestoreGroup";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 71:
      validate(in_str, "GPR", enum_type_name);
      return ERestoreGroup::GPR;
    case 77:
      validate(in_str, "Memory", enum_type_name);
      return ERestoreGroup::Memory;
    case 80:
      validate(in_str, "PREDREG", enum_type_name);
      return ERestoreGroup::PREDREG;
    case 83:
      validate(in_str, "System", enum_type_name);
      return ERestoreGroup::System;
    case 86:
      validate(in_str, "VECREG", enum_type_name);
      return ERestoreGroup::VECREG;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERestoreGroup::GPR;
  }

  ERestoreGroup try_string_to_ERestoreGroup(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 71:
      okay = (in_str == "GPR");
      return ERestoreGroup::GPR;
    case 77:
      okay = (in_str == "Memory");
      return ERestoreGroup::Memory;
    case 80:
      okay = (in_str == "PREDREG");
      return ERestoreGroup::PREDREG;
    case 83:
      okay = (in_str == "System");
      return ERestoreGroup::System;
    case 86:
      okay = (in_str == "VECREG");
      return ERestoreGroup::VECREG;
    default:
      okay = false;
      return ERestoreGroup::GPR;
    }
    return ERestoreGroup::GPR;
  }


  unsigned char EPartitionThreadPolicySize = 5;

  const string EPartitionThreadPolicy_to_string(EPartitionThreadPolicy in_enum)
  {
    switch (in_enum) {
    case EPartitionThreadPolicy::Random: return "Random";
    case EPartitionThreadPolicy::SameCore: return "SameCore";
    case EPartitionThreadPolicy::SameChip: return "SameChip";
    case EPartitionThreadPolicy::DiffChip: return "DiffChip";
    case EPartitionThreadPolicy::DiffCore: return "DiffCore";
    default:
      unknown_enum_value("EPartitionThreadPolicy", (unsigned char)(in_enum));
    }
    return "";
  }

  EPartitionThreadPolicy string_to_EPartitionThreadPolicy(const string& in_str)
  {
    string enum_type_name = "EPartitionThreadPolicy";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(5 < size ? 5 : 5 % size);

    switch (hash_value) {
    case 43:
      validate(in_str, "DiffCore", enum_type_name);
      return EPartitionThreadPolicy::DiffCore;
    case 44:
      validate(in_str, "DiffChip", enum_type_name);
      return EPartitionThreadPolicy::DiffChip;
    case 59:
      validate(in_str, "SameChip", enum_type_name);
      return EPartitionThreadPolicy::SameChip;
    case 60:
      validate(in_str, "SameCore", enum_type_name);
      return EPartitionThreadPolicy::SameCore;
    case 63:
      validate(in_str, "Random", enum_type_name);
      return EPartitionThreadPolicy::Random;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPartitionThreadPolicy::Random;
  }

  EPartitionThreadPolicy try_string_to_EPartitionThreadPolicy(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(5 < size ? 5 : 5 % size);

    switch (hash_value) {
    case 43:
      okay = (in_str == "DiffCore");
      return EPartitionThreadPolicy::DiffCore;
    case 44:
      okay = (in_str == "DiffChip");
      return EPartitionThreadPolicy::DiffChip;
    case 59:
      okay = (in_str == "SameChip");
      return EPartitionThreadPolicy::SameChip;
    case 60:
      okay = (in_str == "SameCore");
      return EPartitionThreadPolicy::SameCore;
    case 63:
      okay = (in_str == "Random");
      return EPartitionThreadPolicy::Random;
    default:
      okay = false;
      return EPartitionThreadPolicy::Random;
    }
    return EPartitionThreadPolicy::Random;
  }


  unsigned char ELargeConstraintSetStateSize = 3;

  const string ELargeConstraintSetState_to_string(ELargeConstraintSetState in_enum)
  {
    switch (in_enum) {
    case ELargeConstraintSetState::Clean: return "Clean";
    case ELargeConstraintSetState::AddCached: return "AddCached";
    case ELargeConstraintSetState::SubCached: return "SubCached";
    default:
      unknown_enum_value("ELargeConstraintSetState", (unsigned char)(in_enum));
    }
    return "";
  }

  ELargeConstraintSetState string_to_ELargeConstraintSetState(const string& in_str)
  {
    string enum_type_name = "ELargeConstraintSetState";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      validate(in_str, "AddCached", enum_type_name);
      return ELargeConstraintSetState::AddCached;
    case 67:
      validate(in_str, "Clean", enum_type_name);
      return ELargeConstraintSetState::Clean;
    case 83:
      validate(in_str, "SubCached", enum_type_name);
      return ELargeConstraintSetState::SubCached;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ELargeConstraintSetState::Clean;
  }

  ELargeConstraintSetState try_string_to_ELargeConstraintSetState(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 65:
      okay = (in_str == "AddCached");
      return ELargeConstraintSetState::AddCached;
    case 67:
      okay = (in_str == "Clean");
      return ELargeConstraintSetState::Clean;
    case 83:
      okay = (in_str == "SubCached");
      return ELargeConstraintSetState::SubCached;
    default:
      okay = false;
      return ELargeConstraintSetState::Clean;
    }
    return ELargeConstraintSetState::Clean;
  }


  unsigned char EAddressReuseTypeSize = 4;

  const string EAddressReuseType_to_string(EAddressReuseType in_enum)
  {
    switch (in_enum) {
    case EAddressReuseType::ReadAfterRead: return "ReadAfterRead";
    case EAddressReuseType::ReadAfterWrite: return "ReadAfterWrite";
    case EAddressReuseType::WriteAfterRead: return "WriteAfterRead";
    case EAddressReuseType::WriteAfterWrite: return "WriteAfterWrite";
    default:
      unknown_enum_value("EAddressReuseType", (unsigned char)(in_enum));
    }
    return "";
  }

  EAddressReuseType string_to_EAddressReuseType(const string& in_str)
  {
    string enum_type_name = "EAddressReuseType";
    size_t size = in_str.size();
    char hash_value = in_str.at(10 < size ? 10 : 10 % size);

    switch (hash_value) {
    case 82:
      validate(in_str, "WriteAfterRead", enum_type_name);
      return EAddressReuseType::WriteAfterRead;
    case 87:
      validate(in_str, "WriteAfterWrite", enum_type_name);
      return EAddressReuseType::WriteAfterWrite;
    case 101:
      validate(in_str, "ReadAfterRead", enum_type_name);
      return EAddressReuseType::ReadAfterRead;
    case 114:
      validate(in_str, "ReadAfterWrite", enum_type_name);
      return EAddressReuseType::ReadAfterWrite;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EAddressReuseType::ReadAfterRead;
  }

  EAddressReuseType try_string_to_EAddressReuseType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(10 < size ? 10 : 10 % size);

    switch (hash_value) {
    case 82:
      okay = (in_str == "WriteAfterRead");
      return EAddressReuseType::WriteAfterRead;
    case 87:
      okay = (in_str == "WriteAfterWrite");
      return EAddressReuseType::WriteAfterWrite;
    case 101:
      okay = (in_str == "ReadAfterRead");
      return EAddressReuseType::ReadAfterRead;
    case 114:
      okay = (in_str == "ReadAfterWrite");
      return EAddressReuseType::ReadAfterWrite;
    default:
      okay = false;
      return EAddressReuseType::ReadAfterRead;
    }
    return EAddressReuseType::ReadAfterRead;
  }


  unsigned char EStateElementDuplicateModeSize = 3;

  const string EStateElementDuplicateMode_to_string(EStateElementDuplicateMode in_enum)
  {
    switch (in_enum) {
    case EStateElementDuplicateMode::Fail: return "Fail";
    case EStateElementDuplicateMode::Replace: return "Replace";
    case EStateElementDuplicateMode::Ignore: return "Ignore";
    default:
      unknown_enum_value("EStateElementDuplicateMode", (unsigned char)(in_enum));
    }
    return "";
  }

  EStateElementDuplicateMode string_to_EStateElementDuplicateMode(const string& in_str)
  {
    string enum_type_name = "EStateElementDuplicateMode";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "Fail", enum_type_name);
      return EStateElementDuplicateMode::Fail;
    case 73:
      validate(in_str, "Ignore", enum_type_name);
      return EStateElementDuplicateMode::Ignore;
    case 82:
      validate(in_str, "Replace", enum_type_name);
      return EStateElementDuplicateMode::Replace;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EStateElementDuplicateMode::Fail;
  }

  EStateElementDuplicateMode try_string_to_EStateElementDuplicateMode(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "Fail");
      return EStateElementDuplicateMode::Fail;
    case 73:
      okay = (in_str == "Ignore");
      return EStateElementDuplicateMode::Ignore;
    case 82:
      okay = (in_str == "Replace");
      return EStateElementDuplicateMode::Replace;
    default:
      okay = false;
      return EStateElementDuplicateMode::Fail;
    }
    return EStateElementDuplicateMode::Fail;
  }


  unsigned char EStateTransitionTypeSize = 2;

  const string EStateTransitionType_to_string(EStateTransitionType in_enum)
  {
    switch (in_enum) {
    case EStateTransitionType::Boot: return "Boot";
    case EStateTransitionType::Explicit: return "Explicit";
    default:
      unknown_enum_value("EStateTransitionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EStateTransitionType string_to_EStateTransitionType(const string& in_str)
  {
    string enum_type_name = "EStateTransitionType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      validate(in_str, "Boot", enum_type_name);
      return EStateTransitionType::Boot;
    case 69:
      validate(in_str, "Explicit", enum_type_name);
      return EStateTransitionType::Explicit;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EStateTransitionType::Boot;
  }

  EStateTransitionType try_string_to_EStateTransitionType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      okay = (in_str == "Boot");
      return EStateTransitionType::Boot;
    case 69:
      okay = (in_str == "Explicit");
      return EStateTransitionType::Explicit;
    default:
      okay = false;
      return EStateTransitionType::Boot;
    }
    return EStateTransitionType::Boot;
  }


  unsigned char EStateTransitionOrderModeSize = 4;

  const string EStateTransitionOrderMode_to_string(EStateTransitionOrderMode in_enum)
  {
    switch (in_enum) {
    case EStateTransitionOrderMode::UseDefault: return "UseDefault";
    case EStateTransitionOrderMode::AsSpecified: return "AsSpecified";
    case EStateTransitionOrderMode::ByStateElementType: return "ByStateElementType";
    case EStateTransitionOrderMode::ByPriority: return "ByPriority";
    default:
      unknown_enum_value("EStateTransitionOrderMode", (unsigned char)(in_enum));
    }
    return "";
  }

  EStateTransitionOrderMode string_to_EStateTransitionOrderMode(const string& in_str)
  {
    string enum_type_name = "EStateTransitionOrderMode";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 68:
      validate(in_str, "UseDefault", enum_type_name);
      return EStateTransitionOrderMode::UseDefault;
    case 112:
      validate(in_str, "AsSpecified", enum_type_name);
      return EStateTransitionOrderMode::AsSpecified;
    case 114:
      validate(in_str, "ByPriority", enum_type_name);
      return EStateTransitionOrderMode::ByPriority;
    case 116:
      validate(in_str, "ByStateElementType", enum_type_name);
      return EStateTransitionOrderMode::ByStateElementType;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EStateTransitionOrderMode::UseDefault;
  }

  EStateTransitionOrderMode try_string_to_EStateTransitionOrderMode(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 68:
      okay = (in_str == "UseDefault");
      return EStateTransitionOrderMode::UseDefault;
    case 112:
      okay = (in_str == "AsSpecified");
      return EStateTransitionOrderMode::AsSpecified;
    case 114:
      okay = (in_str == "ByPriority");
      return EStateTransitionOrderMode::ByPriority;
    case 116:
      okay = (in_str == "ByStateElementType");
      return EStateTransitionOrderMode::ByStateElementType;
    default:
      okay = false;
      return EStateTransitionOrderMode::UseDefault;
    }
    return EStateTransitionOrderMode::UseDefault;
  }


  unsigned char EStateElementTypeSize = 9;

  const string EStateElementType_to_string(EStateElementType in_enum)
  {
    switch (in_enum) {
    case EStateElementType::Memory: return "Memory";
    case EStateElementType::SystemRegister: return "SystemRegister";
    case EStateElementType::VectorRegister: return "VectorRegister";
    case EStateElementType::GPR: return "GPR";
    case EStateElementType::VmContext: return "VmContext";
    case EStateElementType::PrivilegeLevel: return "PrivilegeLevel";
    case EStateElementType::PC: return "PC";
    case EStateElementType::FloatingPointRegister: return "FloatingPointRegister";
    case EStateElementType::PredicateRegister: return "PredicateRegister";
    default:
      unknown_enum_value("EStateElementType", (unsigned char)(in_enum));
    }
    return "";
  }

  EStateElementType string_to_EStateElementType(const string& in_str)
  {
    string enum_type_name = "EStateElementType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 67:
      validate(in_str, "VmContext", enum_type_name);
      return EStateElementType::VmContext;
    case 80:
      validate(in_str, "PC", enum_type_name);
      return EStateElementType::PC;
    case 82:
      validate(in_str, "GPR", enum_type_name);
      return EStateElementType::GPR;
    case 99:
      validate(in_str, "VectorRegister", enum_type_name);
      return EStateElementType::VectorRegister;
    case 101:
      validate(in_str, "PredicateRegister", enum_type_name);
      return EStateElementType::PredicateRegister;
    case 105:
      validate(in_str, "PrivilegeLevel", enum_type_name);
      return EStateElementType::PrivilegeLevel;
    case 109:
      validate(in_str, "Memory", enum_type_name);
      return EStateElementType::Memory;
    case 111:
      validate(in_str, "FloatingPointRegister", enum_type_name);
      return EStateElementType::FloatingPointRegister;
    case 115:
      validate(in_str, "SystemRegister", enum_type_name);
      return EStateElementType::SystemRegister;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EStateElementType::Memory;
  }

  EStateElementType try_string_to_EStateElementType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size);

    switch (hash_value) {
    case 67:
      okay = (in_str == "VmContext");
      return EStateElementType::VmContext;
    case 80:
      okay = (in_str == "PC");
      return EStateElementType::PC;
    case 82:
      okay = (in_str == "GPR");
      return EStateElementType::GPR;
    case 99:
      okay = (in_str == "VectorRegister");
      return EStateElementType::VectorRegister;
    case 101:
      okay = (in_str == "PredicateRegister");
      return EStateElementType::PredicateRegister;
    case 105:
      okay = (in_str == "PrivilegeLevel");
      return EStateElementType::PrivilegeLevel;
    case 109:
      okay = (in_str == "Memory");
      return EStateElementType::Memory;
    case 111:
      okay = (in_str == "FloatingPointRegister");
      return EStateElementType::FloatingPointRegister;
    case 115:
      okay = (in_str == "SystemRegister");
      return EStateElementType::SystemRegister;
    default:
      okay = false;
      return EStateElementType::Memory;
    }
    return EStateElementType::Memory;
  }


  unsigned char EEndiannessSize = 2;

  const string EEndianness_to_string(EEndianness in_enum)
  {
    switch (in_enum) {
    case EEndianness::LittleEndian: return "LittleEndian";
    case EEndianness::BigEndian: return "BigEndian";
    default:
      unknown_enum_value("EEndianness", (unsigned char)(in_enum));
    }
    return "";
  }

  EEndianness string_to_EEndianness(const string& in_str)
  {
    string enum_type_name = "EEndianness";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      validate(in_str, "BigEndian", enum_type_name);
      return EEndianness::BigEndian;
    case 76:
      validate(in_str, "LittleEndian", enum_type_name);
      return EEndianness::LittleEndian;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EEndianness::LittleEndian;
  }

  EEndianness try_string_to_EEndianness(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 66:
      okay = (in_str == "BigEndian");
      return EEndianness::BigEndian;
    case 76:
      okay = (in_str == "LittleEndian");
      return EEndianness::LittleEndian;
    default:
      okay = false;
      return EEndianness::LittleEndian;
    }
    return EEndianness::LittleEndian;
  }

}
