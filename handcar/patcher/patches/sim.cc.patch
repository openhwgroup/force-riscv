#
# Copyright (C) [2020] Futurewei Technologies, Inc.
#
# FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
# FIT FOR A PARTICULAR PURPOSE.
# See the License for the specific language governing permissions and
# limitations under the License.
#
5,6d4
< #include "dts.h"
< #include "remote_bitbang.h"
11d8
< #include <iostream>
20a18,39
> #include <fcntl.h>  // for elf loading
> #include <sys/mman.h>  // for elf loading
> #include <sys/stat.h>  // for elf loading
> 
> #include "disasm.h"
> #include "elf.h"  // for elf loading
> #include "memtracer.h"  // for address translation
> 
> //DEBUG
> extern "C" {
> // update_generator_register function: for the given cpuid, this callback function is called by the simulator to notify the user that a register has been accessed.
> //
> //  inputs:
> //      uint32_t cpuid -- refers to the processor ID
> //      const char* registerName -- the name of the reigster (programmer's name)
> //      uint64_t value -- the data stored in the register after update
> //      uint64_t mask -- 1's indicate relevant bits
> //      const char* accessType -- indicates if the access was a read or write.
> //
> void update_generator_register(uint32_t cpuid, const char* registerName, uint64_t value, uint64_t mask, const char* accessType);  //!< update generator register information when step an instruction
> }
> 
30,42c49
< sim_t::sim_t(const char* isa, const char* priv, const char* varch,
<              size_t nprocs, bool halted, bool real_time_clint,
<              reg_t initrd_start, reg_t initrd_end, const char* bootargs,
<              reg_t start_pc, std::vector<std::pair<reg_t, mem_t*>> mems,
<              std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices,
<              const std::vector<std::string>& args,
<              std::vector<int> const hartids,
<              const debug_module_config_t &dm_config,
<              const char *log_path,
<              bool dtb_enabled, const char *dtb_file,
< #ifdef HAVE_BOOST_ASIO
<              boost::asio::io_service *io_service_ptr, boost::asio::ip::tcp::acceptor *acceptor_ptr, // option -s
< #endif
---
> simlib_t::simlib_t(const char* isa, const char* priv, const char* varch, size_t nprocs, bool halted, const char* bootargs, reg_t start_pc, std::vector<int> const hartids, bool auto_init_mem,
44,49c51
<   : htif_t(args),
<     mems(mems),
<     plugin_devices(plugin_devices),
<     procs(std::max(nprocs, size_t(1))),
<     initrd_start(initrd_start),
<     initrd_end(initrd_end),
---
>   : procs(std::max(nprocs, size_t(1))),
52,54d53
<     dtb_file(dtb_file ? dtb_file : ""),
<     dtb_enabled(dtb_enabled),
<     log_file(log_path),
56,59d54
< #ifdef HAVE_BOOST_ASIO
<     io_service_ptr(io_service_ptr), // socket interface
<     acceptor_ptr(acceptor_ptr),
< #endif
65,67c60,62
<     log(false),
<     remote_bitbang(NULL),
<     debug_module(this, dm_config)
---
>     dtb_enabled(true),
>     _ForceSparseMemoryModel(Force::EMemBankType::Default, auto_init_mem),
>     entry(DRAM_BASE)
73,80d67
<   for (auto& x : mems)
<     bus.add_device(x.first, x.second);
< 
<   for (auto& x : plugin_devices)
<     bus.add_device(x.first, x.second);
< 
<   debug_module.add_device(&bus);
< 
93,106c80
<     procs[i] = new processor_t(isa, priv, varch, this, hart_id, halted,
<                                log_file.get(), sout_);
<   }
< 
<   make_dtb();
< 
<   void *fdt = (void *)dtb.c_str();
<   //handle clic
<   clint.reset(new clint_t(procs, CPU_HZ / INSNS_PER_RTC_TICK, real_time_clint));
<   reg_t clint_base;
<   if (fdt_parse_clint(fdt, &clint_base, "riscv,clint0")) {
<     bus.add_device(CLINT_BASE, clint.get());
<   } else {
<     bus.add_device(clint_base, clint.get());
---
>     procs[i] = new processor_t(isa, priv, varch, this, hart_id, halted, sout_);
108a83
>   // these inputs will have to be hard coded until dtb and fdt are added as dependencies.
110,114c85,89
<   int cpu_offset = 0, rc;
<   size_t cpu_idx = 0;
<   cpu_offset = fdt_get_offset(fdt, "/cpus");
<   if (cpu_offset < 0)
<     return;
---
>   //int cpu_offset = 0, rc;
>   //size_t cpu_idx = 0;
>   //cpu_offset = fdt_get_offset(fdt, "/cpus");
>   //if (cpu_offset < 0)
>   //  return;
116,117c91,92
<   for (cpu_offset = fdt_get_first_subnode(fdt, cpu_offset); cpu_offset >= 0;
<        cpu_offset = fdt_get_next_subnode(fdt, cpu_offset)) {
---
>   //for (cpu_offset = fdt_get_first_subnode(fdt, cpu_offset); cpu_offset >= 0;
>   //     cpu_offset = fdt_get_next_subnode(fdt, cpu_offset)) {
119,120c94,95
<     if (cpu_idx >= nprocs)
<       break;
---
>   //  if (cpu_idx >= nprocs)
>   //    break;
123,130c98,105
<     reg_t pmp_num = 0, pmp_granularity = 0;
<     if (fdt_parse_pmp_num(fdt, cpu_offset, &pmp_num) == 0) {
<       procs[cpu_idx]->set_pmp_num(pmp_num);
<     }
< 
<     if (fdt_parse_pmp_alignment(fdt, cpu_offset, &pmp_granularity) == 0) {
<       procs[cpu_idx]->set_pmp_granularity(pmp_granularity);
<     }
---
>   //  reg_t pmp_num = 0, pmp_granularity = 0;
>   //  if (fdt_parse_pmp_num(fdt, cpu_offset, &pmp_num) == 0) {
>   //    procs[cpu_idx]->set_pmp_num(pmp_num);
>   //  }
> 
>   //  if (fdt_parse_pmp_alignment(fdt, cpu_offset, &pmp_granularity) == 0) {
>   //    procs[cpu_idx]->set_pmp_granularity(pmp_granularity);
>   //  }
133,143c108,118
<     char mmu_type[256] = "";
<     rc = fdt_parse_mmu_type(fdt, cpu_offset, mmu_type);
<     if (rc == 0) {
<       procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SBARE);
<       if (strncmp(mmu_type, "riscv,sv32", strlen("riscv,sv32")) == 0) {
<         procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV32);
<       } else if (strncmp(mmu_type, "riscv,sv39", strlen("riscv,sv39")) == 0) {
<         procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV39);
<       } else if (strncmp(mmu_type, "riscv,sv48", strlen("riscv,sv48")) == 0) {
<         procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV48);
<       } else if (strncmp(mmu_type, "riscv,sbare", strlen("riscv,sbare")) == 0) {
---
>   //  char mmu_type[256] = "";
>   //  rc = fdt_parse_mmu_type(fdt, cpu_offset, mmu_type);
>   //  if (rc == 0) {
>   //    procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SBARE);
>   //    if (strncmp(mmu_type, "riscv,sv32", strlen("riscv,sv32")) == 0) {
>   //      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV32);
>   //    } else if (strncmp(mmu_type, "riscv,sv39", strlen("riscv,sv39")) == 0) {
>   //      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV39);
>   //    } else if (strncmp(mmu_type, "riscv,sv48", strlen("riscv,sv48")) == 0) {
>   //      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV48);
>   //    } else if (strncmp(mmu_type, "riscv,sbare", strlen("riscv,sbare")) == 0) {
145,163c120,138
<       } else {
<         std::cerr << "core ("
<                   << hartids.size()
<                   << ") doesn't have valid 'mmu-type'"
<                   << mmu_type << ").\n";
<         exit(1);
<       }
<     }
< 
<     cpu_idx++;
<   }
< 
<   if (cpu_idx != nprocs) {
<       std::cerr << "core number in dts ("
<                 <<  cpu_idx
<                 << ") doesn't match it in command line ("
<                 << nprocs << ").\n";
<       exit(1);
<   }
---
>   //    } else {
>   //      std::cerr << "core ("
>   //                << hartids.size()
>   //                << ") doesn't have valid 'mmu-type'"
>   //                << mmu_type << ").\n";
>   //      exit(1);
>   //    }
>   //  }
> 
>   //  cpu_idx++;
>   //}
> 
>   //if (cpu_idx != nprocs) {
>   //    std::cerr << "core number in dts ("
>   //              <<  cpu_idx
>   //              << ") doesn't match it in command line ("
>   //              << nprocs << ").\n";
>   //    exit(1);
>   //}
166c141
< sim_t::~sim_t()
---
> simlib_t::~simlib_t()
173c148
< void sim_thread_main(void* arg)
---
> int simlib_t::step_simulator(int target_id, int num_steps, int stx_failed)
175c150,166
<   ((sim_t*)arg)->main();
---
>   processor_t* proc_ptr = get_core(target_id);
>   if (proc_ptr == nullptr)
>     return 1;
>   proc_ptr->step(num_steps);
>   const char pc_name[] = "PC\0";
>   const uint64_t pc_mask = 0xFFFFFFFFFFFFFFFF;
>   uint64_t pc_value = 0x0;
>   const char pc_update_access_type[] = "write\0";
>   get_pc_api(target_id, reinterpret_cast<uint8_t*>(&pc_value), pc_name, sizeof(uint64_t));
>   update_generator_register(target_id, pc_name, pc_value, pc_mask, pc_update_access_type);
> 
>   return 0;
> }
> 
> void simlib_t::set_debug(bool value)
> {
>   debug = value;
178c169
< void sim_t::main()
---
> int simlib_t::get_disassembly(int target_id, const uint64_t* pc, char** opcode, char** disassembly)
180,181c171,173
<   if (!debug && log)
<     set_procs_debug(true);
---
>   std::string opcode_temp;
>   std::string disassembly_temp;
>   uint64_t opcode_num = 0ull;
183c175
<   while (!done())
---
>   if(procs.size() > 0)
185,190c177,194
<     if (debug || ctrlc_pressed)
<       interactive();
<     else
<       step(INTERLEAVE);
<     if (remote_bitbang) {
<       remote_bitbang->tick();
---
>     processor_t* proc_ptr = get_core(target_id);
>     if (proc_ptr == nullptr)
>       return 1;
>     try {
>       const disassembler_t* disassembler = proc_ptr->get_disassembler(); // should be OK to get processor's disassembler, using it should be idempotent
> 
>       // currently this fails a check in the Spike code if the pc isn't found so the code does not have the opportunity to return 1.
>       insn_fetch_t fetched = proc_ptr->get_mmu()->load_insn(*pc);
>       opcode_num = fetched.insn.bits() & ((1ull << (8 * insn_length(fetched.insn.bits()))) - 1); //This is the conversion the processor_t::disasm(...) uses to format the opcode for output.
>       disassembly_temp = disassembler->disassemble(fetched.insn);
>       // format the string interpretation of the opcode as a hex number.
>       std::stringstream stream;
>       stream << "0x" << std::hex << opcode_num;
>       opcode_temp = stream.str();
>     } catch(...) {
>       strcpy(*opcode,"00000000");
>       strcpy(*disassembly,"?");
>       return 1; // there may not be an instruction at the PC (example: page fault on branch)
193,200c197,200
< }
< 
< int sim_t::run()
< {
<   host = context_t::current();
<   target.init(sim_thread_main, this);
<   return htif_t::run();
< }
---
>   else
>   {
>     return 2; // No processors, therefore no configured disassembler for us to use
>   }
202,204c202,209
< void sim_t::step(size_t n)
< {
<   for (size_t i = 0, steps = 0; i < n; i += steps)
---
>   // At this point disassembly proceeded correctly. Now check the output buffers
>   if(opcode == nullptr || disassembly == nullptr)
>   {
>     return 2;
>   }
>   size_t opcode_buffer_length = opcode != nullptr ? strlen(*opcode) : 0;
>   size_t disassembly_buffer_length = disassembly != nullptr ? strlen(*disassembly) : 0;
>   if((opcode_buffer_length < (opcode_temp.size()+1)) || (disassembly_buffer_length < (disassembly_temp.size()+1))) // check for enough size to place the null termination character
206,207c211,212
<     steps = std::min(n - i, INTERLEAVE - current_step);
<     procs[current_proc]->step(steps);
---
>     return 2; // The user didn't give us room to put the answers
>   }
209,217c214,219
<     current_step += steps;
<     if (current_step == INTERLEAVE)
<     {
<       current_step = 0;
<       procs[current_proc]->get_mmu()->yield_load_reservation();
<       if (++current_proc == procs.size()) {
<         current_proc = 0;
<         clint->increment(INTERLEAVE / INSNS_PER_RTC_TICK);
<       }
---
>   // Warning: the 'insn't' null and string length tests above can fail to uncover a corner case of bad input, where a pointer to a string literal is aliased by a char* pointer.
>   // The compiler will accept this, but it will fail when you try to copy as in below, basically be sure your string buffer was correctly allocated.
>   opcode_temp.copy(*opcode, opcode_temp.size(), 0);
>   (*opcode)[opcode_temp.size()]='\0'; // No idea how the user is initializing these strings, so just null terminate the relevant part.
>   disassembly_temp.copy(*disassembly, disassembly_temp.size(), 0);
>   (*disassembly)[disassembly_temp.size()]='\0';
219,221c221
<       host->switch_to();
<     }
<   }
---
>   return 0;
224c224
< void sim_t::set_debug(bool value)
---
> void simlib_t::set_log(bool value)
226c226
<   debug = value;
---
>   log = value;
229c229
< void sim_t::set_histogram(bool value)
---
> void simlib_t::set_histogram(bool value)
237,257c237
< void sim_t::configure_log(bool enable_log, bool enable_commitlog)
< {
<   log = enable_log;
< 
<   if (!enable_commitlog)
<     return;
< 
< #ifndef RISCV_ENABLE_COMMITLOG
<   fputs("Commit logging support has not been properly enabled; "
<         "please re-build the riscv-isa-sim project using "
<         "\"configure --enable-commitlog\".\n",
<         stderr);
<   abort();
< #else
<   for (processor_t *proc : procs) {
<     proc->enable_log_commits();
<   }
< #endif
< }
< 
< void sim_t::set_procs_debug(bool value)
---
> void simlib_t::set_procs_debug(bool value)
263c243
< static bool paddr_ok(reg_t addr)
---
> std::map<std::string, uint64_t> simlib_t::load_elf(const char* fn, reg_t* entry)
265c245,316
<   return (addr >> MAX_PADDR_BITS) == 0;
---
>   int fd = open(fn, O_RDONLY);
>   struct stat s;
>   assert(fd != -1);
>   if (fstat(fd, &s) < 0)
>     abort();
>   size_t size = s.st_size;
> 
>   char* buf = (char*)mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
>   assert(buf != MAP_FAILED);
>   close(fd);
> 
>   assert(size >= sizeof(Elf64_Ehdr));
>   const Elf64_Ehdr* eh64 = (const Elf64_Ehdr*)buf;
>   assert(IS_ELF32(*eh64) || IS_ELF64(*eh64));
> 
>   std::vector<uint8_t> zeros;
>   std::vector<uint8_t> attrs;
>   std::map<std::string, uint64_t> symbols;
> 
>   #define LOAD_ELF(ehdr_t, phdr_t, shdr_t, sym_t) do { \
>     ehdr_t* eh = (ehdr_t*)buf; \
>     phdr_t* ph = (phdr_t*)(buf + eh->e_phoff); \
>     *entry = eh->e_entry; \
>     assert(size >= eh->e_phoff + eh->e_phnum*sizeof(*ph)); \
>     for (unsigned i = 0; i < eh->e_phnum; i++) { \
>       if(ph[i].p_type == PT_LOAD && ph[i].p_memsz) { \
>         if (ph[i].p_filesz) { \
>           assert(size >= ph[i].p_offset + ph[i].p_filesz); \
>           attrs.resize(ph[i].p_filesz); \
>           std::fill(attrs.begin(), attrs.end(), 0); \
>           initialize_multiword(ph[i].p_paddr, ph[i].p_filesz, (uint8_t*)buf + ph[i].p_offset); \
>         } \
>         zeros.resize(ph[i].p_memsz - ph[i].p_filesz); \
>         initialize_multiword(ph[i].p_paddr + ph[i].p_filesz, ph[i].p_memsz - ph[i].p_filesz, &zeros[0]); \
>       } \
>     } \
>     shdr_t* sh = (shdr_t*)(buf + eh->e_shoff); \
>     assert(size >= eh->e_shoff + eh->e_shnum*sizeof(*sh)); \
>     assert(eh->e_shstrndx < eh->e_shnum); \
>     assert(size >= sh[eh->e_shstrndx].sh_offset + sh[eh->e_shstrndx].sh_size); \
>     char *shstrtab = buf + sh[eh->e_shstrndx].sh_offset; \
>     unsigned strtabidx = 0, symtabidx = 0; \
>     for (unsigned i = 0; i < eh->e_shnum; i++) { \
>       unsigned max_len = sh[eh->e_shstrndx].sh_size - sh[i].sh_name; \
>       assert(sh[i].sh_name < sh[eh->e_shstrndx].sh_size); \
>       assert(strnlen(shstrtab + sh[i].sh_name, max_len) < max_len); \
>       if (sh[i].sh_type & SHT_NOBITS) continue; \
>       assert(size >= sh[i].sh_offset + sh[i].sh_size); \
>       if (strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) \
>         strtabidx = i; \
>       if (strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) \
>         symtabidx = i; \
>     } \
>     if (strtabidx && symtabidx) { \
>       char* strtab = buf + sh[strtabidx].sh_offset; \
>       sym_t* sym = (sym_t*)(buf + sh[symtabidx].sh_offset); \
>       for (unsigned i = 0; i < sh[symtabidx].sh_size/sizeof(sym_t); i++) { \
>         unsigned max_len = sh[strtabidx].sh_size - sym[i].st_name; \
>         assert(sym[i].st_name < sh[strtabidx].sh_size); \
>         assert(strnlen(strtab + sym[i].st_name, max_len) < max_len); \
>         symbols[strtab + sym[i].st_name] = sym[i].st_value; \
>       } \
>     } \
>   } while(0)
> 
>   if (IS_ELF32(*eh64))
>     LOAD_ELF(Elf32_Ehdr, Elf32_Phdr, Elf32_Shdr, Elf32_Sym);
>   else
>     LOAD_ELF(Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, Elf64_Sym);
> 
>   munmap(buf, size);
>   return symbols;
268c319,320
< bool sim_t::mmio_load(reg_t addr, size_t len, uint8_t* bytes)
---
> // use the dedicated function for initializing
> void simlib_t::make_dtb()
270,272d321
<   if (addr + len < addr || !paddr_ok(addr + len - 1))
<     return false;
<   return bus.load(addr, len, bytes);
275,301c324
< bool sim_t::mmio_store(reg_t addr, size_t len, const uint8_t* bytes)
< {
<   if (addr + len < addr || !paddr_ok(addr + len - 1))
<     return false;
<   return bus.store(addr, len, bytes);
< }
< 
< void sim_t::make_dtb()
< {
<   if (!dtb_file.empty()) {
<     std::ifstream fin(dtb_file.c_str(), std::ios::binary);
<     if (!fin.good()) {
<       std::cerr << "can't find dtb file: " << dtb_file << std::endl;
<       exit(-1);
<     }
< 
<     std::stringstream strstream;
<     strstream << fin.rdbuf();
< 
<     dtb = strstream.str();
<   } else {
<     dts = make_dts(INSNS_PER_RTC_TICK, CPU_HZ, initrd_start, initrd_end, bootargs, procs, mems);
<     dtb = dts_compile(dts);
<   }
< }
< 
< void sim_t::set_rom()
---
> void simlib_t::set_rom()
306a330,340
>   processor_t* usable_proc_ptr = nullptr;
>   for(uint32_t id = 0; id < 0xffffffffu; ++id)
>   {
>     if(doesCoreWithIdExist(id))
>     {
>       usable_proc_ptr = get_core(id);
>       break;
>     }
>   }
>   assert(usable_proc_ptr != nullptr);
> 
311c345
<     get_core(0)->get_xlen() == 32 ?
---
>     usable_proc_ptr->get_xlen() == 32 ?
338,343c372,382
<   std::string dtb;
<   if (!dtb_file.empty()) {
<     std::ifstream fin(dtb_file.c_str(), std::ios::binary);
<     if (!fin.good()) {
<       std::cerr << "can't find dtb file: " << dtb_file << std::endl;
<       exit(-1);
---
>   const int align = 0x1000;
>   rom.resize((rom.size() + align - 1) / align * align);
> 
>   //write the rom code to the sparse memory model instead
>   std::vector<char> attrVec(rom.size(), 0x0);
>   for( size_t _index = 0; _index < rom.size(); ++_index)
>   {
>     if(sparse_is_pa_initialized(DEFAULT_RSTVEC + _index, 1))
>     {
>       std::cerr << "### Warning something already initialized the memory for VA: " << std::hex << DEFAULT_RSTVEC + _index << " with contents: " << std::hex << sparse_read(DEFAULT_RSTVEC + _index, 1) << std::endl;
>       sparse_write(DEFAULT_RSTVEC + _index, reinterpret_cast<uint8_t*>(rom.data() + _index), 1);
344a384,389
>     else
>     {
>       sparse_initialize_pa(DEFAULT_RSTVEC + _index, reinterpret_cast<const uint8_t*>(rom.data()+_index), reinterpret_cast<const uint8_t*>(attrVec.data()+_index), 1, Force::EMemDataType::Both);
>     }
>   }
> }
346,347c391,396
<     std::stringstream strstream;
<     strstream << fin.rdbuf();
---
> // Not only loads the elf file in the specified path into the memory model but readies the simulator for stepping.
> int simlib_t::load_program_now(const char* elfPath)
> {
>   std::string path;
>   if (access(elfPath, F_OK) == 0)
>     path = elfPath;
349,352c398,401
<     dtb = strstream.str();
<   } else {
<     dts = make_dts(INSNS_PER_RTC_TICK, CPU_HZ, initrd_start, initrd_end, bootargs, procs, mems);
<     dtb = dts_compile(dts);
---
>   if (path.empty())
>   {
>     std::cerr << "could not open " << elfPath << " (did you misspell it? If VCS, did you forget +permissive/+permissive-off?)" << std::endl;
>     return 1;
355,357c404,409
<   rom.insert(rom.end(), dtb.begin(), dtb.end());
<   const int align = 0x1000;
<   rom.resize((rom.size() + align - 1) / align * align);
---
>   std::map<std::string, uint64_t> symbols = load_elf(path.c_str(), &entry);
> 
>   reset();
> 
>   return 0;
> }
359,360c411,413
<   boot_rom.reset(new rom_device_t(rom));
<   bus.add_device(DEFAULT_RSTVEC, boot_rom.get());
---
> uint64_t simlib_t::sparse_read(reg_t paddr, size_t len)
> {
>   return _ForceSparseMemoryModel.Read(paddr, len);
363,370c416,418
< char* sim_t::addr_to_mem(reg_t addr) {
<   if (!paddr_ok(addr))
<     return NULL;
<   auto desc = bus.find_device(addr);
<   if (auto mem = dynamic_cast<mem_t*>(desc.second))
<     if (addr - desc.first < mem->size())
<       return mem->contents(addr - desc.first);
<   return NULL;
---
> void simlib_t::sparse_read_partially_initialized(reg_t paddr, size_t len, uint8_t* bytes)
> {
>   _ForceSparseMemoryModel.ReadPartiallyInitialized(paddr, len, bytes);
373c421
< const char* sim_t::get_symbol(uint64_t addr)
---
> void simlib_t::sparse_write(reg_t paddr, const uint8_t* bytes, size_t len)
375c423
<   return htif_t::get_symbol(addr);
---
>   _ForceSparseMemoryModel.Write(paddr, bytes, len);
378c426,429
< // htif
---
> void simlib_t::sparse_write(reg_t paddr, uint64_t value, size_t len)
> {
>   _ForceSparseMemoryModel.Write(paddr, value, len);
> }
380c431
< void sim_t::reset()
---
> void simlib_t::sparse_write_with_initialization(reg_t paddr, const uint8_t* bytes, size_t len)
382,383c433,457
<   if (dtb_enabled)
<     set_rom();
---
>   if (not sparse_is_pa_initialized(paddr, len)) {
>     _ForceSparseMemoryModel.AutoInitialize(paddr, len);
>   }
> 
>   _ForceSparseMemoryModel.Write(paddr, bytes, len);
> }
> 
> bool simlib_t::sparse_is_pa_initialized(reg_t paddr, size_t len)
> {
>   return  _ForceSparseMemoryModel.IsInitialized(paddr, len);
> }
> 
> void simlib_t::sparse_initialize_pa(reg_t paddr, const uint8_t* data, const uint8_t* attrs, uint32_t nBytes, Force::EMemDataType type)
> {
>   _ForceSparseMemoryModel.Initialize(paddr, data, attrs, nBytes, type);
> }
> 
> void simlib_t::sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes, Force::EMemDataType type)
> {
>   _ForceSparseMemoryModel.Initialize(paddr, value, numBytes, type);
> }
> 
> void simlib_t::sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes)
> {
>   _ForceSparseMemoryModel.Initialize(paddr, value, numBytes, Force::EMemDataType::Both);
386c460
< void sim_t::idle()
---
> void simlib_t::sparse_reserve(reg_t paddr, size_t numBytes)
388c462
<   target.switch_to();
---
>   _ForceSparseMemoryModel.Reserve(paddr, numBytes);
391c465,499
< void sim_t::read_chunk(addr_t taddr, size_t len, void* dst)
---
> void simlib_t::sparse_unreserve(reg_t paddr, size_t numBytes)
> {
>   _ForceSparseMemoryModel.Unreserve(paddr, numBytes);
> }
> 
> bool simlib_t::sparse_is_reserved(reg_t paddr, size_t numBytes)
> {
>   return _ForceSparseMemoryModel.IsReserved(paddr, numBytes);
> }
> 
> bool simlib_t::doesCoreWithIdExist(size_t i)
> {
>   for(processor_t* proc_ptr: procs)
>   {
>     if(proc_ptr != nullptr && proc_ptr->get_state() != nullptr && proc_ptr->get_state()->pid == i)
>     {
>       return true;
>     }
>   }
> 
>   return false;
> }
> 
> void simlib_t::dump_sparse_memory(std::ostream & out)
> {
>   _ForceSparseMemoryModel.Dump(out);
> }
> 
> void simlib_t::reset()
> {
>   if (dtb_enabled)
>     set_rom();
> }
> 
> void simlib_t::read_chunk_partially_initialized(reg_t taddr, size_t len, void* dst)
394c502
<   auto data = debug_mmu->to_target(debug_mmu->load_uint64(taddr));
---
>   auto data = debug_mmu->to_target(debug_mmu->load_partially_initialized_uint64(taddr));
398c506,559
< void sim_t::write_chunk(addr_t taddr, size_t len, const void* src)
---
> void simlib_t::clear_chunk(reg_t taddr, size_t len)
> {
>   char zeros[chunk_max_size()];
>   memset(zeros, 0, chunk_max_size());
> 
>   for (size_t pos = 0; pos < len; pos += chunk_max_size())
>     write_chunk(taddr + pos, std::min(len - pos, chunk_max_size()), zeros);
> }
> 
> void simlib_t::initialize_multiword(reg_t addr, size_t len, const void* bytes) // To support multiword initializations during elf loading
> {
>   size_t align = chunk_align();
>   if (len && (addr & (align-1)))
>   {
>     size_t this_len = std::min(len, align - size_t(addr & (align-1)));
>     uint8_t chunk[align];
> 
>     read_chunk_partially_initialized(addr & ~(align-1), align, chunk);
>     memcpy(chunk + (addr & (align-1)), bytes, this_len);
>     write_chunk(addr & ~(align-1), align, chunk);
> 
>     bytes = (char*)bytes + this_len;
>     addr += this_len;
>     len -= this_len;
>   }
> 
>   if (len & (align-1))
>   {
>     size_t this_len = len & (align-1);
>     size_t start = len - this_len;
>     uint8_t chunk[align];
> 
>     read_chunk_partially_initialized(addr + start, align, chunk);
>     memcpy(chunk, (char*)bytes + start, this_len);
>     write_chunk(addr + start, align, chunk);
> 
>     len -= this_len;
>   }
> 
>   // now we're aligned
>   bool all_zero = len != 0;
>   for (size_t i = 0; i < len; i++)
>     all_zero &= ((const char*)bytes)[i] == 0;
> 
>   if (all_zero) {
>     clear_chunk(addr, len);
>   } else {
>     size_t max_chunk = chunk_max_size();
>     for (size_t pos = 0; pos < len; pos += max_chunk)
>       write_chunk(addr + pos, std::min(max_chunk, len - pos), (char*)bytes + pos);
>   }
> }
> 
> void simlib_t::write_chunk(reg_t taddr, size_t len, const void* src)
406c567
< void sim_t::set_target_endianness(memif_endianness_t endianness)
---
> void simlib_t::set_target_endianness(memif_endianness_t endianness)
422c583
< memif_endianness_t sim_t::get_target_endianness() const
---
> memif_endianness_t simlib_t::get_target_endianness() const
431c592
< void sim_t::proc_reset(unsigned id)
---
> void simlib_t::proc_reset(unsigned id)
433c594
<   debug_module.proc_reset(id);
---
> ////  debug_module.proc_reset(id);
434a596,1389
> 
> processor_t *simlib_t::get_core(const std::string& i)
> {
>   char *ptr;
>   unsigned long p = strtoul(i.c_str(), &ptr, 10);
>   //if (*ptr || p >= procs.size())
>   //  throw trap_interactive();
>   return get_core(p);
> }
> 
> reg_t simlib_t::get_mem(const std::vector<std::string>& args)
> {
>   //if(args.size() != 1 && args.size() != 2)
>   //  throw trap_interactive();
> 
>   std::string addr_str = args[0];
>   mmu_t* mmu = debug_mmu;
>   if(args.size() == 2)
>   {
>     processor_t *p = get_core(args[0]);
>     mmu = p->get_mmu();
>     addr_str = args[1];
>   }
> 
>   reg_t addr = strtol(addr_str.c_str(),NULL,16), val;
>   if(addr == LONG_MAX)
>     addr = strtoul(addr_str.c_str(),NULL,16);
> 
>   switch(addr % 8)
>   {
>     case 0:
>       val = mmu->load_uint64(addr);
>       break;
>     case 4:
>       val = mmu->load_uint32(addr);
>       break;
>     case 2:
>     case 6:
>       val = mmu->load_uint16(addr);
>       break;
>     default:
>       val = mmu->load_uint8(addr);
>       break;
>   }
>   return val;
> }
> 
> uint64_t simlib_t::get_csr_number(const std::string& input_name)
> {
>   //Cant use a switch here unless we map the names to ints beforehand
>   #define DECLARE_CSR(name, number) if (input_name == #name) return number;
>   #include "encoding.h"              // generates if's for all csrs
>   return 0xDEADBEEFDEADBEEF;         // else return a value outside the ISA established 4096 possible
>   #undef DECLARE_CSR
> }
> 
> uint64_t simlib_t::get_xpr_number(const std::string& input_name)
> {
>   return std::find(xpr_arch_name, xpr_arch_name + NXPR, input_name) - xpr_arch_name;
> }
> 
> uint64_t simlib_t::get_fpr_number(const std::string& input_name)
> {
>   return std::find(fpr_arch_name, fpr_arch_name + NFPR, input_name) - fpr_arch_name;
> }
> 
> uint64_t simlib_t::get_vecr_number(const std::string& input_name)
> {
>   return std::find(vr_name, vr_name + NVPR, input_name) - vr_name;
> }
> 
> std::string simlib_t::get_csr_name(uint64_t index)
> {
>   if(index < NCSR)
>     return csr_name(index);
>   else
>     return "unknown-csr";
> }
> 
> std::string simlib_t::get_xpr_name(uint64_t index)
> {
>   if(index < NXPR)
>     return xpr_arch_name[index];
>   else
>     return "unknown-xpr";
> }
> 
> std::string simlib_t::get_fpr_name(uint64_t index)
> {
>   if(index < NFPR)
>     return fpr_arch_name[index];
>   else
>     return "unknown-fpr";
> }
> 
> std::string simlib_t::get_vecr_name(uint64_t index)
> {
>   if(index < NVPR)
>     return vr_name[index];
>   else
>     return "unknown-vr";
> }
> 
> int simlib_t::read_csr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index is valid
>   if(index >= NCSR)
>     return 3;
> 
>   //Check if the index corresponds to a defined csr
>   // WARNING: there are a number of CSRs that are defined in encoding.h but have no entry in the processor class get_csr method. In this case, for now, a value of 0xDEADBEEFDEADBEEF will be returned
>   std::string temp_name = get_csr_name(index);
>   size_t unknown = temp_name.find("unknown");
>   if(unknown != std::string::npos)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   *value = get_core(procid)->get_csr_api(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;
> }
> 
> int simlib_t::read_csr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_csr_number(input_name);
>   if(index >= NCSR)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   *value = get_core(procid)->get_csr_api(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;
> }
> 
> int simlib_t::read_xpr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_xpr_number(input_name);
>   if(index >= NXPR)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   *value = get_core(procid)->get_state()->XPR.readNoCallback(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;
> }
> 
> int simlib_t::read_xpr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the index provided is valid
>   if(index >= NXPR)
>     return 3;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   //*value = get_core(procid)->get_state()->XPR[index];
> 
>   *value = get_core(procid)->get_state()->XPR.readNoCallback(index);
>   *length = get_core(procid)->get_xlen() / 8;
> 
>   return 0;
> }
> 
> int simlib_t::read_fpr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the name provided is valid
>   uint64_t index = get_fpr_number(input_name);
>   if(index >= NFPR)
>     return 3;
> 
>   //Check that the advertised length of the provided buffer is sufficient
>   if(*length < sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   freg_t temp_fpr_val = get_core(procid)->get_state()->FPR.readNoCallback(index);
>   memcpy(value, &temp_fpr_val, sizeof(freg_t));
>   *length = sizeof(freg_t);
> 
>   return 0;
> }
> 
> int simlib_t::read_fpr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NFPR)
>     return 3;
> 
>   if(*length < sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed
>   freg_t temp_fpr_val = get_core(procid)->get_state()->FPR.readNoCallback(index);
>   memcpy(value, &temp_fpr_val, sizeof(freg_t));
>   *length = sizeof(freg_t);
> 
>   return 0;
> }
> 
> int simlib_t::read_vecr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name provided is valid
>   uint64_t index = get_vecr_number(input_name);
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen > *length){
>     return 4;
>   }
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     uint64_t val = 0ull;
>     switch(elen)
>     {
>       case 8:
>       val = get_core(procid)->VU.elt<uint64_t>(index, element);
>       break;
>       case 4:
>       val = get_core(procid)->VU.elt<uint32_t>(index, element);
>       break;
>       case 2:
>       val = get_core(procid)->VU.elt<uint16_t>(index, element);
>       break;
>       case 1:
>       val = get_core(procid)->VU.elt<uint8_t>(index, element);
>       break;
>     }
> 
>     memcpy(value + element * elen, &val, elen);
>   }
> 
>   //Set the length value to the number of bytes that was written
>   *length = vlen;
> 
>   return 0;
> }
> 
> int simlib_t::read_vecr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr || length == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen > *length){
>     return 4;
>   }
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     uint64_t val = 0ull;
>     switch(elen)
>     {
>       case 8:
>       val = get_core(procid)->VU.elt<uint64_t>(index, element);
>       break;
>       case 4:
>       val = get_core(procid)->VU.elt<uint32_t>(index, element);
>       break;
>       case 2:
>       val = get_core(procid)->VU.elt<uint16_t>(index, element);
>       break;
>       case 1:
>       val = get_core(procid)->VU.elt<uint8_t>(index, element);
>       break;
>     }
> 
>     memcpy(value + element * elen, &val, elen);
>   }
> 
>   //Set the length value to the number of bytes that was written
>   *length = vlen;
> 
>   return 0;
> }
> 
> int simlib_t::partial_read_vecr(uint32_t procid, uint64_t index, uint8_t* pValue, uint32_t length, uint32_t offset)
> {
>   //Check that the pointers point to something
>   if(pValue == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen < (offset + length)){
>     return 4;
>   }
> 
>   //All checks passed; write the elements into the value buffer
>   // make this a memcpy
>   for(size_t element = offset; element < (offset + length); ++element)
>   {
>     pValue[element - offset] = get_core(procid)->VU.elt<uint8_t>(index, element);
>   }
> 
>   return 0;
> }
> 
> 
> int simlib_t::partial_write_vecr(uint32_t procid, uint64_t index, const uint8_t* pValue, uint32_t length, uint32_t offset)
> {
>   //Check that the pointers point to something
>   if(pValue == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen < (offset + length)){
>     return 4;
>   }
> 
>   //All checks passed; write the elements into the value buffer
>   // make this a memcpy
>   for(size_t element = offset; element < (offset + length); ++element)
>   {
>     get_core(procid)->VU.elt<uint8_t>(index, element) = pValue[element - offset];
>   }
> 
>   return 0;
> }
> 
> 
> int simlib_t::write_csr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index is valid
>   if(index >= NCSR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   if(length != (get_core(procid)->get_xlen() / 8))
>     return 4;
> 
>   //All checks pass, so go ahead and and write to the csr
>   get_core(procid)->set_csr_api(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_csr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_csr_number(input_name);
>   if(index >= NCSR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   if(length != (get_core(procid)->get_xlen() / 8))
>     return 4;
> 
>   //All checks pass, so go ahead and and write to the csr
>   get_core(procid)->set_csr_api(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_xpr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name is valid
>   uint64_t index = get_xpr_number(input_name);
>   if(index >= NXPR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   //if(length != (get_core(procid)->get_xlen() / 8))
>   //  return 4;
> 
>   //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
>   get_core(procid)->get_state()->XPR.writeNoCallback(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_xpr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the index provided is valid
>   if(index >= NXPR)
>     return 3;
> 
>   //Is the indended write length matching the xlen value?
>   //if(length != (get_core(procid)->get_xlen() / 8))
>   //  return 4;
> 
>   //All checks pass so we're go to write
>   get_core(procid)->get_state()->XPR.writeNoCallback(index, *value);
> 
>   return 0;
> }
> 
> int simlib_t::write_fpr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //check if the name provided is valid
>   uint64_t index = get_fpr_number(input_name);
>   if(index >= NFPR)
>     return 3;
> 
>   //Is the indended write length matching the flen value?
>   if(length > sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed perform the write via a memory operation into the floating point register model
>   freg_t temp_fpr_val;
>   temp_fpr_val.v[0] = 0xffffffffffffffffull;
>   temp_fpr_val.v[1] = 0xffffffffffffffffull;
>   memcpy(&temp_fpr_val, value, length);
>   get_core(procid)->get_state()->FPR.writeNoCallback(index, temp_fpr_val);
> 
>   return 0;
> }
> 
> int simlib_t::write_fpr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length)
> {
>   //Check if the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check if the procid AKA hart id is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NFPR)
>     return 3;
> 
>   //Is the indended write length matching the flen value?
>   if(length > sizeof(freg_t))
>     return 4;
> 
>   //All checks have passed perform the write via a memory operation into the floating point register model
>   freg_t temp_fpr_val;
>   temp_fpr_val.v[0] = 0xffffffffffffffffull;
>   temp_fpr_val.v[1] = 0xffffffffffffffffull;
>   memcpy(&temp_fpr_val, value, length);
>   get_core(procid)->get_state()->FPR.writeNoCallback(index, temp_fpr_val);
> 
>   return 0;
> }
> 
> //will probably have to cast differently here and other places to the get the pointer types the same and compatible with the function.
> int simlib_t::write_vecr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the name provided is valid
>   uint64_t index = get_vecr_number(input_name);
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes equals the size of the vector register
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen != length)
>     return 4;
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     switch(elen)
>     {
>       case 8:
>       {
>         uint64_t* reg = &(get_core(procid)->VU.elt<uint64_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 4:
>       {
>         uint32_t* reg = &(get_core(procid)->VU.elt<uint32_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 2:
>       {
>         uint16_t* reg = &(get_core(procid)->VU.elt<uint16_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 1:
>       {
>         uint8_t* reg = &(get_core(procid)->VU.elt<uint8_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>     }
>   }
> 
>   return 0;
> }
> 
> int simlib_t::write_vecr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length)
> {
>   //Check that the pointers point to something
>   if(value == nullptr)
>     return 1;
> 
>   //Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   //Check if the index provided is valid
>   if(index >= NVPR)
>     return 3;
> 
>   //Check that the advertised length of the buffer in bytes can hold the requested data
>   size_t vlen = get_core(procid)->VU.get_vlen() / 8;
>   if(vlen != length)
>     return 4;
> 
>   //All checks passed
>   size_t elen = get_core(procid)->VU.get_elen() / 8;
>   size_t num_elem = vlen/elen;
> 
>   //Write the elements into the value buffer
>   for(size_t element = 0; element < num_elem; ++element)
>   {
>     switch(elen)
>     {
>       case 8:
>       {
>         uint64_t* reg = &(get_core(procid)->VU.elt<uint64_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 4:
>       {
>         uint32_t* reg = &(get_core(procid)->VU.elt<uint32_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 2:
>       {
>         uint16_t* reg = &(get_core(procid)->VU.elt<uint16_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>       case 1:
>       {
>         uint8_t* reg = &(get_core(procid)->VU.elt<uint8_t>(index, element));
>         memcpy(reg, value + element * elen, elen);
>         break;
>       }
>     }
>   }
> 
>   return 0;
> }
> 
> int simlib_t::translate_virtual_address_api(int procid, const uint64_t* vaddr, int intent, uint64_t* paddr, uint64_t* memattrs)
> {
>   // check the pointers do point to something
>   if(vaddr == nullptr || paddr == nullptr || memattrs == nullptr)
>     return 1;
> 
>   // Check that the procid AKA hart is valid
>   if(not doesCoreWithIdExist(procid))
>     return 2;
> 
>   // get the mmu for the specified processor and call the translation api function
>   access_type type;
>   switch(intent)
>   {
>     case(0):
>       type = access_type::LOAD;
>       break;
>     case(1):
>       type = access_type::STORE;
>       break;
>     case(2):
>       type = access_type::FETCH;
>       break;
>   }
>   // TODO(Noah): Investigate what might need to be passed for the xlate_flags parameter when there
>   // is time to do so.
>   int status = get_core(procid)->get_mmu()->translate_api(*vaddr, paddr, memattrs, reg_t(1) /* length */, static_cast<access_type>(intent), 0); // length is set to 1 byte here because the api requirements were for individual bytes only.
> 
>   if(status == 0)
>   {
>     return 0;
>   }
> 
>   return status + 2;
> }
> 
> bool simlib_t::set_pc_api(int procid, const std::string& name, const uint8_t* bytes, size_t len)
> {
>   if(bytes == nullptr)
>   {
>     return false;
>   }
>   else if(not doesCoreWithIdExist(procid))
>   {
>     return false;
>   }
> 
>   processor_t* proc_ptr = get_core(procid);
>   if(proc_ptr == nullptr)
>   {
>     return false;
>   }
> 
>   return get_core(procid)->set_pc_api(name, bytes, len);
> }
> 
> bool simlib_t::get_pc_api(int procid, uint8_t* bytes, const std::string& name, size_t len)
> {
>   if(bytes == nullptr)
>   {
>     return false;
>   }
>   else if(not doesCoreWithIdExist(procid))
>   {
>     return false;
>   }
> 
>   processor_t* proc_ptr = get_core(procid);
>   if(proc_ptr == nullptr)
>   {
>     return false;
>   }
> 
>   return get_core(procid)->retrieve_pc_api(bytes, name, len); // The method called in processor_t will validate the name and length.
> }
> 
> bool simlib_t::set_privilege_api(int procid, const uint64_t* val)
> {
>   if (nullptr == val) return false;
>   if (!doesCoreWithIdExist(procid)) return false;
> 
>   processor_t* proc_ptr = get_core(procid);
>   if (nullptr == proc_ptr) return false;
> 
>   //assert in legalize_privilege should catch invalid values
>   //register field is only 2 bits so shouldn't be able to pass invalid case from force
>   proc_ptr->set_privilege_api(*val);
>   return true;
> }
> 
> bool simlib_t::get_privilege_api(int procid, uint64_t* val)
> {
>   if(nullptr == val) return false;
>   if(!doesCoreWithIdExist(procid)) return false;
> 
>   processor_t* proc_ptr = get_core(procid);
>   if(nullptr == proc_ptr) return false;
> 
>   proc_ptr->retrieve_privilege_api(val);
>   return true;
> }
> 
