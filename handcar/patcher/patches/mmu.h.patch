#
# Copyright (C) [2020] Futurewei Technologies, Inc.
#
# FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
# FIT FOR A PARTICULAR PURPOSE.
# See the License for the specific language governing permissions and
# limitations under the License.
#
15a16,58
> #include "Force_Memory.h"
> 
> //!< MmuEvent - struct used to record memory events from simulator...
> typedef enum _Memtype { Strong,Device,Normal } Memtype;
> typedef unsigned int CacheType;
> typedef unsigned int CacheAttrs;
> struct MmuEvent
> {
>   MmuEvent(uint64_t _va, uint64_t _pa, Memtype _type, bool _has_stage_two, CacheType _outer_type, CacheAttrs _outer_attrs, CacheType _inner_type, CacheAttrs _inner_attrs)
>     : va(_va), pa(_pa), type(_type), has_stage_two(_has_stage_two), outer_type(_outer_type), outer_attrs(_outer_attrs), inner_type(_inner_type), inner_attrs(_inner_attrs)
>   {
>   }
> 
>   uint64_t va;
>   uint64_t pa;
>   Memtype type;
>   bool has_stage_two;
>   CacheType outer_type;
>   CacheAttrs outer_attrs;
>   CacheType inner_type;
>   CacheAttrs inner_attrs;
> };
> 
> struct SimException {
>   SimException() : mExceptionID(0), mExceptionAttributes(0), mpComments(""), mEPC(0) {}
>   SimException(uint32_t exceptionID, uint32_t exceptionAttributes, const char* comments, uint64_t epc) :
>     mExceptionID(exceptionID), mExceptionAttributes(exceptionAttributes), mpComments(comments), mEPC(epc) {}
>   uint32_t mExceptionID; //!< 0x4E: eret. Other values are scause or mcause codes.   
>   uint32_t  mExceptionAttributes;  //!< copied from tval. 
>   const char* mpComments; //!<  exception comments, identifies enter, exit and m or s modes.
>   uint64_t mEPC; //!< exception program counter.
> };
> 
> extern "C" {
>     // memory r/w callback
>     void update_generator_memory(uint32_t cpuid, uint64_t virtualAddress, uint32_t memBank, uint64_t physicalAddress, uint32_t size, const char *pBytes, const char *pAccessType);
> 
>     // mmu update callback
>     void update_mmu_event(MmuEvent *event);
> 
>     //exception handling callback
>     void update_exception_event(const SimException* exception);
> }
75a119,130
>   inline reg_t misaligned_load_partially_initialized(reg_t addr, size_t size)
>   {
> #ifdef RISCV_ENABLE_MISALIGNED
>     reg_t res = 0;
>     for (size_t i = 0; i < size; i++)
>       res += (reg_t)load_partially_initialized_uint8(addr + i) << (i * 8);
>     return res;
> #else
>     throw trap_load_address_misaligned(addr, 0, 0);
> #endif
>   }
> 
108,109c163,168
<         if (proc) READ_MEM(addr, size); \
<         return from_target(*(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); \
---
>         reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
>         type##_t data = static_cast<type##_t>(sim->sparse_read(paddr, size)); \
>         data = to_value_from_be(data); \
>         type##_t update_data = to_target_from_value(data); \
>         update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&update_data), "read"); \
>         return data; \
112c171,173
<         type##_t data = from_target(*(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); \
---
>         reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
>         type##_t data = static_cast<type##_t>(sim->sparse_read(paddr, size)); \
>         data = to_value_from_be(data); \
118c179,180
<         if (proc) READ_MEM(addr, size); \
---
>         type##_t update_data = to_target_from_value(data); \
>         update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&update_data), "read"); \
155,160c217,228
< #ifndef RISCV_ENABLE_COMMITLOG
< # define WRITE_MEM(addr, value, size) ({})
< #else
< # define WRITE_MEM(addr, val, size) \
<   proc->state.log_mem_write.push_back(std::make_tuple(addr, val, size));
< #endif
---
>   // template for functions that load an aligned value from memory
>   #define load_func_partially_initialized(type, xlate_flags)\
>     inline type##_t load_partially_initialized_##type(reg_t addr) { \
>       if (unlikely(addr & (sizeof(type##_t)-1))) \
>         return misaligned_load_partially_initialized(addr, sizeof(type##_t)); \
>       type##_t res; \
>       load_slow_path_partially_initialized(addr, sizeof(type##_t), (uint8_t*)&res, xlate_flags); \
>       return res; \
>     }
> 
>   load_func_partially_initialized(uint8, 0)
>   load_func_partially_initialized(uint64, 0)
170c238,239
<       size_t size = sizeof(type##_t); \
---
>       type##_t data = to_target_from_value(val); \
>       reg_t size = sizeof(type##_t); \
172,173c241,249
<         if (proc) WRITE_MEM(addr, val, size); \
<         *(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val); \
---
>         reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
>         update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&data), "write"); \
>         if (unlikely(!sim->sparse_is_pa_initialized(paddr, size))) { \
>           uint64_t attrs = 0; \
>           sim->sparse_initialize_pa(paddr, (const uint8_t*)&data, reinterpret_cast<const uint8_t*>(&attrs), size, Force::EMemDataType::Both); \
>         } \
>         else { \
>           sim->sparse_write(paddr, (const uint8_t*)&data, size); \
>         } \
181,182c257,265
<         if (proc) WRITE_MEM(addr, val, size); \
<         *(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val); \
---
>         reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
>         update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&data), "write"); \
>         if(unlikely(!sim->sparse_is_pa_initialized(paddr, size))) { \
>           uint64_t attrs = 0; \
>           sim->sparse_initialize_pa(paddr, (const uint8_t*)&data, reinterpret_cast<const uint8_t*>(&attrs), size, Force::EMemDataType::Both); \
>         } \
>         else { \
>           sim->sparse_write(paddr, (const uint8_t*)&data, size); \
>         } \
185,187c268
<         target_endian<type##_t> target_val = to_target(val); \
<         store_slow_path(addr, sizeof(type##_t), (const uint8_t*)&target_val, (xlate_flags)); \
<         if (proc) WRITE_MEM(addr, val, size); \
---
>        store_slow_path(addr, sizeof(type##_t), (const uint8_t*)&data, (xlate_flags)); \
189,191c270
<       if ((xlate_flags) != 0) \
<         flush_tlb(); \
<   }
---
>     }
247a327,328
>   static const size_t LOAD_RESERVATION_SIZE = 8;
> 
249a331
>     sim->sparse_unreserve(load_reservation_address, LOAD_RESERVATION_SIZE);
255,259c337,340
<     reg_t paddr = translate(vaddr, 1, LOAD, 0);
<     if (auto host_addr = sim->addr_to_mem(paddr))
<       load_reservation_address = refill_tlb(vaddr, paddr, host_addr, LOAD).target_offset + vaddr;
<     else
<       throw trap_load_access_fault((proc) ? proc->state.v : false, vaddr, 0, 0); // disallow LR to I/O space
---
>     load_reservation_address = translate(vaddr, LOAD_RESERVATION_SIZE, LOAD, 0);
>     sim->sparse_reserve(load_reservation_address, LOAD_RESERVATION_SIZE);
>     refill_tlb(vaddr, load_reservation_address, 0ull /*host_addr*/, LOAD);
>     return;
285,289c366,368
<     reg_t paddr = translate(vaddr, 1, STORE, 0);
<     if (auto host_addr = sim->addr_to_mem(paddr))
<       return load_reservation_address == refill_tlb(vaddr, paddr, host_addr, STORE).target_offset + vaddr;
<     else
<       throw trap_store_access_fault((proc) ? proc->state.v : false, vaddr, 0, 0); // disallow SC to I/O space
---
>     reg_t paddr = translate(vaddr, LOAD_RESERVATION_SIZE, STORE, 0);
>     refill_tlb(vaddr, paddr, 0ull /*host_addr*/, STORE);
>     return (paddr == load_reservation_address) and (sim->sparse_is_reserved(load_reservation_address, LOAD_RESERVATION_SIZE));
302c381,390
<     insn_bits_t insn = from_le(*(uint16_t*)(tlb_entry.host_offset + addr));
---
>     uint16_t insn_buf = 0;
>     uint64_t load_buff = 0ull;
>     uint64_t muh_paddr = tlb_entry.target_offset + addr;
>     size_t len = sizeof(uint16_t);
>     load_buff = sim->sparse_read(muh_paddr, len); 
>     reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>     reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
> 
>     insn_bits_t insn = from_le(insn_buf); 
> 
306c394,398
<       insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
---
>       load_buff = sim->sparse_read(muh_paddr + 2, len); 
>       reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>       reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
>       insn_buf = from_le(insn_buf);
>       insn |= (insn_bits_t)(const int16_t)insn_buf << 16;
308a401
> 
310,311c403,413
<       insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 4)) << 32;
<       insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
---
>       load_buff = sim->sparse_read(muh_paddr + 4, len); 
>       reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>       reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
>       insn_buf = from_le(insn_buf); 
>       insn |= (insn_bits_t)(const int16_t)insn_buf << 32;
> 
>       load_buff = sim->sparse_read(muh_paddr + 2, len); 
>       reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>       reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
>       insn_buf = from_le(insn_buf); 
>       insn |= (insn_bits_t)(const uint16_t)insn_buf << 16;
314,316c416,432
<       insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 6)) << 48;
<       insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 4)) << 32;
<       insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
---
>       load_buff = sim->sparse_read(muh_paddr + 6, len); 
>       reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>       reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
>       insn_buf = from_le(insn_buf); 
>       insn |= (insn_bits_t)(const int16_t)insn_buf << 48;
> 
>       load_buff = sim->sparse_read(muh_paddr + 4, len); 
>       reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>       reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
>       insn_buf = from_le(insn_buf); 
>       insn |= (insn_bits_t)(const uint16_t)insn_buf << 32;
> 
>       load_buff = sim->sparse_read(muh_paddr + 2, len); 
>       reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
>       reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
>       insn_buf = from_le(insn_buf); 
>       insn |= (insn_bits_t)(const uint16_t)insn_buf << 16;
392a509,537
>   template<typename T> inline T to_target_from_value(T n) const
>   {
>     return target_big_endian? to_be(n) : to_le(n);
>   }
> 
>   template<typename T> inline T to_value_from_be(T n) const
>   {
>     return target_big_endian? n : from_be(n);
>   }
> 
> 
>   reg_t translate(reg_t addr, reg_t len, access_type type, uint32_t xlate_flags);
> 
>   // Translate a VA to a PA by performing a page table walk but don't set any state bits
>   // and instead of throwing exceptions, return codes are used.
>   //
>   // Does a pmp check on the recovered PA.
>   //
>   //    returns:
>   //        0 - walk was successful
>   //        1 - PMP problem with PA after address translation somehow
>   //        2 - access exception while trying to check pmp status of page table entry PA
>   //        3 - walk was unsuccessful and access type was FETCH
>   //        4 - walk was unsuccessful and access type was LOAD
>   //        5 - walk was unsuccessful and access type was STORE
>   //        6 - walk was unsuccessful and access type was not any of the above
>   //        7 - walk would have been successful had paddr_ptr not been a null pointer
>   int translate_api(reg_t addr, reg_t* paddr, uint64_t* pmp_info, reg_t len, access_type type, uint32_t xlate_flags);
> 
419a565,577
>   // perform a page table walk but don't set any state bits
>   // and instead of throwing exceptions, return codes are used:
>   //
>   //    returns:
>   //        0 - walk was successful
>   //        2 - access exception while trying to check pmp status of page table entry PA
>   //        3 - walk was unsuccessful and access type was FETCH
>   //        4 - walk was unsuccessful and access type was LOAD
>   //        5 - walk was unsuccessful and access type was STORE
>   //        6 - walk was unsuccessful and access type was not any of the above
>   //        7 - walk would have been successful had paddr_ptr not been a null pointer
>   int walk_api(reg_t addr, reg_t* paddr_ptr, access_type type, reg_t prv, bool virt, bool mxr);
> 
425a584
>   void load_slow_path_partially_initialized(reg_t addr, reg_t len, uint8_t* bytes, uint32_t xlate_flags);
427,430c586,587
<   bool mmio_load(reg_t addr, size_t len, uint8_t* bytes);
<   bool mmio_store(reg_t addr, size_t len, const uint8_t* bytes);
<   bool mmio_ok(reg_t addr, access_type type);
<   reg_t translate(reg_t addr, reg_t len, access_type type, uint32_t xlate_flags);
---
>   void initialize_slow_path(reg_t addr, reg_t len, const uint8_t* bytes, uint32_t xlate_flags);
>   //reg_t translate(reg_t addr, reg_t len, access_type type);
444,445c601,606
<       target_endian<uint16_t>* ptr = (target_endian<uint16_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr);
<       int match = proc->trigger_match(OPERATION_EXECUTE, addr, from_target(*ptr));
---
>       reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr;
> 
>       uint16_t load_buff = 0;
>       load_buff = static_cast<uint16_t>(sim->sparse_read(paddr, sizeof(uint16_t)));
> 
>       int match = proc->trigger_match(OPERATION_EXECUTE, addr, from_be(load_buff));
447c608
<         throw trigger_matched_t(match, OPERATION_EXECUTE, addr, from_target(*ptr));
---
>         throw trigger_matched_t(match, OPERATION_EXECUTE, addr, from_be(load_buff));
453,455c614,617
<   inline const uint16_t* translate_insn_addr_to_host(reg_t addr) {
<     return (uint16_t*)(translate_insn_addr(addr).host_offset + addr);
<   }
---
>   //possibly remove
>   //inline const uint16_t* translate_insn_addr_to_host(reg_t addr) {
>   //  return (uint16_t*)(translate_insn_addr(addr).host_offset + addr);
>   //}
473a636
>   reg_t pmp_ok_api(reg_t addr, reg_t* pmpaddr_ptr, uint8_t* pmpcfg_ptr, reg_t len, access_type type, reg_t mode);
