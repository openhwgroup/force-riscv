//
// Copyright (C) [2020] Futurewei Technologies, Inc.
//
// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
// FIT FOR A PARTICULAR PURPOSE.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/*  !!! NOTICE !!!
    This file is automatically generated by the script: utils/enum_classes/create_enum_files.py
    Please do not modify this file manually.  Instead, modify the above mentioned script to re-generate this file.
*/

#include <lest/lest.hpp>
#include <Log.h>

#include <Enums.h>
#include <GenException.h>

using text = std::string;
using namespace Force;

const lest::test specification[] = {


CASE( "tests for ELimitType" ) {

  SETUP ( "setup ELimitType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ELimitType_to_string(ELimitType::ThreadsLimit) == "ThreadsLimit");
      EXPECT(ELimitType_to_string(ELimitType::CoresLimit) == "CoresLimit");
      EXPECT(ELimitType_to_string(ELimitType::ChipsLimit) == "ChipsLimit");
      EXPECT(ELimitType_to_string(ELimitType::PhysicalAddressLimit) == "PhysicalAddressLimit");
      EXPECT(ELimitType_to_string(ELimitType::MaxInstructions) == "MaxInstructions");
      EXPECT(ELimitType_to_string(ELimitType::PerMonRegisterNumber) == "PerMonRegisterNumber");
      EXPECT(ELimitType_to_string(ELimitType::DependencyHistoryLimit) == "DependencyHistoryLimit");
      EXPECT(ELimitType_to_string(ELimitType::BranchNotTakenLimit) == "BranchNotTakenLimit");
      EXPECT(ELimitType_to_string(ELimitType::SpeculativeBntLevelLimit) == "SpeculativeBntLevelLimit");
      EXPECT(ELimitType_to_string(ELimitType::MaxPhysicalVectorLen) == "MaxPhysicalVectorLen");
      EXPECT(ELimitType_to_string(ELimitType::ErrRegisterNumber) == "ErrRegisterNumber");
      EXPECT(ELimitType_to_string(ELimitType::SpeculativeBntInstructionLimit) == "SpeculativeBntInstructionLimit");
      EXPECT(ELimitType_to_string(ELimitType::MaxVectorElementWidth) == "MaxVectorElementWidth");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ELimitType("ThreadsLimit") == ELimitType::ThreadsLimit);
      EXPECT(string_to_ELimitType("CoresLimit") == ELimitType::CoresLimit);
      EXPECT(string_to_ELimitType("ChipsLimit") == ELimitType::ChipsLimit);
      EXPECT(string_to_ELimitType("PhysicalAddressLimit") == ELimitType::PhysicalAddressLimit);
      EXPECT(string_to_ELimitType("MaxInstructions") == ELimitType::MaxInstructions);
      EXPECT(string_to_ELimitType("PerMonRegisterNumber") == ELimitType::PerMonRegisterNumber);
      EXPECT(string_to_ELimitType("DependencyHistoryLimit") == ELimitType::DependencyHistoryLimit);
      EXPECT(string_to_ELimitType("BranchNotTakenLimit") == ELimitType::BranchNotTakenLimit);
      EXPECT(string_to_ELimitType("SpeculativeBntLevelLimit") == ELimitType::SpeculativeBntLevelLimit);
      EXPECT(string_to_ELimitType("MaxPhysicalVectorLen") == ELimitType::MaxPhysicalVectorLen);
      EXPECT(string_to_ELimitType("ErrRegisterNumber") == ELimitType::ErrRegisterNumber);
      EXPECT(string_to_ELimitType("SpeculativeBntInstructionLimit") == ELimitType::SpeculativeBntInstructionLimit);
      EXPECT(string_to_ELimitType("MaxVectorElementWidth") == ELimitType::MaxVectorElementWidth);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ELimitType("T_readsLimit"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ELimitType("ThreadsLimit", okay) == ELimitType::ThreadsLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("CoresLimit", okay) == ELimitType::CoresLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("ChipsLimit", okay) == ELimitType::ChipsLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("PhysicalAddressLimit", okay) == ELimitType::PhysicalAddressLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("MaxInstructions", okay) == ELimitType::MaxInstructions);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("PerMonRegisterNumber", okay) == ELimitType::PerMonRegisterNumber);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("DependencyHistoryLimit", okay) == ELimitType::DependencyHistoryLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("BranchNotTakenLimit", okay) == ELimitType::BranchNotTakenLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("SpeculativeBntLevelLimit", okay) == ELimitType::SpeculativeBntLevelLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("MaxPhysicalVectorLen", okay) == ELimitType::MaxPhysicalVectorLen);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("ErrRegisterNumber", okay) == ELimitType::ErrRegisterNumber);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("SpeculativeBntInstructionLimit", okay) == ELimitType::SpeculativeBntInstructionLimit);
      EXPECT(okay);
      EXPECT(try_string_to_ELimitType("MaxVectorElementWidth", okay) == ELimitType::MaxVectorElementWidth);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ELimitType("T_readsLimit", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EOperandType" ) {

  SETUP ( "setup EOperandType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EOperandType_to_string(EOperandType::Constant) == "Constant");
      EXPECT(EOperandType_to_string(EOperandType::Immediate) == "Immediate");
      EXPECT(EOperandType_to_string(EOperandType::Choices) == "Choices");
      EXPECT(EOperandType_to_string(EOperandType::Register) == "Register");
      EXPECT(EOperandType_to_string(EOperandType::GPR) == "GPR");
      EXPECT(EOperandType_to_string(EOperandType::GPRSP) == "GPRSP");
      EXPECT(EOperandType_to_string(EOperandType::FPR) == "FPR");
      EXPECT(EOperandType_to_string(EOperandType::SIMDSR) == "SIMDSR");
      EXPECT(EOperandType_to_string(EOperandType::SIMDVR) == "SIMDVR");
      EXPECT(EOperandType_to_string(EOperandType::SysReg) == "SysReg");
      EXPECT(EOperandType_to_string(EOperandType::Branch) == "Branch");
      EXPECT(EOperandType_to_string(EOperandType::LoadStore) == "LoadStore");
      EXPECT(EOperandType_to_string(EOperandType::AuthBranch) == "AuthBranch");
      EXPECT(EOperandType_to_string(EOperandType::AuthLoadStore) == "AuthLoadStore");
      EXPECT(EOperandType_to_string(EOperandType::SystemOp) == "SystemOp");
      EXPECT(EOperandType_to_string(EOperandType::VECREG) == "VECREG");
      EXPECT(EOperandType_to_string(EOperandType::PREDREG) == "PREDREG");
      EXPECT(EOperandType_to_string(EOperandType::ALU) == "ALU");
      EXPECT(EOperandType_to_string(EOperandType::DataProcessing) == "DataProcessing");
      EXPECT(EOperandType_to_string(EOperandType::VectorLayout) == "VectorLayout");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EOperandType("Constant") == EOperandType::Constant);
      EXPECT(string_to_EOperandType("Immediate") == EOperandType::Immediate);
      EXPECT(string_to_EOperandType("Choices") == EOperandType::Choices);
      EXPECT(string_to_EOperandType("Register") == EOperandType::Register);
      EXPECT(string_to_EOperandType("GPR") == EOperandType::GPR);
      EXPECT(string_to_EOperandType("GPRSP") == EOperandType::GPRSP);
      EXPECT(string_to_EOperandType("FPR") == EOperandType::FPR);
      EXPECT(string_to_EOperandType("SIMDSR") == EOperandType::SIMDSR);
      EXPECT(string_to_EOperandType("SIMDVR") == EOperandType::SIMDVR);
      EXPECT(string_to_EOperandType("SysReg") == EOperandType::SysReg);
      EXPECT(string_to_EOperandType("Branch") == EOperandType::Branch);
      EXPECT(string_to_EOperandType("LoadStore") == EOperandType::LoadStore);
      EXPECT(string_to_EOperandType("AuthBranch") == EOperandType::AuthBranch);
      EXPECT(string_to_EOperandType("AuthLoadStore") == EOperandType::AuthLoadStore);
      EXPECT(string_to_EOperandType("SystemOp") == EOperandType::SystemOp);
      EXPECT(string_to_EOperandType("VECREG") == EOperandType::VECREG);
      EXPECT(string_to_EOperandType("PREDREG") == EOperandType::PREDREG);
      EXPECT(string_to_EOperandType("ALU") == EOperandType::ALU);
      EXPECT(string_to_EOperandType("DataProcessing") == EOperandType::DataProcessing);
      EXPECT(string_to_EOperandType("VectorLayout") == EOperandType::VectorLayout);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EOperandType("C_nstant"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EOperandType("Constant", okay) == EOperandType::Constant);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("Immediate", okay) == EOperandType::Immediate);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("Choices", okay) == EOperandType::Choices);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("Register", okay) == EOperandType::Register);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("GPR", okay) == EOperandType::GPR);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("GPRSP", okay) == EOperandType::GPRSP);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("FPR", okay) == EOperandType::FPR);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("SIMDSR", okay) == EOperandType::SIMDSR);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("SIMDVR", okay) == EOperandType::SIMDVR);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("SysReg", okay) == EOperandType::SysReg);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("Branch", okay) == EOperandType::Branch);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("LoadStore", okay) == EOperandType::LoadStore);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("AuthBranch", okay) == EOperandType::AuthBranch);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("AuthLoadStore", okay) == EOperandType::AuthLoadStore);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("SystemOp", okay) == EOperandType::SystemOp);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("VECREG", okay) == EOperandType::VECREG);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("PREDREG", okay) == EOperandType::PREDREG);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("ALU", okay) == EOperandType::ALU);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("DataProcessing", okay) == EOperandType::DataProcessing);
      EXPECT(okay);
      EXPECT(try_string_to_EOperandType("VectorLayout", okay) == EOperandType::VectorLayout);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EOperandType("C_nstant", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EMemDataType" ) {

  SETUP ( "setup EMemDataType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EMemDataType_to_string(EMemDataType::Init) == "Init");
      EXPECT(EMemDataType_to_string(EMemDataType::Instruction) == "Instruction");
      EXPECT(EMemDataType_to_string(EMemDataType::Data) == "Data");
      EXPECT(EMemDataType_to_string(EMemDataType::Both) == "Both");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EMemDataType("Init") == EMemDataType::Init);
      EXPECT(string_to_EMemDataType("Instruction") == EMemDataType::Instruction);
      EXPECT(string_to_EMemDataType("Data") == EMemDataType::Data);
      EXPECT(string_to_EMemDataType("Both") == EMemDataType::Both);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EMemDataType("I_it"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EMemDataType("Init", okay) == EMemDataType::Init);
      EXPECT(okay);
      EXPECT(try_string_to_EMemDataType("Instruction", okay) == EMemDataType::Instruction);
      EXPECT(okay);
      EXPECT(try_string_to_EMemDataType("Data", okay) == EMemDataType::Data);
      EXPECT(okay);
      EXPECT(try_string_to_EMemDataType("Both", okay) == EMemDataType::Both);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EMemDataType("I_it", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ERegAttrType" ) {

  SETUP ( "setup ERegAttrType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ERegAttrType_to_string(ERegAttrType::Read) == "Read");
      EXPECT(ERegAttrType_to_string(ERegAttrType::Write) == "Write");
      EXPECT(ERegAttrType_to_string(ERegAttrType::ReadWrite) == "ReadWrite");
      EXPECT(ERegAttrType_to_string(ERegAttrType::HasValue) == "HasValue");
      EXPECT(ERegAttrType_to_string(ERegAttrType::Unpredictable) == "Unpredictable");
      EXPECT(ERegAttrType_to_string(ERegAttrType::UpdatedFromISS) == "UpdatedFromISS");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ERegAttrType("Read") == ERegAttrType::Read);
      EXPECT(string_to_ERegAttrType("Write") == ERegAttrType::Write);
      EXPECT(string_to_ERegAttrType("ReadWrite") == ERegAttrType::ReadWrite);
      EXPECT(string_to_ERegAttrType("HasValue") == ERegAttrType::HasValue);
      EXPECT(string_to_ERegAttrType("Unpredictable") == ERegAttrType::Unpredictable);
      EXPECT(string_to_ERegAttrType("UpdatedFromISS") == ERegAttrType::UpdatedFromISS);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ERegAttrType("R_ad"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ERegAttrType("Read", okay) == ERegAttrType::Read);
      EXPECT(okay);
      EXPECT(try_string_to_ERegAttrType("Write", okay) == ERegAttrType::Write);
      EXPECT(okay);
      EXPECT(try_string_to_ERegAttrType("ReadWrite", okay) == ERegAttrType::ReadWrite);
      EXPECT(okay);
      EXPECT(try_string_to_ERegAttrType("HasValue", okay) == ERegAttrType::HasValue);
      EXPECT(okay);
      EXPECT(try_string_to_ERegAttrType("Unpredictable", okay) == ERegAttrType::Unpredictable);
      EXPECT(okay);
      EXPECT(try_string_to_ERegAttrType("UpdatedFromISS", okay) == ERegAttrType::UpdatedFromISS);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ERegAttrType("R_ad", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EMemAccessType" ) {

  SETUP ( "setup EMemAccessType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EMemAccessType_to_string(EMemAccessType::Unknown) == "Unknown");
      EXPECT(EMemAccessType_to_string(EMemAccessType::Read) == "Read");
      EXPECT(EMemAccessType_to_string(EMemAccessType::Write) == "Write");
      EXPECT(EMemAccessType_to_string(EMemAccessType::ReadWrite) == "ReadWrite");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EMemAccessType("Unknown") == EMemAccessType::Unknown);
      EXPECT(string_to_EMemAccessType("Read") == EMemAccessType::Read);
      EXPECT(string_to_EMemAccessType("Write") == EMemAccessType::Write);
      EXPECT(string_to_EMemAccessType("ReadWrite") == EMemAccessType::ReadWrite);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EMemAccessType("U_known"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EMemAccessType("Unknown", okay) == EMemAccessType::Unknown);
      EXPECT(okay);
      EXPECT(try_string_to_EMemAccessType("Read", okay) == EMemAccessType::Read);
      EXPECT(okay);
      EXPECT(try_string_to_EMemAccessType("Write", okay) == EMemAccessType::Write);
      EXPECT(okay);
      EXPECT(try_string_to_EMemAccessType("ReadWrite", okay) == EMemAccessType::ReadWrite);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EMemAccessType("U_known", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EGenAgentType" ) {

  SETUP ( "setup EGenAgentType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenInstructionAgent) == "GenInstructionAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenSequenceAgent) == "GenSequenceAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenVirtualMemoryAgent) == "GenVirtualMemoryAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenQueryAgent) == "GenQueryAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenStateAgent) == "GenStateAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenExceptionAgent) == "GenExceptionAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenCallBackAgent) == "GenCallBackAgent");
      EXPECT(EGenAgentType_to_string(EGenAgentType::GenStateTransitionAgent) == "GenStateTransitionAgent");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EGenAgentType("GenInstructionAgent") == EGenAgentType::GenInstructionAgent);
      EXPECT(string_to_EGenAgentType("GenSequenceAgent") == EGenAgentType::GenSequenceAgent);
      EXPECT(string_to_EGenAgentType("GenVirtualMemoryAgent") == EGenAgentType::GenVirtualMemoryAgent);
      EXPECT(string_to_EGenAgentType("GenQueryAgent") == EGenAgentType::GenQueryAgent);
      EXPECT(string_to_EGenAgentType("GenStateAgent") == EGenAgentType::GenStateAgent);
      EXPECT(string_to_EGenAgentType("GenExceptionAgent") == EGenAgentType::GenExceptionAgent);
      EXPECT(string_to_EGenAgentType("GenCallBackAgent") == EGenAgentType::GenCallBackAgent);
      EXPECT(string_to_EGenAgentType("GenStateTransitionAgent") == EGenAgentType::GenStateTransitionAgent);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EGenAgentType("G_nInstructionAgent"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EGenAgentType("GenInstructionAgent", okay) == EGenAgentType::GenInstructionAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenSequenceAgent", okay) == EGenAgentType::GenSequenceAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenVirtualMemoryAgent", okay) == EGenAgentType::GenVirtualMemoryAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenQueryAgent", okay) == EGenAgentType::GenQueryAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenStateAgent", okay) == EGenAgentType::GenStateAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenExceptionAgent", okay) == EGenAgentType::GenExceptionAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenCallBackAgent", okay) == EGenAgentType::GenCallBackAgent);
      EXPECT(okay);
      EXPECT(try_string_to_EGenAgentType("GenStateTransitionAgent", okay) == EGenAgentType::GenStateTransitionAgent);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EGenAgentType("G_nInstructionAgent", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EChoicesType" ) {

  SETUP ( "setup EChoicesType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EChoicesType_to_string(EChoicesType::OperandChoices) == "OperandChoices");
      EXPECT(EChoicesType_to_string(EChoicesType::RegisterFieldValueChoices) == "RegisterFieldValueChoices");
      EXPECT(EChoicesType_to_string(EChoicesType::PagingChoices) == "PagingChoices");
      EXPECT(EChoicesType_to_string(EChoicesType::GeneralChoices) == "GeneralChoices");
      EXPECT(EChoicesType_to_string(EChoicesType::DependenceChoices) == "DependenceChoices");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EChoicesType("OperandChoices") == EChoicesType::OperandChoices);
      EXPECT(string_to_EChoicesType("RegisterFieldValueChoices") == EChoicesType::RegisterFieldValueChoices);
      EXPECT(string_to_EChoicesType("PagingChoices") == EChoicesType::PagingChoices);
      EXPECT(string_to_EChoicesType("GeneralChoices") == EChoicesType::GeneralChoices);
      EXPECT(string_to_EChoicesType("DependenceChoices") == EChoicesType::DependenceChoices);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EChoicesType("O_erandChoices"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EChoicesType("OperandChoices", okay) == EChoicesType::OperandChoices);
      EXPECT(okay);
      EXPECT(try_string_to_EChoicesType("RegisterFieldValueChoices", okay) == EChoicesType::RegisterFieldValueChoices);
      EXPECT(okay);
      EXPECT(try_string_to_EChoicesType("PagingChoices", okay) == EChoicesType::PagingChoices);
      EXPECT(okay);
      EXPECT(try_string_to_EChoicesType("GeneralChoices", okay) == EChoicesType::GeneralChoices);
      EXPECT(okay);
      EXPECT(try_string_to_EChoicesType("DependenceChoices", okay) == EChoicesType::DependenceChoices);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EChoicesType("O_erandChoices", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ERegisterType" ) {

  SETUP ( "setup ERegisterType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ERegisterType_to_string(ERegisterType::GPR) == "GPR");
      EXPECT(ERegisterType_to_string(ERegisterType::FPR) == "FPR");
      EXPECT(ERegisterType_to_string(ERegisterType::SIMDR) == "SIMDR");
      EXPECT(ERegisterType_to_string(ERegisterType::SIMDVR) == "SIMDVR");
      EXPECT(ERegisterType_to_string(ERegisterType::VECREG) == "VECREG");
      EXPECT(ERegisterType_to_string(ERegisterType::PREDREG) == "PREDREG");
      EXPECT(ERegisterType_to_string(ERegisterType::SysReg) == "SysReg");
      EXPECT(ERegisterType_to_string(ERegisterType::SP) == "SP");
      EXPECT(ERegisterType_to_string(ERegisterType::ZR) == "ZR");
      EXPECT(ERegisterType_to_string(ERegisterType::PC) == "PC");
      EXPECT(ERegisterType_to_string(ERegisterType::Internal) == "Internal");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ERegisterType("GPR") == ERegisterType::GPR);
      EXPECT(string_to_ERegisterType("FPR") == ERegisterType::FPR);
      EXPECT(string_to_ERegisterType("SIMDR") == ERegisterType::SIMDR);
      EXPECT(string_to_ERegisterType("SIMDVR") == ERegisterType::SIMDVR);
      EXPECT(string_to_ERegisterType("VECREG") == ERegisterType::VECREG);
      EXPECT(string_to_ERegisterType("PREDREG") == ERegisterType::PREDREG);
      EXPECT(string_to_ERegisterType("SysReg") == ERegisterType::SysReg);
      EXPECT(string_to_ERegisterType("SP") == ERegisterType::SP);
      EXPECT(string_to_ERegisterType("ZR") == ERegisterType::ZR);
      EXPECT(string_to_ERegisterType("PC") == ERegisterType::PC);
      EXPECT(string_to_ERegisterType("Internal") == ERegisterType::Internal);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ERegisterType("G_R"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ERegisterType("GPR", okay) == ERegisterType::GPR);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("FPR", okay) == ERegisterType::FPR);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("SIMDR", okay) == ERegisterType::SIMDR);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("SIMDVR", okay) == ERegisterType::SIMDVR);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("VECREG", okay) == ERegisterType::VECREG);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("PREDREG", okay) == ERegisterType::PREDREG);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("SysReg", okay) == ERegisterType::SysReg);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("SP", okay) == ERegisterType::SP);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("ZR", okay) == ERegisterType::ZR);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("PC", okay) == ERegisterType::PC);
      EXPECT(okay);
      EXPECT(try_string_to_ERegisterType("Internal", okay) == ERegisterType::Internal);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ERegisterType("G_R", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EConstraintType" ) {

  SETUP ( "setup EConstraintType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EConstraintType_to_string(EConstraintType::Value) == "Value");
      EXPECT(EConstraintType_to_string(EConstraintType::Range) == "Range");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EConstraintType("Value") == EConstraintType::Value);
      EXPECT(string_to_EConstraintType("Range") == EConstraintType::Range);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EConstraintType("V_lue"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EConstraintType("Value", okay) == EConstraintType::Value);
      EXPECT(okay);
      EXPECT(try_string_to_EConstraintType("Range", okay) == EConstraintType::Range);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EConstraintType("V_lue", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EConstraintResultType" ) {

  SETUP ( "setup EConstraintResultType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EConstraintResultType_to_string(EConstraintResultType::Consumed) == "Consumed");
      EXPECT(EConstraintResultType_to_string(EConstraintResultType::Replace) == "Replace");
      EXPECT(EConstraintResultType_to_string(EConstraintResultType::Remove) == "Remove");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EConstraintResultType("Consumed") == EConstraintResultType::Consumed);
      EXPECT(string_to_EConstraintResultType("Replace") == EConstraintResultType::Replace);
      EXPECT(string_to_EConstraintResultType("Remove") == EConstraintResultType::Remove);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EConstraintResultType("C_nsumed"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EConstraintResultType("Consumed", okay) == EConstraintResultType::Consumed);
      EXPECT(okay);
      EXPECT(try_string_to_EConstraintResultType("Replace", okay) == EConstraintResultType::Replace);
      EXPECT(okay);
      EXPECT(try_string_to_EConstraintResultType("Remove", okay) == EConstraintResultType::Remove);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EConstraintResultType("C_nsumed", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EConstraintMoveDirection" ) {

  SETUP ( "setup EConstraintMoveDirection" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EConstraintMoveDirection_to_string(EConstraintMoveDirection::Shrink) == "Shrink");
      EXPECT(EConstraintMoveDirection_to_string(EConstraintMoveDirection::Expand) == "Expand");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EConstraintMoveDirection("Shrink") == EConstraintMoveDirection::Shrink);
      EXPECT(string_to_EConstraintMoveDirection("Expand") == EConstraintMoveDirection::Expand);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EConstraintMoveDirection("S_rink"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EConstraintMoveDirection("Shrink", okay) == EConstraintMoveDirection::Shrink);
      EXPECT(okay);
      EXPECT(try_string_to_EConstraintMoveDirection("Expand", okay) == EConstraintMoveDirection::Expand);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EConstraintMoveDirection("S_rink", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ETranslationResultType" ) {

  SETUP ( "setup ETranslationResultType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ETranslationResultType_to_string(ETranslationResultType::NotMapped) == "NotMapped");
      EXPECT(ETranslationResultType_to_string(ETranslationResultType::Mapped) == "Mapped");
      EXPECT(ETranslationResultType_to_string(ETranslationResultType::AddressError) == "AddressError");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ETranslationResultType("NotMapped") == ETranslationResultType::NotMapped);
      EXPECT(string_to_ETranslationResultType("Mapped") == ETranslationResultType::Mapped);
      EXPECT(string_to_ETranslationResultType("AddressError") == ETranslationResultType::AddressError);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ETranslationResultType("N_tMapped"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ETranslationResultType("NotMapped", okay) == ETranslationResultType::NotMapped);
      EXPECT(okay);
      EXPECT(try_string_to_ETranslationResultType("Mapped", okay) == ETranslationResultType::Mapped);
      EXPECT(okay);
      EXPECT(try_string_to_ETranslationResultType("AddressError", okay) == ETranslationResultType::AddressError);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ETranslationResultType("N_tMapped", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EVmStateType" ) {

  SETUP ( "setup EVmStateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EVmStateType_to_string(EVmStateType::Uninitialized) == "Uninitialized");
      EXPECT(EVmStateType_to_string(EVmStateType::Invalid) == "Invalid");
      EXPECT(EVmStateType_to_string(EVmStateType::Initialized) == "Initialized");
      EXPECT(EVmStateType_to_string(EVmStateType::Active) == "Active");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EVmStateType("Uninitialized") == EVmStateType::Uninitialized);
      EXPECT(string_to_EVmStateType("Invalid") == EVmStateType::Invalid);
      EXPECT(string_to_EVmStateType("Initialized") == EVmStateType::Initialized);
      EXPECT(string_to_EVmStateType("Active") == EVmStateType::Active);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EVmStateType("U_initialized"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EVmStateType("Uninitialized", okay) == EVmStateType::Uninitialized);
      EXPECT(okay);
      EXPECT(try_string_to_EVmStateType("Invalid", okay) == EVmStateType::Invalid);
      EXPECT(okay);
      EXPECT(try_string_to_EVmStateType("Initialized", okay) == EVmStateType::Initialized);
      EXPECT(okay);
      EXPECT(try_string_to_EVmStateType("Active", okay) == EVmStateType::Active);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EVmStateType("U_initialized", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EVmStateBits" ) {

  SETUP ( "setup EVmStateBits" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EVmStateBits_to_string(EVmStateBits::ActiveMask) == "ActiveMask");
      EXPECT(EVmStateBits_to_string(EVmStateBits::InitMask) == "InitMask");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EVmStateBits("ActiveMask") == EVmStateBits::ActiveMask);
      EXPECT(string_to_EVmStateBits("InitMask") == EVmStateBits::InitMask);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EVmStateBits("A_tiveMask"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EVmStateBits("ActiveMask", okay) == EVmStateBits::ActiveMask);
      EXPECT(okay);
      EXPECT(try_string_to_EVmStateBits("InitMask", okay) == EVmStateBits::InitMask);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EVmStateBits("A_tiveMask", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EAddrModeStateType" ) {

  SETUP ( "setup EAddrModeStateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EAddrModeStateType_to_string(EAddrModeStateType::Free) == "Free");
      EXPECT(EAddrModeStateType_to_string(EAddrModeStateType::Mapped) == "Mapped");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EAddrModeStateType("Free") == EAddrModeStateType::Free);
      EXPECT(string_to_EAddrModeStateType("Mapped") == EAddrModeStateType::Mapped);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EAddrModeStateType("F_ee"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EAddrModeStateType("Free", okay) == EAddrModeStateType::Free);
      EXPECT(okay);
      EXPECT(try_string_to_EAddrModeStateType("Mapped", okay) == EAddrModeStateType::Mapped);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EAddrModeStateType("F_ee", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ESequenceType" ) {

  SETUP ( "setup ESequenceType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ESequenceType_to_string(ESequenceType::BootLoading) == "BootLoading");
      EXPECT(ESequenceType_to_string(ESequenceType::EndOfTest) == "EndOfTest");
      EXPECT(ESequenceType_to_string(ESequenceType::Summary) == "Summary");
      EXPECT(ESequenceType_to_string(ESequenceType::LoadRegister) == "LoadRegister");
      EXPECT(ESequenceType_to_string(ESequenceType::CommitInstruction) == "CommitInstruction");
      EXPECT(ESequenceType_to_string(ESequenceType::JumpToStart) == "JumpToStart");
      EXPECT(ESequenceType_to_string(ESequenceType::BranchToTarget) == "BranchToTarget");
      EXPECT(ESequenceType_to_string(ESequenceType::InitialSetup) == "InitialSetup");
      EXPECT(ESequenceType_to_string(ESequenceType::RegisterReservation) == "RegisterReservation");
      EXPECT(ESequenceType_to_string(ESequenceType::EscapeCollision) == "EscapeCollision");
      EXPECT(ESequenceType_to_string(ESequenceType::BranchNotTaken) == "BranchNotTaken");
      EXPECT(ESequenceType_to_string(ESequenceType::BntNode) == "BntNode");
      EXPECT(ESequenceType_to_string(ESequenceType::ReExecution) == "ReExecution");
      EXPECT(ESequenceType_to_string(ESequenceType::UpdatePeState) == "UpdatePeState");
      EXPECT(ESequenceType_to_string(ESequenceType::UpdateRegisterField) == "UpdateRegisterField");
      EXPECT(ESequenceType_to_string(ESequenceType::SetRegister) == "SetRegister");
      EXPECT(ESequenceType_to_string(ESequenceType::ConfirmSpace) == "ConfirmSpace");
      EXPECT(ESequenceType_to_string(ESequenceType::ReloadRegister) == "ReloadRegister");
      EXPECT(ESequenceType_to_string(ESequenceType::BatchReloadRegisters) == "BatchReloadRegisters");
      EXPECT(ESequenceType_to_string(ESequenceType::SpeculativeBntNode) == "SpeculativeBntNode");
      EXPECT(ESequenceType_to_string(ESequenceType::ThreadSummary) == "ThreadSummary");
      EXPECT(ESequenceType_to_string(ESequenceType::InitializeAddrTables) == "InitializeAddrTables");
      EXPECT(ESequenceType_to_string(ESequenceType::LoadLargeRegister) == "LoadLargeRegister");
      EXPECT(ESequenceType_to_string(ESequenceType::BeginRestoreLoop) == "BeginRestoreLoop");
      EXPECT(ESequenceType_to_string(ESequenceType::EndRestoreLoop) == "EndRestoreLoop");
      EXPECT(ESequenceType_to_string(ESequenceType::RestoreLoopState) == "RestoreLoopState");
      EXPECT(ESequenceType_to_string(ESequenceType::LoopReconverge) == "LoopReconverge");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ESequenceType("BootLoading") == ESequenceType::BootLoading);
      EXPECT(string_to_ESequenceType("EndOfTest") == ESequenceType::EndOfTest);
      EXPECT(string_to_ESequenceType("Summary") == ESequenceType::Summary);
      EXPECT(string_to_ESequenceType("LoadRegister") == ESequenceType::LoadRegister);
      EXPECT(string_to_ESequenceType("CommitInstruction") == ESequenceType::CommitInstruction);
      EXPECT(string_to_ESequenceType("JumpToStart") == ESequenceType::JumpToStart);
      EXPECT(string_to_ESequenceType("BranchToTarget") == ESequenceType::BranchToTarget);
      EXPECT(string_to_ESequenceType("InitialSetup") == ESequenceType::InitialSetup);
      EXPECT(string_to_ESequenceType("RegisterReservation") == ESequenceType::RegisterReservation);
      EXPECT(string_to_ESequenceType("EscapeCollision") == ESequenceType::EscapeCollision);
      EXPECT(string_to_ESequenceType("BranchNotTaken") == ESequenceType::BranchNotTaken);
      EXPECT(string_to_ESequenceType("BntNode") == ESequenceType::BntNode);
      EXPECT(string_to_ESequenceType("ReExecution") == ESequenceType::ReExecution);
      EXPECT(string_to_ESequenceType("UpdatePeState") == ESequenceType::UpdatePeState);
      EXPECT(string_to_ESequenceType("UpdateRegisterField") == ESequenceType::UpdateRegisterField);
      EXPECT(string_to_ESequenceType("SetRegister") == ESequenceType::SetRegister);
      EXPECT(string_to_ESequenceType("ConfirmSpace") == ESequenceType::ConfirmSpace);
      EXPECT(string_to_ESequenceType("ReloadRegister") == ESequenceType::ReloadRegister);
      EXPECT(string_to_ESequenceType("BatchReloadRegisters") == ESequenceType::BatchReloadRegisters);
      EXPECT(string_to_ESequenceType("SpeculativeBntNode") == ESequenceType::SpeculativeBntNode);
      EXPECT(string_to_ESequenceType("ThreadSummary") == ESequenceType::ThreadSummary);
      EXPECT(string_to_ESequenceType("InitializeAddrTables") == ESequenceType::InitializeAddrTables);
      EXPECT(string_to_ESequenceType("LoadLargeRegister") == ESequenceType::LoadLargeRegister);
      EXPECT(string_to_ESequenceType("BeginRestoreLoop") == ESequenceType::BeginRestoreLoop);
      EXPECT(string_to_ESequenceType("EndRestoreLoop") == ESequenceType::EndRestoreLoop);
      EXPECT(string_to_ESequenceType("RestoreLoopState") == ESequenceType::RestoreLoopState);
      EXPECT(string_to_ESequenceType("LoopReconverge") == ESequenceType::LoopReconverge);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ESequenceType("B_otLoading"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ESequenceType("BootLoading", okay) == ESequenceType::BootLoading);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("EndOfTest", okay) == ESequenceType::EndOfTest);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("Summary", okay) == ESequenceType::Summary);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("LoadRegister", okay) == ESequenceType::LoadRegister);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("CommitInstruction", okay) == ESequenceType::CommitInstruction);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("JumpToStart", okay) == ESequenceType::JumpToStart);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("BranchToTarget", okay) == ESequenceType::BranchToTarget);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("InitialSetup", okay) == ESequenceType::InitialSetup);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("RegisterReservation", okay) == ESequenceType::RegisterReservation);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("EscapeCollision", okay) == ESequenceType::EscapeCollision);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("BranchNotTaken", okay) == ESequenceType::BranchNotTaken);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("BntNode", okay) == ESequenceType::BntNode);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("ReExecution", okay) == ESequenceType::ReExecution);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("UpdatePeState", okay) == ESequenceType::UpdatePeState);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("UpdateRegisterField", okay) == ESequenceType::UpdateRegisterField);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("SetRegister", okay) == ESequenceType::SetRegister);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("ConfirmSpace", okay) == ESequenceType::ConfirmSpace);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("ReloadRegister", okay) == ESequenceType::ReloadRegister);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("BatchReloadRegisters", okay) == ESequenceType::BatchReloadRegisters);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("SpeculativeBntNode", okay) == ESequenceType::SpeculativeBntNode);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("ThreadSummary", okay) == ESequenceType::ThreadSummary);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("InitializeAddrTables", okay) == ESequenceType::InitializeAddrTables);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("LoadLargeRegister", okay) == ESequenceType::LoadLargeRegister);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("BeginRestoreLoop", okay) == ESequenceType::BeginRestoreLoop);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("EndRestoreLoop", okay) == ESequenceType::EndRestoreLoop);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("RestoreLoopState", okay) == ESequenceType::RestoreLoopState);
      EXPECT(okay);
      EXPECT(try_string_to_ESequenceType("LoopReconverge", okay) == ESequenceType::LoopReconverge);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ESequenceType("B_otLoading", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ECallBackType" ) {

  SETUP ( "setup ECallBackType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ECallBackType_to_string(ECallBackType::Bnt) == "Bnt");
      EXPECT(ECallBackType_to_string(ECallBackType::Eret) == "Eret");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ECallBackType("Bnt") == ECallBackType::Bnt);
      EXPECT(string_to_ECallBackType("Eret") == ECallBackType::Eret);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ECallBackType("B_t"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ECallBackType("Bnt", okay) == ECallBackType::Bnt);
      EXPECT(okay);
      EXPECT(try_string_to_ECallBackType("Eret", okay) == ECallBackType::Eret);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ECallBackType("B_t", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EExtendType" ) {

  SETUP ( "setup EExtendType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EExtendType_to_string(EExtendType::UXTW) == "UXTW");
      EXPECT(EExtendType_to_string(EExtendType::LSL) == "LSL");
      EXPECT(EExtendType_to_string(EExtendType::SXTW) == "SXTW");
      EXPECT(EExtendType_to_string(EExtendType::SXTX) == "SXTX");
      EXPECT(EExtendType_to_string(EExtendType::UXTX) == "UXTX");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EExtendType("UXTW") == EExtendType::UXTW);
      EXPECT(string_to_EExtendType("LSL") == EExtendType::LSL);
      EXPECT(string_to_EExtendType("SXTW") == EExtendType::SXTW);
      EXPECT(string_to_EExtendType("SXTX") == EExtendType::SXTX);
      EXPECT(string_to_EExtendType("UXTX") == EExtendType::UXTX);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EExtendType("U_TW"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EExtendType("UXTW", okay) == EExtendType::UXTW);
      EXPECT(okay);
      EXPECT(try_string_to_EExtendType("LSL", okay) == EExtendType::LSL);
      EXPECT(okay);
      EXPECT(try_string_to_EExtendType("SXTW", okay) == EExtendType::SXTW);
      EXPECT(okay);
      EXPECT(try_string_to_EExtendType("SXTX", okay) == EExtendType::SXTX);
      EXPECT(okay);
      EXPECT(try_string_to_EExtendType("UXTX", okay) == EExtendType::UXTX);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EExtendType("U_TW", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EVmRequestType" ) {

  SETUP ( "setup EVmRequestType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenPA) == "GenPA");
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenVA) == "GenVA");
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenVAforPA) == "GenVAforPA");
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenPage) == "GenPage");
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenFreePage) == "GenFreePage");
      EXPECT(EVmRequestType_to_string(EVmRequestType::PhysicalRegion) == "PhysicalRegion");
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenVMVA) == "GenVMVA");
      EXPECT(EVmRequestType_to_string(EVmRequestType::GenVmContext) == "GenVmContext");
      EXPECT(EVmRequestType_to_string(EVmRequestType::UpdateVm) == "UpdateVm");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EVmRequestType("GenPA") == EVmRequestType::GenPA);
      EXPECT(string_to_EVmRequestType("GenVA") == EVmRequestType::GenVA);
      EXPECT(string_to_EVmRequestType("GenVAforPA") == EVmRequestType::GenVAforPA);
      EXPECT(string_to_EVmRequestType("GenPage") == EVmRequestType::GenPage);
      EXPECT(string_to_EVmRequestType("GenFreePage") == EVmRequestType::GenFreePage);
      EXPECT(string_to_EVmRequestType("PhysicalRegion") == EVmRequestType::PhysicalRegion);
      EXPECT(string_to_EVmRequestType("GenVMVA") == EVmRequestType::GenVMVA);
      EXPECT(string_to_EVmRequestType("GenVmContext") == EVmRequestType::GenVmContext);
      EXPECT(string_to_EVmRequestType("UpdateVm") == EVmRequestType::UpdateVm);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EVmRequestType("G_nPA"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EVmRequestType("GenPA", okay) == EVmRequestType::GenPA);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("GenVA", okay) == EVmRequestType::GenVA);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("GenVAforPA", okay) == EVmRequestType::GenVAforPA);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("GenPage", okay) == EVmRequestType::GenPage);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("GenFreePage", okay) == EVmRequestType::GenFreePage);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("PhysicalRegion", okay) == EVmRequestType::PhysicalRegion);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("GenVMVA", okay) == EVmRequestType::GenVMVA);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("GenVmContext", okay) == EVmRequestType::GenVmContext);
      EXPECT(okay);
      EXPECT(try_string_to_EVmRequestType("UpdateVm", okay) == EVmRequestType::UpdateVm);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EVmRequestType("G_nPA", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EInstrBoolAttrType" ) {

  SETUP ( "setup EInstrBoolAttrType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::NoSkip) == "NoSkip");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::NoRestriction) == "NoRestriction");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::UnalignedPC) == "UnalignedPC");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::AlignedData) == "AlignedData");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::AlignedSP) == "AlignedSP");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::NoBnt) == "NoBnt");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::NoPreamble) == "NoPreamble");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::SpeculativeBnt) == "SpeculativeBnt");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::NoDataAbort) == "NoDataAbort");
      EXPECT(EInstrBoolAttrType_to_string(EInstrBoolAttrType::SharedTarget) == "SharedTarget");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EInstrBoolAttrType("NoSkip") == EInstrBoolAttrType::NoSkip);
      EXPECT(string_to_EInstrBoolAttrType("NoRestriction") == EInstrBoolAttrType::NoRestriction);
      EXPECT(string_to_EInstrBoolAttrType("UnalignedPC") == EInstrBoolAttrType::UnalignedPC);
      EXPECT(string_to_EInstrBoolAttrType("AlignedData") == EInstrBoolAttrType::AlignedData);
      EXPECT(string_to_EInstrBoolAttrType("AlignedSP") == EInstrBoolAttrType::AlignedSP);
      EXPECT(string_to_EInstrBoolAttrType("NoBnt") == EInstrBoolAttrType::NoBnt);
      EXPECT(string_to_EInstrBoolAttrType("NoPreamble") == EInstrBoolAttrType::NoPreamble);
      EXPECT(string_to_EInstrBoolAttrType("SpeculativeBnt") == EInstrBoolAttrType::SpeculativeBnt);
      EXPECT(string_to_EInstrBoolAttrType("NoDataAbort") == EInstrBoolAttrType::NoDataAbort);
      EXPECT(string_to_EInstrBoolAttrType("SharedTarget") == EInstrBoolAttrType::SharedTarget);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EInstrBoolAttrType("N_Skip"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EInstrBoolAttrType("NoSkip", okay) == EInstrBoolAttrType::NoSkip);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("NoRestriction", okay) == EInstrBoolAttrType::NoRestriction);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("UnalignedPC", okay) == EInstrBoolAttrType::UnalignedPC);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("AlignedData", okay) == EInstrBoolAttrType::AlignedData);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("AlignedSP", okay) == EInstrBoolAttrType::AlignedSP);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("NoBnt", okay) == EInstrBoolAttrType::NoBnt);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("NoPreamble", okay) == EInstrBoolAttrType::NoPreamble);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("SpeculativeBnt", okay) == EInstrBoolAttrType::SpeculativeBnt);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("NoDataAbort", okay) == EInstrBoolAttrType::NoDataAbort);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrBoolAttrType("SharedTarget", okay) == EInstrBoolAttrType::SharedTarget);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EInstrBoolAttrType("N_Skip", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EInstrConstraintAttrType" ) {

  SETUP ( "setup EInstrConstraintAttrType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EInstrConstraintAttrType_to_string(EInstrConstraintAttrType::LSTarget) == "LSTarget");
      EXPECT(EInstrConstraintAttrType_to_string(EInstrConstraintAttrType::BRTarget) == "BRTarget");
      EXPECT(EInstrConstraintAttrType_to_string(EInstrConstraintAttrType::CondTaken) == "CondTaken");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EInstrConstraintAttrType("LSTarget") == EInstrConstraintAttrType::LSTarget);
      EXPECT(string_to_EInstrConstraintAttrType("BRTarget") == EInstrConstraintAttrType::BRTarget);
      EXPECT(string_to_EInstrConstraintAttrType("CondTaken") == EInstrConstraintAttrType::CondTaken);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EInstrConstraintAttrType("L_Target"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EInstrConstraintAttrType("LSTarget", okay) == EInstrConstraintAttrType::LSTarget);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrConstraintAttrType("BRTarget", okay) == EInstrConstraintAttrType::BRTarget);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrConstraintAttrType("CondTaken", okay) == EInstrConstraintAttrType::CondTaken);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EInstrConstraintAttrType("L_Target", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EBntAttributeType" ) {

  SETUP ( "setup EBntAttributeType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EBntAttributeType_to_string(EBntAttributeType::Taken) == "Taken");
      EXPECT(EBntAttributeType_to_string(EBntAttributeType::Conditional) == "Conditional");
      EXPECT(EBntAttributeType_to_string(EBntAttributeType::Accurate) == "Accurate");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EBntAttributeType("Taken") == EBntAttributeType::Taken);
      EXPECT(string_to_EBntAttributeType("Conditional") == EBntAttributeType::Conditional);
      EXPECT(string_to_EBntAttributeType("Accurate") == EBntAttributeType::Accurate);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EBntAttributeType("T_ken"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EBntAttributeType("Taken", okay) == EBntAttributeType::Taken);
      EXPECT(okay);
      EXPECT(try_string_to_EBntAttributeType("Conditional", okay) == EBntAttributeType::Conditional);
      EXPECT(okay);
      EXPECT(try_string_to_EBntAttributeType("Accurate", okay) == EBntAttributeType::Accurate);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EBntAttributeType("T_ken", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EAluOperationType" ) {

  SETUP ( "setup EAluOperationType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EAluOperationType_to_string(EAluOperationType::Unknown) == "Unknown");
      EXPECT(EAluOperationType_to_string(EAluOperationType::ADD) == "ADD");
      EXPECT(EAluOperationType_to_string(EAluOperationType::SUB) == "SUB");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EAluOperationType("Unknown") == EAluOperationType::Unknown);
      EXPECT(string_to_EAluOperationType("ADD") == EAluOperationType::ADD);
      EXPECT(string_to_EAluOperationType("SUB") == EAluOperationType::SUB);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EAluOperationType("U_known"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EAluOperationType("Unknown", okay) == EAluOperationType::Unknown);
      EXPECT(okay);
      EXPECT(try_string_to_EAluOperationType("ADD", okay) == EAluOperationType::ADD);
      EXPECT(okay);
      EXPECT(try_string_to_EAluOperationType("SUB", okay) == EAluOperationType::SUB);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EAluOperationType("U_known", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EDataProcessingOperationType" ) {

  SETUP ( "setup EDataProcessingOperationType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::Unknown) == "Unknown");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MulAdd) == "MulAdd");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::Mul) == "Mul");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::UDiv) == "UDiv");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SDiv) == "SDiv");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddWithCarry) == "AddWithCarry");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubWithCarry) == "SubWithCarry");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndShift32) == "AndShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndShift64) == "AndShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::BicClearShift32) == "BicClearShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::BicClearShift64) == "BicClearShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::EonExcOrNotShift32) == "EonExcOrNotShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::EonExcOrNotShift64) == "EonExcOrNotShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::EorExcOrShift32) == "EorExcOrShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::EorExcOrShift64) == "EorExcOrShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::OrrIncOrShift32) == "OrrIncOrShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::OrrIncOrShift64) == "OrrIncOrShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MvnNotShift32) == "MvnNotShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MvnNotShift64) == "MvnNotShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::OrnIncOrNotShift32) == "OrnIncOrNotShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::OrnIncOrNotShift64) == "OrnIncOrNotShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MsubMulSub32) == "MsubMulSub32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MsubMulSub64) == "MsubMulSub64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MnegMulNot32) == "MnegMulNot32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::MnegMulNot64) == "MnegMulNot64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SmaddlSigMulAddLong) == "SmaddlSigMulAddLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SmsublSigMulSubLong) == "SmsublSigMulSubLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SmneglSigMulNotLong) == "SmneglSigMulNotLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SmullSigMulLong) == "SmullSigMulLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SmulhSigMulHigh) == "SmulhSigMulHigh");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::UmaddlMulAddLong) == "UmaddlMulAddLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::UmsublMulSubLong) == "UmsublMulSubLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::UmneglMulNotLong) == "UmneglMulNotLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::UmullMulLong) == "UmullMulLong");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::UmulhMulHigh) == "UmulhMulHigh");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndImm32) == "AndImm32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndImm64) == "AndImm64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::EorExcOrImm32) == "EorExcOrImm32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::EorExcOrImm64) == "EorExcOrImm64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::OrrIncOrImm32) == "OrrIncOrImm32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::OrrIncOrImm64) == "OrrIncOrImm64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddExt32) == "AddExt32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddExt64) == "AddExt64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddShift32) == "AddShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddShift64) == "AddShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubExt32) == "SubExt32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubExt64) == "SubExt64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubShift32) == "SubShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubShift64) == "SubShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddsAddSetFlagsExt32) == "AddsAddSetFlagsExt32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddsAddSetFlagsExt64) == "AddsAddSetFlagsExt64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddsAddSetFlagsShift32) == "AddsAddSetFlagsShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AddsAddSetFlagsShift64) == "AddsAddSetFlagsShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubsSubSetFlagsExt32) == "SubsSubSetFlagsExt32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubsSubSetFlagsExt64) == "SubsSubSetFlagsExt64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubsSubSetFlagsShift32) == "SubsSubSetFlagsShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::SubsSubSetFlagsShift64) == "SubsSubSetFlagsShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NegNegateShift32) == "NegNegateShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NegNegateShift64) == "NegNegateShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NegsNegateSetFlagsShift32) == "NegsNegateSetFlagsShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NegsNegateSetFlagsShift64) == "NegsNegateSetFlagsShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NgcNegateWithCarry32) == "NgcNegateWithCarry32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NgcNegateWithCarry64) == "NgcNegateWithCarry64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NgcsNegateWithCarrySetFlags32) == "NgcsNegateWithCarrySetFlags32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::NgcsNegateWithCarrySetFlags64) == "NgcsNegateWithCarrySetFlags64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndsAndSetFlagsShift32) == "AndsAndSetFlagsShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndsAndSetFlagsShift64) == "AndsAndSetFlagsShift64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndsAndSetFlagsImm32) == "AndsAndSetFlagsImm32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::AndsAndSetFlagsImm64) == "AndsAndSetFlagsImm64");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::BicsClearSetFlagsShift32) == "BicsClearSetFlagsShift32");
      EXPECT(EDataProcessingOperationType_to_string(EDataProcessingOperationType::BicsClearSetFlagsShift64) == "BicsClearSetFlagsShift64");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EDataProcessingOperationType("Unknown") == EDataProcessingOperationType::Unknown);
      EXPECT(string_to_EDataProcessingOperationType("MulAdd") == EDataProcessingOperationType::MulAdd);
      EXPECT(string_to_EDataProcessingOperationType("Mul") == EDataProcessingOperationType::Mul);
      EXPECT(string_to_EDataProcessingOperationType("UDiv") == EDataProcessingOperationType::UDiv);
      EXPECT(string_to_EDataProcessingOperationType("SDiv") == EDataProcessingOperationType::SDiv);
      EXPECT(string_to_EDataProcessingOperationType("AddWithCarry") == EDataProcessingOperationType::AddWithCarry);
      EXPECT(string_to_EDataProcessingOperationType("SubWithCarry") == EDataProcessingOperationType::SubWithCarry);
      EXPECT(string_to_EDataProcessingOperationType("AndShift32") == EDataProcessingOperationType::AndShift32);
      EXPECT(string_to_EDataProcessingOperationType("AndShift64") == EDataProcessingOperationType::AndShift64);
      EXPECT(string_to_EDataProcessingOperationType("BicClearShift32") == EDataProcessingOperationType::BicClearShift32);
      EXPECT(string_to_EDataProcessingOperationType("BicClearShift64") == EDataProcessingOperationType::BicClearShift64);
      EXPECT(string_to_EDataProcessingOperationType("EonExcOrNotShift32") == EDataProcessingOperationType::EonExcOrNotShift32);
      EXPECT(string_to_EDataProcessingOperationType("EonExcOrNotShift64") == EDataProcessingOperationType::EonExcOrNotShift64);
      EXPECT(string_to_EDataProcessingOperationType("EorExcOrShift32") == EDataProcessingOperationType::EorExcOrShift32);
      EXPECT(string_to_EDataProcessingOperationType("EorExcOrShift64") == EDataProcessingOperationType::EorExcOrShift64);
      EXPECT(string_to_EDataProcessingOperationType("OrrIncOrShift32") == EDataProcessingOperationType::OrrIncOrShift32);
      EXPECT(string_to_EDataProcessingOperationType("OrrIncOrShift64") == EDataProcessingOperationType::OrrIncOrShift64);
      EXPECT(string_to_EDataProcessingOperationType("MvnNotShift32") == EDataProcessingOperationType::MvnNotShift32);
      EXPECT(string_to_EDataProcessingOperationType("MvnNotShift64") == EDataProcessingOperationType::MvnNotShift64);
      EXPECT(string_to_EDataProcessingOperationType("OrnIncOrNotShift32") == EDataProcessingOperationType::OrnIncOrNotShift32);
      EXPECT(string_to_EDataProcessingOperationType("OrnIncOrNotShift64") == EDataProcessingOperationType::OrnIncOrNotShift64);
      EXPECT(string_to_EDataProcessingOperationType("MsubMulSub32") == EDataProcessingOperationType::MsubMulSub32);
      EXPECT(string_to_EDataProcessingOperationType("MsubMulSub64") == EDataProcessingOperationType::MsubMulSub64);
      EXPECT(string_to_EDataProcessingOperationType("MnegMulNot32") == EDataProcessingOperationType::MnegMulNot32);
      EXPECT(string_to_EDataProcessingOperationType("MnegMulNot64") == EDataProcessingOperationType::MnegMulNot64);
      EXPECT(string_to_EDataProcessingOperationType("SmaddlSigMulAddLong") == EDataProcessingOperationType::SmaddlSigMulAddLong);
      EXPECT(string_to_EDataProcessingOperationType("SmsublSigMulSubLong") == EDataProcessingOperationType::SmsublSigMulSubLong);
      EXPECT(string_to_EDataProcessingOperationType("SmneglSigMulNotLong") == EDataProcessingOperationType::SmneglSigMulNotLong);
      EXPECT(string_to_EDataProcessingOperationType("SmullSigMulLong") == EDataProcessingOperationType::SmullSigMulLong);
      EXPECT(string_to_EDataProcessingOperationType("SmulhSigMulHigh") == EDataProcessingOperationType::SmulhSigMulHigh);
      EXPECT(string_to_EDataProcessingOperationType("UmaddlMulAddLong") == EDataProcessingOperationType::UmaddlMulAddLong);
      EXPECT(string_to_EDataProcessingOperationType("UmsublMulSubLong") == EDataProcessingOperationType::UmsublMulSubLong);
      EXPECT(string_to_EDataProcessingOperationType("UmneglMulNotLong") == EDataProcessingOperationType::UmneglMulNotLong);
      EXPECT(string_to_EDataProcessingOperationType("UmullMulLong") == EDataProcessingOperationType::UmullMulLong);
      EXPECT(string_to_EDataProcessingOperationType("UmulhMulHigh") == EDataProcessingOperationType::UmulhMulHigh);
      EXPECT(string_to_EDataProcessingOperationType("AndImm32") == EDataProcessingOperationType::AndImm32);
      EXPECT(string_to_EDataProcessingOperationType("AndImm64") == EDataProcessingOperationType::AndImm64);
      EXPECT(string_to_EDataProcessingOperationType("EorExcOrImm32") == EDataProcessingOperationType::EorExcOrImm32);
      EXPECT(string_to_EDataProcessingOperationType("EorExcOrImm64") == EDataProcessingOperationType::EorExcOrImm64);
      EXPECT(string_to_EDataProcessingOperationType("OrrIncOrImm32") == EDataProcessingOperationType::OrrIncOrImm32);
      EXPECT(string_to_EDataProcessingOperationType("OrrIncOrImm64") == EDataProcessingOperationType::OrrIncOrImm64);
      EXPECT(string_to_EDataProcessingOperationType("AddExt32") == EDataProcessingOperationType::AddExt32);
      EXPECT(string_to_EDataProcessingOperationType("AddExt64") == EDataProcessingOperationType::AddExt64);
      EXPECT(string_to_EDataProcessingOperationType("AddShift32") == EDataProcessingOperationType::AddShift32);
      EXPECT(string_to_EDataProcessingOperationType("AddShift64") == EDataProcessingOperationType::AddShift64);
      EXPECT(string_to_EDataProcessingOperationType("SubExt32") == EDataProcessingOperationType::SubExt32);
      EXPECT(string_to_EDataProcessingOperationType("SubExt64") == EDataProcessingOperationType::SubExt64);
      EXPECT(string_to_EDataProcessingOperationType("SubShift32") == EDataProcessingOperationType::SubShift32);
      EXPECT(string_to_EDataProcessingOperationType("SubShift64") == EDataProcessingOperationType::SubShift64);
      EXPECT(string_to_EDataProcessingOperationType("AddsAddSetFlagsExt32") == EDataProcessingOperationType::AddsAddSetFlagsExt32);
      EXPECT(string_to_EDataProcessingOperationType("AddsAddSetFlagsExt64") == EDataProcessingOperationType::AddsAddSetFlagsExt64);
      EXPECT(string_to_EDataProcessingOperationType("AddsAddSetFlagsShift32") == EDataProcessingOperationType::AddsAddSetFlagsShift32);
      EXPECT(string_to_EDataProcessingOperationType("AddsAddSetFlagsShift64") == EDataProcessingOperationType::AddsAddSetFlagsShift64);
      EXPECT(string_to_EDataProcessingOperationType("SubsSubSetFlagsExt32") == EDataProcessingOperationType::SubsSubSetFlagsExt32);
      EXPECT(string_to_EDataProcessingOperationType("SubsSubSetFlagsExt64") == EDataProcessingOperationType::SubsSubSetFlagsExt64);
      EXPECT(string_to_EDataProcessingOperationType("SubsSubSetFlagsShift32") == EDataProcessingOperationType::SubsSubSetFlagsShift32);
      EXPECT(string_to_EDataProcessingOperationType("SubsSubSetFlagsShift64") == EDataProcessingOperationType::SubsSubSetFlagsShift64);
      EXPECT(string_to_EDataProcessingOperationType("NegNegateShift32") == EDataProcessingOperationType::NegNegateShift32);
      EXPECT(string_to_EDataProcessingOperationType("NegNegateShift64") == EDataProcessingOperationType::NegNegateShift64);
      EXPECT(string_to_EDataProcessingOperationType("NegsNegateSetFlagsShift32") == EDataProcessingOperationType::NegsNegateSetFlagsShift32);
      EXPECT(string_to_EDataProcessingOperationType("NegsNegateSetFlagsShift64") == EDataProcessingOperationType::NegsNegateSetFlagsShift64);
      EXPECT(string_to_EDataProcessingOperationType("NgcNegateWithCarry32") == EDataProcessingOperationType::NgcNegateWithCarry32);
      EXPECT(string_to_EDataProcessingOperationType("NgcNegateWithCarry64") == EDataProcessingOperationType::NgcNegateWithCarry64);
      EXPECT(string_to_EDataProcessingOperationType("NgcsNegateWithCarrySetFlags32") == EDataProcessingOperationType::NgcsNegateWithCarrySetFlags32);
      EXPECT(string_to_EDataProcessingOperationType("NgcsNegateWithCarrySetFlags64") == EDataProcessingOperationType::NgcsNegateWithCarrySetFlags64);
      EXPECT(string_to_EDataProcessingOperationType("AndsAndSetFlagsShift32") == EDataProcessingOperationType::AndsAndSetFlagsShift32);
      EXPECT(string_to_EDataProcessingOperationType("AndsAndSetFlagsShift64") == EDataProcessingOperationType::AndsAndSetFlagsShift64);
      EXPECT(string_to_EDataProcessingOperationType("AndsAndSetFlagsImm32") == EDataProcessingOperationType::AndsAndSetFlagsImm32);
      EXPECT(string_to_EDataProcessingOperationType("AndsAndSetFlagsImm64") == EDataProcessingOperationType::AndsAndSetFlagsImm64);
      EXPECT(string_to_EDataProcessingOperationType("BicsClearSetFlagsShift32") == EDataProcessingOperationType::BicsClearSetFlagsShift32);
      EXPECT(string_to_EDataProcessingOperationType("BicsClearSetFlagsShift64") == EDataProcessingOperationType::BicsClearSetFlagsShift64);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EDataProcessingOperationType("U_known"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EDataProcessingOperationType("Unknown", okay) == EDataProcessingOperationType::Unknown);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MulAdd", okay) == EDataProcessingOperationType::MulAdd);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("Mul", okay) == EDataProcessingOperationType::Mul);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("UDiv", okay) == EDataProcessingOperationType::UDiv);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SDiv", okay) == EDataProcessingOperationType::SDiv);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddWithCarry", okay) == EDataProcessingOperationType::AddWithCarry);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubWithCarry", okay) == EDataProcessingOperationType::SubWithCarry);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndShift32", okay) == EDataProcessingOperationType::AndShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndShift64", okay) == EDataProcessingOperationType::AndShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("BicClearShift32", okay) == EDataProcessingOperationType::BicClearShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("BicClearShift64", okay) == EDataProcessingOperationType::BicClearShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("EonExcOrNotShift32", okay) == EDataProcessingOperationType::EonExcOrNotShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("EonExcOrNotShift64", okay) == EDataProcessingOperationType::EonExcOrNotShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("EorExcOrShift32", okay) == EDataProcessingOperationType::EorExcOrShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("EorExcOrShift64", okay) == EDataProcessingOperationType::EorExcOrShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("OrrIncOrShift32", okay) == EDataProcessingOperationType::OrrIncOrShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("OrrIncOrShift64", okay) == EDataProcessingOperationType::OrrIncOrShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MvnNotShift32", okay) == EDataProcessingOperationType::MvnNotShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MvnNotShift64", okay) == EDataProcessingOperationType::MvnNotShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("OrnIncOrNotShift32", okay) == EDataProcessingOperationType::OrnIncOrNotShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("OrnIncOrNotShift64", okay) == EDataProcessingOperationType::OrnIncOrNotShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MsubMulSub32", okay) == EDataProcessingOperationType::MsubMulSub32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MsubMulSub64", okay) == EDataProcessingOperationType::MsubMulSub64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MnegMulNot32", okay) == EDataProcessingOperationType::MnegMulNot32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("MnegMulNot64", okay) == EDataProcessingOperationType::MnegMulNot64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SmaddlSigMulAddLong", okay) == EDataProcessingOperationType::SmaddlSigMulAddLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SmsublSigMulSubLong", okay) == EDataProcessingOperationType::SmsublSigMulSubLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SmneglSigMulNotLong", okay) == EDataProcessingOperationType::SmneglSigMulNotLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SmullSigMulLong", okay) == EDataProcessingOperationType::SmullSigMulLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SmulhSigMulHigh", okay) == EDataProcessingOperationType::SmulhSigMulHigh);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("UmaddlMulAddLong", okay) == EDataProcessingOperationType::UmaddlMulAddLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("UmsublMulSubLong", okay) == EDataProcessingOperationType::UmsublMulSubLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("UmneglMulNotLong", okay) == EDataProcessingOperationType::UmneglMulNotLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("UmullMulLong", okay) == EDataProcessingOperationType::UmullMulLong);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("UmulhMulHigh", okay) == EDataProcessingOperationType::UmulhMulHigh);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndImm32", okay) == EDataProcessingOperationType::AndImm32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndImm64", okay) == EDataProcessingOperationType::AndImm64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("EorExcOrImm32", okay) == EDataProcessingOperationType::EorExcOrImm32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("EorExcOrImm64", okay) == EDataProcessingOperationType::EorExcOrImm64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("OrrIncOrImm32", okay) == EDataProcessingOperationType::OrrIncOrImm32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("OrrIncOrImm64", okay) == EDataProcessingOperationType::OrrIncOrImm64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddExt32", okay) == EDataProcessingOperationType::AddExt32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddExt64", okay) == EDataProcessingOperationType::AddExt64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddShift32", okay) == EDataProcessingOperationType::AddShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddShift64", okay) == EDataProcessingOperationType::AddShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubExt32", okay) == EDataProcessingOperationType::SubExt32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubExt64", okay) == EDataProcessingOperationType::SubExt64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubShift32", okay) == EDataProcessingOperationType::SubShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubShift64", okay) == EDataProcessingOperationType::SubShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddsAddSetFlagsExt32", okay) == EDataProcessingOperationType::AddsAddSetFlagsExt32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddsAddSetFlagsExt64", okay) == EDataProcessingOperationType::AddsAddSetFlagsExt64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddsAddSetFlagsShift32", okay) == EDataProcessingOperationType::AddsAddSetFlagsShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AddsAddSetFlagsShift64", okay) == EDataProcessingOperationType::AddsAddSetFlagsShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubsSubSetFlagsExt32", okay) == EDataProcessingOperationType::SubsSubSetFlagsExt32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubsSubSetFlagsExt64", okay) == EDataProcessingOperationType::SubsSubSetFlagsExt64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubsSubSetFlagsShift32", okay) == EDataProcessingOperationType::SubsSubSetFlagsShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("SubsSubSetFlagsShift64", okay) == EDataProcessingOperationType::SubsSubSetFlagsShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NegNegateShift32", okay) == EDataProcessingOperationType::NegNegateShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NegNegateShift64", okay) == EDataProcessingOperationType::NegNegateShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NegsNegateSetFlagsShift32", okay) == EDataProcessingOperationType::NegsNegateSetFlagsShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NegsNegateSetFlagsShift64", okay) == EDataProcessingOperationType::NegsNegateSetFlagsShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NgcNegateWithCarry32", okay) == EDataProcessingOperationType::NgcNegateWithCarry32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NgcNegateWithCarry64", okay) == EDataProcessingOperationType::NgcNegateWithCarry64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NgcsNegateWithCarrySetFlags32", okay) == EDataProcessingOperationType::NgcsNegateWithCarrySetFlags32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("NgcsNegateWithCarrySetFlags64", okay) == EDataProcessingOperationType::NgcsNegateWithCarrySetFlags64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndsAndSetFlagsShift32", okay) == EDataProcessingOperationType::AndsAndSetFlagsShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndsAndSetFlagsShift64", okay) == EDataProcessingOperationType::AndsAndSetFlagsShift64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndsAndSetFlagsImm32", okay) == EDataProcessingOperationType::AndsAndSetFlagsImm32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("AndsAndSetFlagsImm64", okay) == EDataProcessingOperationType::AndsAndSetFlagsImm64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("BicsClearSetFlagsShift32", okay) == EDataProcessingOperationType::BicsClearSetFlagsShift32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataProcessingOperationType("BicsClearSetFlagsShift64", okay) == EDataProcessingOperationType::BicsClearSetFlagsShift64);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EDataProcessingOperationType("U_known", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EPteType" ) {

  SETUP ( "setup EPteType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EPteType_to_string(EPteType::P4K) == "P4K");
      EXPECT(EPteType_to_string(EPteType::P16K) == "P16K");
      EXPECT(EPteType_to_string(EPteType::P64K) == "P64K");
      EXPECT(EPteType_to_string(EPteType::P2M) == "P2M");
      EXPECT(EPteType_to_string(EPteType::P32M) == "P32M");
      EXPECT(EPteType_to_string(EPteType::P512M) == "P512M");
      EXPECT(EPteType_to_string(EPteType::P1G) == "P1G");
      EXPECT(EPteType_to_string(EPteType::P512G) == "P512G");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EPteType("P4K") == EPteType::P4K);
      EXPECT(string_to_EPteType("P16K") == EPteType::P16K);
      EXPECT(string_to_EPteType("P64K") == EPteType::P64K);
      EXPECT(string_to_EPteType("P2M") == EPteType::P2M);
      EXPECT(string_to_EPteType("P32M") == EPteType::P32M);
      EXPECT(string_to_EPteType("P512M") == EPteType::P512M);
      EXPECT(string_to_EPteType("P1G") == EPteType::P1G);
      EXPECT(string_to_EPteType("P512G") == EPteType::P512G);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EPteType("P_K"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EPteType("P4K", okay) == EPteType::P4K);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P16K", okay) == EPteType::P16K);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P64K", okay) == EPteType::P64K);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P2M", okay) == EPteType::P2M);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P32M", okay) == EPteType::P32M);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P512M", okay) == EPteType::P512M);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P1G", okay) == EPteType::P1G);
      EXPECT(okay);
      EXPECT(try_string_to_EPteType("P512G", okay) == EPteType::P512G);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EPteType("P_K", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EPteCategoryType" ) {

  SETUP ( "setup EPteCategoryType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EPteCategoryType_to_string(EPteCategoryType::Page) == "Page");
      EXPECT(EPteCategoryType_to_string(EPteCategoryType::Table) == "Table");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EPteCategoryType("Page") == EPteCategoryType::Page);
      EXPECT(string_to_EPteCategoryType("Table") == EPteCategoryType::Table);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EPteCategoryType("P_ge"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EPteCategoryType("Page", okay) == EPteCategoryType::Page);
      EXPECT(okay);
      EXPECT(try_string_to_EPteCategoryType("Table", okay) == EPteCategoryType::Table);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EPteCategoryType("P_ge", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ENotificationType" ) {

  SETUP ( "setup ENotificationType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ENotificationType_to_string(ENotificationType::RegisterUpdate) == "RegisterUpdate");
      EXPECT(ENotificationType_to_string(ENotificationType::RegisterInitiation) == "RegisterInitiation");
      EXPECT(ENotificationType_to_string(ENotificationType::ChoiceUpdate) == "ChoiceUpdate");
      EXPECT(ENotificationType_to_string(ENotificationType::VariableUpdate) == "VariableUpdate");
      EXPECT(ENotificationType_to_string(ENotificationType::ConditionUpdate) == "ConditionUpdate");
      EXPECT(ENotificationType_to_string(ENotificationType::PhysicalRegionAdded) == "PhysicalRegionAdded");
      EXPECT(ENotificationType_to_string(ENotificationType::PCUpdate) == "PCUpdate");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ENotificationType("RegisterUpdate") == ENotificationType::RegisterUpdate);
      EXPECT(string_to_ENotificationType("RegisterInitiation") == ENotificationType::RegisterInitiation);
      EXPECT(string_to_ENotificationType("ChoiceUpdate") == ENotificationType::ChoiceUpdate);
      EXPECT(string_to_ENotificationType("VariableUpdate") == ENotificationType::VariableUpdate);
      EXPECT(string_to_ENotificationType("ConditionUpdate") == ENotificationType::ConditionUpdate);
      EXPECT(string_to_ENotificationType("PhysicalRegionAdded") == ENotificationType::PhysicalRegionAdded);
      EXPECT(string_to_ENotificationType("PCUpdate") == ENotificationType::PCUpdate);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ENotificationType("R_gisterUpdate"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ENotificationType("RegisterUpdate", okay) == ENotificationType::RegisterUpdate);
      EXPECT(okay);
      EXPECT(try_string_to_ENotificationType("RegisterInitiation", okay) == ENotificationType::RegisterInitiation);
      EXPECT(okay);
      EXPECT(try_string_to_ENotificationType("ChoiceUpdate", okay) == ENotificationType::ChoiceUpdate);
      EXPECT(okay);
      EXPECT(try_string_to_ENotificationType("VariableUpdate", okay) == ENotificationType::VariableUpdate);
      EXPECT(okay);
      EXPECT(try_string_to_ENotificationType("ConditionUpdate", okay) == ENotificationType::ConditionUpdate);
      EXPECT(okay);
      EXPECT(try_string_to_ENotificationType("PhysicalRegionAdded", okay) == ENotificationType::PhysicalRegionAdded);
      EXPECT(okay);
      EXPECT(try_string_to_ENotificationType("PCUpdate", okay) == ENotificationType::PCUpdate);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ENotificationType("R_gisterUpdate", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EPageRequestAttributeType" ) {

  SETUP ( "setup EPageRequestAttributeType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::VA) == "VA");
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::IPA) == "IPA");
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::PA) == "PA");
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::PageSize) == "PageSize");
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::MemAttrArch) == "MemAttrArch");
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::MemAttrImpl) == "MemAttrImpl");
      EXPECT(EPageRequestAttributeType_to_string(EPageRequestAttributeType::AliasPageId) == "AliasPageId");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EPageRequestAttributeType("VA") == EPageRequestAttributeType::VA);
      EXPECT(string_to_EPageRequestAttributeType("IPA") == EPageRequestAttributeType::IPA);
      EXPECT(string_to_EPageRequestAttributeType("PA") == EPageRequestAttributeType::PA);
      EXPECT(string_to_EPageRequestAttributeType("PageSize") == EPageRequestAttributeType::PageSize);
      EXPECT(string_to_EPageRequestAttributeType("MemAttrArch") == EPageRequestAttributeType::MemAttrArch);
      EXPECT(string_to_EPageRequestAttributeType("MemAttrImpl") == EPageRequestAttributeType::MemAttrImpl);
      EXPECT(string_to_EPageRequestAttributeType("AliasPageId") == EPageRequestAttributeType::AliasPageId);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EPageRequestAttributeType("V_"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EPageRequestAttributeType("VA", okay) == EPageRequestAttributeType::VA);
      EXPECT(okay);
      EXPECT(try_string_to_EPageRequestAttributeType("IPA", okay) == EPageRequestAttributeType::IPA);
      EXPECT(okay);
      EXPECT(try_string_to_EPageRequestAttributeType("PA", okay) == EPageRequestAttributeType::PA);
      EXPECT(okay);
      EXPECT(try_string_to_EPageRequestAttributeType("PageSize", okay) == EPageRequestAttributeType::PageSize);
      EXPECT(okay);
      EXPECT(try_string_to_EPageRequestAttributeType("MemAttrArch", okay) == EPageRequestAttributeType::MemAttrArch);
      EXPECT(okay);
      EXPECT(try_string_to_EPageRequestAttributeType("MemAttrImpl", okay) == EPageRequestAttributeType::MemAttrImpl);
      EXPECT(okay);
      EXPECT(try_string_to_EPageRequestAttributeType("AliasPageId", okay) == EPageRequestAttributeType::AliasPageId);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EPageRequestAttributeType("V_", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EPageGenAttributeType" ) {

  SETUP ( "setup EPageGenAttributeType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EPageGenAttributeType_to_string(EPageGenAttributeType::MemAttrImpl) == "MemAttrImpl");
      EXPECT(EPageGenAttributeType_to_string(EPageGenAttributeType::Invalid) == "Invalid");
      EXPECT(EPageGenAttributeType_to_string(EPageGenAttributeType::AddrSizeFault) == "AddrSizeFault");
      EXPECT(EPageGenAttributeType_to_string(EPageGenAttributeType::DataAccessPermission) == "DataAccessPermission");
      EXPECT(EPageGenAttributeType_to_string(EPageGenAttributeType::InstrAccessPermission) == "InstrAccessPermission");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EPageGenAttributeType("MemAttrImpl") == EPageGenAttributeType::MemAttrImpl);
      EXPECT(string_to_EPageGenAttributeType("Invalid") == EPageGenAttributeType::Invalid);
      EXPECT(string_to_EPageGenAttributeType("AddrSizeFault") == EPageGenAttributeType::AddrSizeFault);
      EXPECT(string_to_EPageGenAttributeType("DataAccessPermission") == EPageGenAttributeType::DataAccessPermission);
      EXPECT(string_to_EPageGenAttributeType("InstrAccessPermission") == EPageGenAttributeType::InstrAccessPermission);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EPageGenAttributeType("M_mAttrImpl"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EPageGenAttributeType("MemAttrImpl", okay) == EPageGenAttributeType::MemAttrImpl);
      EXPECT(okay);
      EXPECT(try_string_to_EPageGenAttributeType("Invalid", okay) == EPageGenAttributeType::Invalid);
      EXPECT(okay);
      EXPECT(try_string_to_EPageGenAttributeType("AddrSizeFault", okay) == EPageGenAttributeType::AddrSizeFault);
      EXPECT(okay);
      EXPECT(try_string_to_EPageGenAttributeType("DataAccessPermission", okay) == EPageGenAttributeType::DataAccessPermission);
      EXPECT(okay);
      EXPECT(try_string_to_EPageGenAttributeType("InstrAccessPermission", okay) == EPageGenAttributeType::InstrAccessPermission);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EPageGenAttributeType("M_mAttrImpl", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EDataAccessPermissionType" ) {

  SETUP ( "setup EDataAccessPermissionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::NoAccess) == "NoAccess");
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::ReadWrite) == "ReadWrite");
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::ReadOnly) == "ReadOnly");
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::ReadWriteNoUser) == "ReadWriteNoUser");
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::ReadOnlyNoUser) == "ReadOnlyNoUser");
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::ReadWriteUserOnly) == "ReadWriteUserOnly");
      EXPECT(EDataAccessPermissionType_to_string(EDataAccessPermissionType::ReadOnlyUserOnly) == "ReadOnlyUserOnly");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EDataAccessPermissionType("NoAccess") == EDataAccessPermissionType::NoAccess);
      EXPECT(string_to_EDataAccessPermissionType("ReadWrite") == EDataAccessPermissionType::ReadWrite);
      EXPECT(string_to_EDataAccessPermissionType("ReadOnly") == EDataAccessPermissionType::ReadOnly);
      EXPECT(string_to_EDataAccessPermissionType("ReadWriteNoUser") == EDataAccessPermissionType::ReadWriteNoUser);
      EXPECT(string_to_EDataAccessPermissionType("ReadOnlyNoUser") == EDataAccessPermissionType::ReadOnlyNoUser);
      EXPECT(string_to_EDataAccessPermissionType("ReadWriteUserOnly") == EDataAccessPermissionType::ReadWriteUserOnly);
      EXPECT(string_to_EDataAccessPermissionType("ReadOnlyUserOnly") == EDataAccessPermissionType::ReadOnlyUserOnly);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EDataAccessPermissionType("N_Access"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EDataAccessPermissionType("NoAccess", okay) == EDataAccessPermissionType::NoAccess);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAccessPermissionType("ReadWrite", okay) == EDataAccessPermissionType::ReadWrite);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAccessPermissionType("ReadOnly", okay) == EDataAccessPermissionType::ReadOnly);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAccessPermissionType("ReadWriteNoUser", okay) == EDataAccessPermissionType::ReadWriteNoUser);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAccessPermissionType("ReadOnlyNoUser", okay) == EDataAccessPermissionType::ReadOnlyNoUser);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAccessPermissionType("ReadWriteUserOnly", okay) == EDataAccessPermissionType::ReadWriteUserOnly);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAccessPermissionType("ReadOnlyUserOnly", okay) == EDataAccessPermissionType::ReadOnlyUserOnly);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EDataAccessPermissionType("N_Access", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EInstrAccessPermissionType" ) {

  SETUP ( "setup EInstrAccessPermissionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EInstrAccessPermissionType_to_string(EInstrAccessPermissionType::Execute) == "Execute");
      EXPECT(EInstrAccessPermissionType_to_string(EInstrAccessPermissionType::NoExecute) == "NoExecute");
      EXPECT(EInstrAccessPermissionType_to_string(EInstrAccessPermissionType::PrivilegedNoExecute) == "PrivilegedNoExecute");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EInstrAccessPermissionType("Execute") == EInstrAccessPermissionType::Execute);
      EXPECT(string_to_EInstrAccessPermissionType("NoExecute") == EInstrAccessPermissionType::NoExecute);
      EXPECT(string_to_EInstrAccessPermissionType("PrivilegedNoExecute") == EInstrAccessPermissionType::PrivilegedNoExecute);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EInstrAccessPermissionType("E_ecute"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EInstrAccessPermissionType("Execute", okay) == EInstrAccessPermissionType::Execute);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrAccessPermissionType("NoExecute", okay) == EInstrAccessPermissionType::NoExecute);
      EXPECT(okay);
      EXPECT(try_string_to_EInstrAccessPermissionType("PrivilegedNoExecute", okay) == EInstrAccessPermissionType::PrivilegedNoExecute);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EInstrAccessPermissionType("E_ecute", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EGlobalStateType" ) {

  SETUP ( "setup EGlobalStateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::ResetPC) == "ResetPC");
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::PageTableRegionSize) == "PageTableRegionSize");
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::PageTableRegionAlign) == "PageTableRegionAlign");
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::PageTableRegionStart) == "PageTableRegionStart");
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::MemoryFillPattern) == "MemoryFillPattern");
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::ElfMachine) == "ElfMachine");
      EXPECT(EGlobalStateType_to_string(EGlobalStateType::RV32) == "RV32");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EGlobalStateType("ResetPC") == EGlobalStateType::ResetPC);
      EXPECT(string_to_EGlobalStateType("PageTableRegionSize") == EGlobalStateType::PageTableRegionSize);
      EXPECT(string_to_EGlobalStateType("PageTableRegionAlign") == EGlobalStateType::PageTableRegionAlign);
      EXPECT(string_to_EGlobalStateType("PageTableRegionStart") == EGlobalStateType::PageTableRegionStart);
      EXPECT(string_to_EGlobalStateType("MemoryFillPattern") == EGlobalStateType::MemoryFillPattern);
      EXPECT(string_to_EGlobalStateType("ElfMachine") == EGlobalStateType::ElfMachine);
      EXPECT(string_to_EGlobalStateType("RV32") == EGlobalStateType::RV32);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EGlobalStateType("R_setPC"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EGlobalStateType("ResetPC", okay) == EGlobalStateType::ResetPC);
      EXPECT(okay);
      EXPECT(try_string_to_EGlobalStateType("PageTableRegionSize", okay) == EGlobalStateType::PageTableRegionSize);
      EXPECT(okay);
      EXPECT(try_string_to_EGlobalStateType("PageTableRegionAlign", okay) == EGlobalStateType::PageTableRegionAlign);
      EXPECT(okay);
      EXPECT(try_string_to_EGlobalStateType("PageTableRegionStart", okay) == EGlobalStateType::PageTableRegionStart);
      EXPECT(okay);
      EXPECT(try_string_to_EGlobalStateType("MemoryFillPattern", okay) == EGlobalStateType::MemoryFillPattern);
      EXPECT(okay);
      EXPECT(try_string_to_EGlobalStateType("ElfMachine", okay) == EGlobalStateType::ElfMachine);
      EXPECT(okay);
      EXPECT(try_string_to_EGlobalStateType("RV32", okay) == EGlobalStateType::RV32);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EGlobalStateType("R_setPC", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EAddrType" ) {

  SETUP ( "setup EAddrType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EAddrType_to_string(EAddrType::DataAddr) == "DataAddr");
      EXPECT(EAddrType_to_string(EAddrType::InstructionAddr) == "InstructionAddr");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EAddrType("DataAddr") == EAddrType::DataAddr);
      EXPECT(string_to_EAddrType("InstructionAddr") == EAddrType::InstructionAddr);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EAddrType("D_taAddr"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EAddrType("DataAddr", okay) == EAddrType::DataAddr);
      EXPECT(okay);
      EXPECT(try_string_to_EAddrType("InstructionAddr", okay) == EAddrType::InstructionAddr);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EAddrType("D_taAddr", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EBootElementActionType" ) {

  SETUP ( "setup EBootElementActionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EBootElementActionType_to_string(EBootElementActionType::LoadRegister) == "LoadRegister");
      EXPECT(EBootElementActionType_to_string(EBootElementActionType::InstructionBarrier) == "InstructionBarrier");
      EXPECT(EBootElementActionType_to_string(EBootElementActionType::DataBarrier) == "DataBarrier");
      EXPECT(EBootElementActionType_to_string(EBootElementActionType::LoadLargeRegister) == "LoadLargeRegister");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EBootElementActionType("LoadRegister") == EBootElementActionType::LoadRegister);
      EXPECT(string_to_EBootElementActionType("InstructionBarrier") == EBootElementActionType::InstructionBarrier);
      EXPECT(string_to_EBootElementActionType("DataBarrier") == EBootElementActionType::DataBarrier);
      EXPECT(string_to_EBootElementActionType("LoadLargeRegister") == EBootElementActionType::LoadLargeRegister);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EBootElementActionType("L_adRegister"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EBootElementActionType("LoadRegister", okay) == EBootElementActionType::LoadRegister);
      EXPECT(okay);
      EXPECT(try_string_to_EBootElementActionType("InstructionBarrier", okay) == EBootElementActionType::InstructionBarrier);
      EXPECT(okay);
      EXPECT(try_string_to_EBootElementActionType("DataBarrier", okay) == EBootElementActionType::DataBarrier);
      EXPECT(okay);
      EXPECT(try_string_to_EBootElementActionType("LoadLargeRegister", okay) == EBootElementActionType::LoadLargeRegister);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EBootElementActionType("L_adRegister", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EQueryType" ) {

  SETUP ( "setup EQueryType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EQueryType_to_string(EQueryType::RegisterIndex) == "RegisterIndex");
      EXPECT(EQueryType_to_string(EQueryType::RegisterReloadValue) == "RegisterReloadValue");
      EXPECT(EQueryType_to_string(EQueryType::InstructionRecord) == "InstructionRecord");
      EXPECT(EQueryType_to_string(EQueryType::RegisterInfo) == "RegisterInfo");
      EXPECT(EQueryType_to_string(EQueryType::GenState) == "GenState");
      EXPECT(EQueryType_to_string(EQueryType::PageInfo) == "PageInfo");
      EXPECT(EQueryType_to_string(EQueryType::BranchOffset) == "BranchOffset");
      EXPECT(EQueryType_to_string(EQueryType::RegisterFieldInfo) == "RegisterFieldInfo");
      EXPECT(EQueryType_to_string(EQueryType::ChoicesTreeInfo) == "ChoicesTreeInfo");
      EXPECT(EQueryType_to_string(EQueryType::SimpleExceptionsHistory) == "SimpleExceptionsHistory");
      EXPECT(EQueryType_to_string(EQueryType::AdvancedExceptionsHistory) == "AdvancedExceptionsHistory");
      EXPECT(EQueryType_to_string(EQueryType::MaxAddress) == "MaxAddress");
      EXPECT(EQueryType_to_string(EQueryType::ValidAddressMask) == "ValidAddressMask");
      EXPECT(EQueryType_to_string(EQueryType::HandlerSetMemory) == "HandlerSetMemory");
      EXPECT(EQueryType_to_string(EQueryType::ExceptionVectorBaseAddress) == "ExceptionVectorBaseAddress");
      EXPECT(EQueryType_to_string(EQueryType::ResourceEntropy) == "ResourceEntropy");
      EXPECT(EQueryType_to_string(EQueryType::SoftwareStepPrivLevs) == "SoftwareStepPrivLevs");
      EXPECT(EQueryType_to_string(EQueryType::SoftwareStepReady) == "SoftwareStepReady");
      EXPECT(EQueryType_to_string(EQueryType::PickedValue) == "PickedValue");
      EXPECT(EQueryType_to_string(EQueryType::GetVmContextDelta) == "GetVmContextDelta");
      EXPECT(EQueryType_to_string(EQueryType::RestoreLoopContext) == "RestoreLoopContext");
      EXPECT(EQueryType_to_string(EQueryType::GenData) == "GenData");
      EXPECT(EQueryType_to_string(EQueryType::GetVmCurrentContext) == "GetVmCurrentContext");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EQueryType("RegisterIndex") == EQueryType::RegisterIndex);
      EXPECT(string_to_EQueryType("RegisterReloadValue") == EQueryType::RegisterReloadValue);
      EXPECT(string_to_EQueryType("InstructionRecord") == EQueryType::InstructionRecord);
      EXPECT(string_to_EQueryType("RegisterInfo") == EQueryType::RegisterInfo);
      EXPECT(string_to_EQueryType("GenState") == EQueryType::GenState);
      EXPECT(string_to_EQueryType("PageInfo") == EQueryType::PageInfo);
      EXPECT(string_to_EQueryType("BranchOffset") == EQueryType::BranchOffset);
      EXPECT(string_to_EQueryType("RegisterFieldInfo") == EQueryType::RegisterFieldInfo);
      EXPECT(string_to_EQueryType("ChoicesTreeInfo") == EQueryType::ChoicesTreeInfo);
      EXPECT(string_to_EQueryType("SimpleExceptionsHistory") == EQueryType::SimpleExceptionsHistory);
      EXPECT(string_to_EQueryType("AdvancedExceptionsHistory") == EQueryType::AdvancedExceptionsHistory);
      EXPECT(string_to_EQueryType("MaxAddress") == EQueryType::MaxAddress);
      EXPECT(string_to_EQueryType("ValidAddressMask") == EQueryType::ValidAddressMask);
      EXPECT(string_to_EQueryType("HandlerSetMemory") == EQueryType::HandlerSetMemory);
      EXPECT(string_to_EQueryType("ExceptionVectorBaseAddress") == EQueryType::ExceptionVectorBaseAddress);
      EXPECT(string_to_EQueryType("ResourceEntropy") == EQueryType::ResourceEntropy);
      EXPECT(string_to_EQueryType("SoftwareStepPrivLevs") == EQueryType::SoftwareStepPrivLevs);
      EXPECT(string_to_EQueryType("SoftwareStepReady") == EQueryType::SoftwareStepReady);
      EXPECT(string_to_EQueryType("PickedValue") == EQueryType::PickedValue);
      EXPECT(string_to_EQueryType("GetVmContextDelta") == EQueryType::GetVmContextDelta);
      EXPECT(string_to_EQueryType("RestoreLoopContext") == EQueryType::RestoreLoopContext);
      EXPECT(string_to_EQueryType("GenData") == EQueryType::GenData);
      EXPECT(string_to_EQueryType("GetVmCurrentContext") == EQueryType::GetVmCurrentContext);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EQueryType("R_gisterIndex"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EQueryType("RegisterIndex", okay) == EQueryType::RegisterIndex);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("RegisterReloadValue", okay) == EQueryType::RegisterReloadValue);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("InstructionRecord", okay) == EQueryType::InstructionRecord);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("RegisterInfo", okay) == EQueryType::RegisterInfo);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("GenState", okay) == EQueryType::GenState);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("PageInfo", okay) == EQueryType::PageInfo);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("BranchOffset", okay) == EQueryType::BranchOffset);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("RegisterFieldInfo", okay) == EQueryType::RegisterFieldInfo);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("ChoicesTreeInfo", okay) == EQueryType::ChoicesTreeInfo);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("SimpleExceptionsHistory", okay) == EQueryType::SimpleExceptionsHistory);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("AdvancedExceptionsHistory", okay) == EQueryType::AdvancedExceptionsHistory);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("MaxAddress", okay) == EQueryType::MaxAddress);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("ValidAddressMask", okay) == EQueryType::ValidAddressMask);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("HandlerSetMemory", okay) == EQueryType::HandlerSetMemory);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("ExceptionVectorBaseAddress", okay) == EQueryType::ExceptionVectorBaseAddress);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("ResourceEntropy", okay) == EQueryType::ResourceEntropy);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("SoftwareStepPrivLevs", okay) == EQueryType::SoftwareStepPrivLevs);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("SoftwareStepReady", okay) == EQueryType::SoftwareStepReady);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("PickedValue", okay) == EQueryType::PickedValue);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("GetVmContextDelta", okay) == EQueryType::GetVmContextDelta);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("RestoreLoopContext", okay) == EQueryType::RestoreLoopContext);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("GenData", okay) == EQueryType::GenData);
      EXPECT(okay);
      EXPECT(try_string_to_EQueryType("GetVmCurrentContext", okay) == EQueryType::GetVmCurrentContext);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EQueryType("R_gisterIndex", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EGenModeType" ) {

  SETUP ( "setup EGenModeType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EGenModeType_to_string(EGenModeType::NoIss) == "NoIss");
      EXPECT(EGenModeType_to_string(EGenModeType::SimOff) == "SimOff");
      EXPECT(EGenModeType_to_string(EGenModeType::NoEscape) == "NoEscape");
      EXPECT(EGenModeType_to_string(EGenModeType::NoJump) == "NoJump");
      EXPECT(EGenModeType_to_string(EGenModeType::ReExe) == "ReExe");
      EXPECT(EGenModeType_to_string(EGenModeType::Exception) == "Exception");
      EXPECT(EGenModeType_to_string(EGenModeType::NoSkip) == "NoSkip");
      EXPECT(EGenModeType_to_string(EGenModeType::InLoop) == "InLoop");
      EXPECT(EGenModeType_to_string(EGenModeType::DelayInit) == "DelayInit");
      EXPECT(EGenModeType_to_string(EGenModeType::LowPower) == "LowPower");
      EXPECT(EGenModeType_to_string(EGenModeType::Filler) == "Filler");
      EXPECT(EGenModeType_to_string(EGenModeType::Speculative) == "Speculative");
      EXPECT(EGenModeType_to_string(EGenModeType::AddressShortage) == "AddressShortage");
      EXPECT(EGenModeType_to_string(EGenModeType::RecordingState) == "RecordingState");
      EXPECT(EGenModeType_to_string(EGenModeType::RestoreStateLoop) == "RestoreStateLoop");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EGenModeType("NoIss") == EGenModeType::NoIss);
      EXPECT(string_to_EGenModeType("SimOff") == EGenModeType::SimOff);
      EXPECT(string_to_EGenModeType("NoEscape") == EGenModeType::NoEscape);
      EXPECT(string_to_EGenModeType("NoJump") == EGenModeType::NoJump);
      EXPECT(string_to_EGenModeType("ReExe") == EGenModeType::ReExe);
      EXPECT(string_to_EGenModeType("Exception") == EGenModeType::Exception);
      EXPECT(string_to_EGenModeType("NoSkip") == EGenModeType::NoSkip);
      EXPECT(string_to_EGenModeType("InLoop") == EGenModeType::InLoop);
      EXPECT(string_to_EGenModeType("DelayInit") == EGenModeType::DelayInit);
      EXPECT(string_to_EGenModeType("LowPower") == EGenModeType::LowPower);
      EXPECT(string_to_EGenModeType("Filler") == EGenModeType::Filler);
      EXPECT(string_to_EGenModeType("Speculative") == EGenModeType::Speculative);
      EXPECT(string_to_EGenModeType("AddressShortage") == EGenModeType::AddressShortage);
      EXPECT(string_to_EGenModeType("RecordingState") == EGenModeType::RecordingState);
      EXPECT(string_to_EGenModeType("RestoreStateLoop") == EGenModeType::RestoreStateLoop);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EGenModeType("N_Iss"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EGenModeType("NoIss", okay) == EGenModeType::NoIss);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("SimOff", okay) == EGenModeType::SimOff);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("NoEscape", okay) == EGenModeType::NoEscape);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("NoJump", okay) == EGenModeType::NoJump);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("ReExe", okay) == EGenModeType::ReExe);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("Exception", okay) == EGenModeType::Exception);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("NoSkip", okay) == EGenModeType::NoSkip);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("InLoop", okay) == EGenModeType::InLoop);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("DelayInit", okay) == EGenModeType::DelayInit);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("LowPower", okay) == EGenModeType::LowPower);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("Filler", okay) == EGenModeType::Filler);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("Speculative", okay) == EGenModeType::Speculative);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("AddressShortage", okay) == EGenModeType::AddressShortage);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("RecordingState", okay) == EGenModeType::RecordingState);
      EXPECT(okay);
      EXPECT(try_string_to_EGenModeType("RestoreStateLoop", okay) == EGenModeType::RestoreStateLoop);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EGenModeType("N_Iss", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EGenStateType" ) {

  SETUP ( "setup EGenStateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EGenStateType_to_string(EGenStateType::GenMode) == "GenMode");
      EXPECT(EGenStateType_to_string(EGenStateType::PC) == "PC");
      EXPECT(EGenStateType_to_string(EGenStateType::InitialPC) == "InitialPC");
      EXPECT(EGenStateType_to_string(EGenStateType::BootPC) == "BootPC");
      EXPECT(EGenStateType_to_string(EGenStateType::EL) == "EL");
      EXPECT(EGenStateType_to_string(EGenStateType::Loop) == "Loop");
      EXPECT(EGenStateType_to_string(EGenStateType::CPSR) == "CPSR");
      EXPECT(EGenStateType_to_string(EGenStateType::LinearBlock) == "LinearBlock");
      EXPECT(EGenStateType_to_string(EGenStateType::LastPC) == "LastPC");
      EXPECT(EGenStateType_to_string(EGenStateType::BntHook) == "BntHook");
      EXPECT(EGenStateType_to_string(EGenStateType::PostLoopAddress) == "PostLoopAddress");
      EXPECT(EGenStateType_to_string(EGenStateType::LoopReconvergeAddress) == "LoopReconvergeAddress");
      EXPECT(EGenStateType_to_string(EGenStateType::PrivilegeLevel) == "PrivilegeLevel");
      EXPECT(EGenStateType_to_string(EGenStateType::Endianness) == "Endianness");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EGenStateType("GenMode") == EGenStateType::GenMode);
      EXPECT(string_to_EGenStateType("PC") == EGenStateType::PC);
      EXPECT(string_to_EGenStateType("InitialPC") == EGenStateType::InitialPC);
      EXPECT(string_to_EGenStateType("BootPC") == EGenStateType::BootPC);
      EXPECT(string_to_EGenStateType("EL") == EGenStateType::EL);
      EXPECT(string_to_EGenStateType("Loop") == EGenStateType::Loop);
      EXPECT(string_to_EGenStateType("CPSR") == EGenStateType::CPSR);
      EXPECT(string_to_EGenStateType("LinearBlock") == EGenStateType::LinearBlock);
      EXPECT(string_to_EGenStateType("LastPC") == EGenStateType::LastPC);
      EXPECT(string_to_EGenStateType("BntHook") == EGenStateType::BntHook);
      EXPECT(string_to_EGenStateType("PostLoopAddress") == EGenStateType::PostLoopAddress);
      EXPECT(string_to_EGenStateType("LoopReconvergeAddress") == EGenStateType::LoopReconvergeAddress);
      EXPECT(string_to_EGenStateType("PrivilegeLevel") == EGenStateType::PrivilegeLevel);
      EXPECT(string_to_EGenStateType("Endianness") == EGenStateType::Endianness);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EGenStateType("G_nMode"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EGenStateType("GenMode", okay) == EGenStateType::GenMode);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("PC", okay) == EGenStateType::PC);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("InitialPC", okay) == EGenStateType::InitialPC);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("BootPC", okay) == EGenStateType::BootPC);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("EL", okay) == EGenStateType::EL);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("Loop", okay) == EGenStateType::Loop);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("CPSR", okay) == EGenStateType::CPSR);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("LinearBlock", okay) == EGenStateType::LinearBlock);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("LastPC", okay) == EGenStateType::LastPC);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("BntHook", okay) == EGenStateType::BntHook);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("PostLoopAddress", okay) == EGenStateType::PostLoopAddress);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("LoopReconvergeAddress", okay) == EGenStateType::LoopReconvergeAddress);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("PrivilegeLevel", okay) == EGenStateType::PrivilegeLevel);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateType("Endianness", okay) == EGenStateType::Endianness);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EGenStateType("G_nMode", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EGenStateActionType" ) {

  SETUP ( "setup EGenStateActionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EGenStateActionType_to_string(EGenStateActionType::Push) == "Push");
      EXPECT(EGenStateActionType_to_string(EGenStateActionType::Pop) == "Pop");
      EXPECT(EGenStateActionType_to_string(EGenStateActionType::Set) == "Set");
      EXPECT(EGenStateActionType_to_string(EGenStateActionType::Enable) == "Enable");
      EXPECT(EGenStateActionType_to_string(EGenStateActionType::Disable) == "Disable");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EGenStateActionType("Push") == EGenStateActionType::Push);
      EXPECT(string_to_EGenStateActionType("Pop") == EGenStateActionType::Pop);
      EXPECT(string_to_EGenStateActionType("Set") == EGenStateActionType::Set);
      EXPECT(string_to_EGenStateActionType("Enable") == EGenStateActionType::Enable);
      EXPECT(string_to_EGenStateActionType("Disable") == EGenStateActionType::Disable);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EGenStateActionType("P_sh"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EGenStateActionType("Push", okay) == EGenStateActionType::Push);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateActionType("Pop", okay) == EGenStateActionType::Pop);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateActionType("Set", okay) == EGenStateActionType::Set);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateActionType("Enable", okay) == EGenStateActionType::Enable);
      EXPECT(okay);
      EXPECT(try_string_to_EGenStateActionType("Disable", okay) == EGenStateActionType::Disable);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EGenStateActionType("P_sh", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EGenExceptionDetatilType" ) {

  SETUP ( "setup EGenExceptionDetatilType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EGenExceptionDetatilType_to_string(EGenExceptionDetatilType::RegisterNotInitSetValue) == "RegisterNotInitSetValue");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EGenExceptionDetatilType("RegisterNotInitSetValue") == EGenExceptionDetatilType::RegisterNotInitSetValue);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EGenExceptionDetatilType("R_gisterNotInitSetValue"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EGenExceptionDetatilType("RegisterNotInitSetValue", okay) == EGenExceptionDetatilType::RegisterNotInitSetValue);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EGenExceptionDetatilType("R_gisterNotInitSetValue", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EExceptionRequestType" ) {

  SETUP ( "setup EExceptionRequestType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EExceptionRequestType_to_string(EExceptionRequestType::HandleException) == "HandleException");
      EXPECT(EExceptionRequestType_to_string(EExceptionRequestType::SystemCall) == "SystemCall");
      EXPECT(EExceptionRequestType_to_string(EExceptionRequestType::UpdateHandlerInfo) == "UpdateHandlerInfo");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EExceptionRequestType("HandleException") == EExceptionRequestType::HandleException);
      EXPECT(string_to_EExceptionRequestType("SystemCall") == EExceptionRequestType::SystemCall);
      EXPECT(string_to_EExceptionRequestType("UpdateHandlerInfo") == EExceptionRequestType::UpdateHandlerInfo);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EExceptionRequestType("H_ndleException"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EExceptionRequestType("HandleException", okay) == EExceptionRequestType::HandleException);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionRequestType("SystemCall", okay) == EExceptionRequestType::SystemCall);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionRequestType("UpdateHandlerInfo", okay) == EExceptionRequestType::UpdateHandlerInfo);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EExceptionRequestType("H_ndleException", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EExceptionEventType" ) {

  SETUP ( "setup EExceptionEventType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EExceptionEventType_to_string(EExceptionEventType::ExceptionReturn) == "ExceptionReturn");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EExceptionEventType("ExceptionReturn") == EExceptionEventType::ExceptionReturn);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EExceptionEventType("E_ceptionReturn"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EExceptionEventType("ExceptionReturn", okay) == EExceptionEventType::ExceptionReturn);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EExceptionEventType("E_ceptionReturn", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EExceptionConstraintType" ) {

  SETUP ( "setup EExceptionConstraintType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EExceptionConstraintType_to_string(EExceptionConstraintType::Allow) == "Allow");
      EXPECT(EExceptionConstraintType_to_string(EExceptionConstraintType::Prevent) == "Prevent");
      EXPECT(EExceptionConstraintType_to_string(EExceptionConstraintType::Trigger) == "Trigger");
      EXPECT(EExceptionConstraintType_to_string(EExceptionConstraintType::PreventHard) == "PreventHard");
      EXPECT(EExceptionConstraintType_to_string(EExceptionConstraintType::TriggerHard) == "TriggerHard");
      EXPECT(EExceptionConstraintType_to_string(EExceptionConstraintType::Invalid) == "Invalid");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EExceptionConstraintType("Allow") == EExceptionConstraintType::Allow);
      EXPECT(string_to_EExceptionConstraintType("Prevent") == EExceptionConstraintType::Prevent);
      EXPECT(string_to_EExceptionConstraintType("Trigger") == EExceptionConstraintType::Trigger);
      EXPECT(string_to_EExceptionConstraintType("PreventHard") == EExceptionConstraintType::PreventHard);
      EXPECT(string_to_EExceptionConstraintType("TriggerHard") == EExceptionConstraintType::TriggerHard);
      EXPECT(string_to_EExceptionConstraintType("Invalid") == EExceptionConstraintType::Invalid);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EExceptionConstraintType("A_low"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EExceptionConstraintType("Allow", okay) == EExceptionConstraintType::Allow);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionConstraintType("Prevent", okay) == EExceptionConstraintType::Prevent);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionConstraintType("Trigger", okay) == EExceptionConstraintType::Trigger);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionConstraintType("PreventHard", okay) == EExceptionConstraintType::PreventHard);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionConstraintType("TriggerHard", okay) == EExceptionConstraintType::TriggerHard);
      EXPECT(okay);
      EXPECT(try_string_to_EExceptionConstraintType("Invalid", okay) == EExceptionConstraintType::Invalid);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EExceptionConstraintType("A_low", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EPhysicalRegionType" ) {

  SETUP ( "setup EPhysicalRegionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EPhysicalRegionType_to_string(EPhysicalRegionType::HandlerMemory) == "HandlerMemory");
      EXPECT(EPhysicalRegionType_to_string(EPhysicalRegionType::ExceptionStack) == "ExceptionStack");
      EXPECT(EPhysicalRegionType_to_string(EPhysicalRegionType::PageTable) == "PageTable");
      EXPECT(EPhysicalRegionType_to_string(EPhysicalRegionType::BootRegion) == "BootRegion");
      EXPECT(EPhysicalRegionType_to_string(EPhysicalRegionType::AddressTable) == "AddressTable");
      EXPECT(EPhysicalRegionType_to_string(EPhysicalRegionType::ResetRegion) == "ResetRegion");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EPhysicalRegionType("HandlerMemory") == EPhysicalRegionType::HandlerMemory);
      EXPECT(string_to_EPhysicalRegionType("ExceptionStack") == EPhysicalRegionType::ExceptionStack);
      EXPECT(string_to_EPhysicalRegionType("PageTable") == EPhysicalRegionType::PageTable);
      EXPECT(string_to_EPhysicalRegionType("BootRegion") == EPhysicalRegionType::BootRegion);
      EXPECT(string_to_EPhysicalRegionType("AddressTable") == EPhysicalRegionType::AddressTable);
      EXPECT(string_to_EPhysicalRegionType("ResetRegion") == EPhysicalRegionType::ResetRegion);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EPhysicalRegionType("H_ndlerMemory"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EPhysicalRegionType("HandlerMemory", okay) == EPhysicalRegionType::HandlerMemory);
      EXPECT(okay);
      EXPECT(try_string_to_EPhysicalRegionType("ExceptionStack", okay) == EPhysicalRegionType::ExceptionStack);
      EXPECT(okay);
      EXPECT(try_string_to_EPhysicalRegionType("PageTable", okay) == EPhysicalRegionType::PageTable);
      EXPECT(okay);
      EXPECT(try_string_to_EPhysicalRegionType("BootRegion", okay) == EPhysicalRegionType::BootRegion);
      EXPECT(okay);
      EXPECT(try_string_to_EPhysicalRegionType("AddressTable", okay) == EPhysicalRegionType::AddressTable);
      EXPECT(okay);
      EXPECT(try_string_to_EPhysicalRegionType("ResetRegion", okay) == EPhysicalRegionType::ResetRegion);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EPhysicalRegionType("H_ndlerMemory", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EDataType" ) {

  SETUP ( "setup EDataType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EDataType_to_string(EDataType::INT8) == "INT8");
      EXPECT(EDataType_to_string(EDataType::INT16) == "INT16");
      EXPECT(EDataType_to_string(EDataType::INT32) == "INT32");
      EXPECT(EDataType_to_string(EDataType::INT64) == "INT64");
      EXPECT(EDataType_to_string(EDataType::FIX8) == "FIX8");
      EXPECT(EDataType_to_string(EDataType::FIX16) == "FIX16");
      EXPECT(EDataType_to_string(EDataType::FIX32) == "FIX32");
      EXPECT(EDataType_to_string(EDataType::FIX64) == "FIX64");
      EXPECT(EDataType_to_string(EDataType::FP8) == "FP8");
      EXPECT(EDataType_to_string(EDataType::FP16) == "FP16");
      EXPECT(EDataType_to_string(EDataType::FP32) == "FP32");
      EXPECT(EDataType_to_string(EDataType::FP64) == "FP64");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EDataType("INT8") == EDataType::INT8);
      EXPECT(string_to_EDataType("INT16") == EDataType::INT16);
      EXPECT(string_to_EDataType("INT32") == EDataType::INT32);
      EXPECT(string_to_EDataType("INT64") == EDataType::INT64);
      EXPECT(string_to_EDataType("FIX8") == EDataType::FIX8);
      EXPECT(string_to_EDataType("FIX16") == EDataType::FIX16);
      EXPECT(string_to_EDataType("FIX32") == EDataType::FIX32);
      EXPECT(string_to_EDataType("FIX64") == EDataType::FIX64);
      EXPECT(string_to_EDataType("FP8") == EDataType::FP8);
      EXPECT(string_to_EDataType("FP16") == EDataType::FP16);
      EXPECT(string_to_EDataType("FP32") == EDataType::FP32);
      EXPECT(string_to_EDataType("FP64") == EDataType::FP64);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EDataType("I_T8"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EDataType("INT8", okay) == EDataType::INT8);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("INT16", okay) == EDataType::INT16);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("INT32", okay) == EDataType::INT32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("INT64", okay) == EDataType::INT64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FIX8", okay) == EDataType::FIX8);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FIX16", okay) == EDataType::FIX16);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FIX32", okay) == EDataType::FIX32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FIX64", okay) == EDataType::FIX64);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FP8", okay) == EDataType::FP8);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FP16", okay) == EDataType::FP16);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FP32", okay) == EDataType::FP32);
      EXPECT(okay);
      EXPECT(try_string_to_EDataType("FP64", okay) == EDataType::FP64);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EDataType("I_T8", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EDumpType" ) {

  SETUP ( "setup EDumpType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EDumpType_to_string(EDumpType::Asm) == "Asm");
      EXPECT(EDumpType_to_string(EDumpType::Elf) == "Elf");
      EXPECT(EDumpType_to_string(EDumpType::Mem) == "Mem");
      EXPECT(EDumpType_to_string(EDumpType::Page) == "Page");
      EXPECT(EDumpType_to_string(EDumpType::FailOnly) == "FailOnly");
      EXPECT(EDumpType_to_string(EDumpType::Handlers) == "Handlers");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EDumpType("Asm") == EDumpType::Asm);
      EXPECT(string_to_EDumpType("Elf") == EDumpType::Elf);
      EXPECT(string_to_EDumpType("Mem") == EDumpType::Mem);
      EXPECT(string_to_EDumpType("Page") == EDumpType::Page);
      EXPECT(string_to_EDumpType("FailOnly") == EDumpType::FailOnly);
      EXPECT(string_to_EDumpType("Handlers") == EDumpType::Handlers);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EDumpType("A_m"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EDumpType("Asm", okay) == EDumpType::Asm);
      EXPECT(okay);
      EXPECT(try_string_to_EDumpType("Elf", okay) == EDumpType::Elf);
      EXPECT(okay);
      EXPECT(try_string_to_EDumpType("Mem", okay) == EDumpType::Mem);
      EXPECT(okay);
      EXPECT(try_string_to_EDumpType("Page", okay) == EDumpType::Page);
      EXPECT(okay);
      EXPECT(try_string_to_EDumpType("FailOnly", okay) == EDumpType::FailOnly);
      EXPECT(okay);
      EXPECT(try_string_to_EDumpType("Handlers", okay) == EDumpType::Handlers);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EDumpType("A_m", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EResourceType" ) {

  SETUP ( "setup EResourceType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EResourceType_to_string(EResourceType::GPR) == "GPR");
      EXPECT(EResourceType_to_string(EResourceType::FPR) == "FPR");
      EXPECT(EResourceType_to_string(EResourceType::PREDREG) == "PREDREG");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EResourceType("GPR") == EResourceType::GPR);
      EXPECT(string_to_EResourceType("FPR") == EResourceType::FPR);
      EXPECT(string_to_EResourceType("PREDREG") == EResourceType::PREDREG);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EResourceType("G_R"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EResourceType("GPR", okay) == EResourceType::GPR);
      EXPECT(okay);
      EXPECT(try_string_to_EResourceType("FPR", okay) == EResourceType::FPR);
      EXPECT(okay);
      EXPECT(try_string_to_EResourceType("PREDREG", okay) == EResourceType::PREDREG);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EResourceType("G_R", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EDependencyType" ) {

  SETUP ( "setup EDependencyType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EDependencyType_to_string(EDependencyType::OnSource) == "OnSource");
      EXPECT(EDependencyType_to_string(EDependencyType::OnTarget) == "OnTarget");
      EXPECT(EDependencyType_to_string(EDependencyType::NoDependency) == "NoDependency");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EDependencyType("OnSource") == EDependencyType::OnSource);
      EXPECT(string_to_EDependencyType("OnTarget") == EDependencyType::OnTarget);
      EXPECT(string_to_EDependencyType("NoDependency") == EDependencyType::NoDependency);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EDependencyType("O_Source"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EDependencyType("OnSource", okay) == EDependencyType::OnSource);
      EXPECT(okay);
      EXPECT(try_string_to_EDependencyType("OnTarget", okay) == EDependencyType::OnTarget);
      EXPECT(okay);
      EXPECT(try_string_to_EDependencyType("NoDependency", okay) == EDependencyType::NoDependency);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EDependencyType("O_Source", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EAccessAgeType" ) {

  SETUP ( "setup EAccessAgeType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EAccessAgeType_to_string(EAccessAgeType::Invalid) == "Invalid");
      EXPECT(EAccessAgeType_to_string(EAccessAgeType::Read) == "Read");
      EXPECT(EAccessAgeType_to_string(EAccessAgeType::Write) == "Write");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EAccessAgeType("Invalid") == EAccessAgeType::Invalid);
      EXPECT(string_to_EAccessAgeType("Read") == EAccessAgeType::Read);
      EXPECT(string_to_EAccessAgeType("Write") == EAccessAgeType::Write);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EAccessAgeType("I_valid"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EAccessAgeType("Invalid", okay) == EAccessAgeType::Invalid);
      EXPECT(okay);
      EXPECT(try_string_to_EAccessAgeType("Read", okay) == EAccessAgeType::Read);
      EXPECT(okay);
      EXPECT(try_string_to_EAccessAgeType("Write", okay) == EAccessAgeType::Write);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EAccessAgeType("I_valid", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EEntropyStateType" ) {

  SETUP ( "setup EEntropyStateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EEntropyStateType_to_string(EEntropyStateType::WarmUp) == "WarmUp");
      EXPECT(EEntropyStateType_to_string(EEntropyStateType::Stable) == "Stable");
      EXPECT(EEntropyStateType_to_string(EEntropyStateType::CoolDown) == "CoolDown");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EEntropyStateType("WarmUp") == EEntropyStateType::WarmUp);
      EXPECT(string_to_EEntropyStateType("Stable") == EEntropyStateType::Stable);
      EXPECT(string_to_EEntropyStateType("CoolDown") == EEntropyStateType::CoolDown);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EEntropyStateType("W_rmUp"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EEntropyStateType("WarmUp", okay) == EEntropyStateType::WarmUp);
      EXPECT(okay);
      EXPECT(try_string_to_EEntropyStateType("Stable", okay) == EEntropyStateType::Stable);
      EXPECT(okay);
      EXPECT(try_string_to_EEntropyStateType("CoolDown", okay) == EEntropyStateType::CoolDown);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EEntropyStateType("W_rmUp", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EVariableType" ) {

  SETUP ( "setup EVariableType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EVariableType_to_string(EVariableType::Choice) == "Choice");
      EXPECT(EVariableType_to_string(EVariableType::Value) == "Value");
      EXPECT(EVariableType_to_string(EVariableType::String) == "String");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EVariableType("Choice") == EVariableType::Choice);
      EXPECT(string_to_EVariableType("Value") == EVariableType::Value);
      EXPECT(string_to_EVariableType("String") == EVariableType::String);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EVariableType("C_oice"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EVariableType("Choice", okay) == EVariableType::Choice);
      EXPECT(okay);
      EXPECT(try_string_to_EVariableType("Value", okay) == EVariableType::Value);
      EXPECT(okay);
      EXPECT(try_string_to_EVariableType("String", okay) == EVariableType::String);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EVariableType("C_oice", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EAddressSolutionFilterType" ) {

  SETUP ( "setup EAddressSolutionFilterType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EAddressSolutionFilterType_to_string(EAddressSolutionFilterType::BaseDependency) == "BaseDependency");
      EXPECT(EAddressSolutionFilterType_to_string(EAddressSolutionFilterType::IndexDependency) == "IndexDependency");
      EXPECT(EAddressSolutionFilterType_to_string(EAddressSolutionFilterType::SpAlignment) == "SpAlignment");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EAddressSolutionFilterType("BaseDependency") == EAddressSolutionFilterType::BaseDependency);
      EXPECT(string_to_EAddressSolutionFilterType("IndexDependency") == EAddressSolutionFilterType::IndexDependency);
      EXPECT(string_to_EAddressSolutionFilterType("SpAlignment") == EAddressSolutionFilterType::SpAlignment);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EAddressSolutionFilterType("B_seDependency"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EAddressSolutionFilterType("BaseDependency", okay) == EAddressSolutionFilterType::BaseDependency);
      EXPECT(okay);
      EXPECT(try_string_to_EAddressSolutionFilterType("IndexDependency", okay) == EAddressSolutionFilterType::IndexDependency);
      EXPECT(okay);
      EXPECT(try_string_to_EAddressSolutionFilterType("SpAlignment", okay) == EAddressSolutionFilterType::SpAlignment);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EAddressSolutionFilterType("B_seDependency", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ECallBackTemplateType" ) {

  SETUP ( "setup ECallBackTemplateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ECallBackTemplateType_to_string(ECallBackTemplateType::SetBntSeq) == "SetBntSeq");
      EXPECT(ECallBackTemplateType_to_string(ECallBackTemplateType::RunBntSeq) == "RunBntSeq");
      EXPECT(ECallBackTemplateType_to_string(ECallBackTemplateType::SetEretPreambleSeq) == "SetEretPreambleSeq");
      EXPECT(ECallBackTemplateType_to_string(ECallBackTemplateType::RunEretPreambleSeq) == "RunEretPreambleSeq");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ECallBackTemplateType("SetBntSeq") == ECallBackTemplateType::SetBntSeq);
      EXPECT(string_to_ECallBackTemplateType("RunBntSeq") == ECallBackTemplateType::RunBntSeq);
      EXPECT(string_to_ECallBackTemplateType("SetEretPreambleSeq") == ECallBackTemplateType::SetEretPreambleSeq);
      EXPECT(string_to_ECallBackTemplateType("RunEretPreambleSeq") == ECallBackTemplateType::RunEretPreambleSeq);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ECallBackTemplateType("S_tBntSeq"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ECallBackTemplateType("SetBntSeq", okay) == ECallBackTemplateType::SetBntSeq);
      EXPECT(okay);
      EXPECT(try_string_to_ECallBackTemplateType("RunBntSeq", okay) == ECallBackTemplateType::RunBntSeq);
      EXPECT(okay);
      EXPECT(try_string_to_ECallBackTemplateType("SetEretPreambleSeq", okay) == ECallBackTemplateType::SetEretPreambleSeq);
      EXPECT(okay);
      EXPECT(try_string_to_ECallBackTemplateType("RunEretPreambleSeq", okay) == ECallBackTemplateType::RunEretPreambleSeq);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ECallBackTemplateType("S_tBntSeq", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ERegReserveType" ) {

  SETUP ( "setup ERegReserveType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ERegReserveType_to_string(ERegReserveType::User) == "User");
      EXPECT(ERegReserveType_to_string(ERegReserveType::Exception) == "Exception");
      EXPECT(ERegReserveType_to_string(ERegReserveType::Unpredictable) == "Unpredictable");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ERegReserveType("User") == ERegReserveType::User);
      EXPECT(string_to_ERegReserveType("Exception") == ERegReserveType::Exception);
      EXPECT(string_to_ERegReserveType("Unpredictable") == ERegReserveType::Unpredictable);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ERegReserveType("U_er"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ERegReserveType("User", okay) == ERegReserveType::User);
      EXPECT(okay);
      EXPECT(try_string_to_ERegReserveType("Exception", okay) == ERegReserveType::Exception);
      EXPECT(okay);
      EXPECT(try_string_to_ERegReserveType("Unpredictable", okay) == ERegReserveType::Unpredictable);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ERegReserveType("U_er", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EDataAlignedType" ) {

  SETUP ( "setup EDataAlignedType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EDataAlignedType_to_string(EDataAlignedType::SingleDataAligned) == "SingleDataAligned");
      EXPECT(EDataAlignedType_to_string(EDataAlignedType::Unaligned) == "Unaligned");
      EXPECT(EDataAlignedType_to_string(EDataAlignedType::WholeDataAligned) == "WholeDataAligned");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EDataAlignedType("SingleDataAligned") == EDataAlignedType::SingleDataAligned);
      EXPECT(string_to_EDataAlignedType("Unaligned") == EDataAlignedType::Unaligned);
      EXPECT(string_to_EDataAlignedType("WholeDataAligned") == EDataAlignedType::WholeDataAligned);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EDataAlignedType("S_ngleDataAligned"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EDataAlignedType("SingleDataAligned", okay) == EDataAlignedType::SingleDataAligned);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAlignedType("Unaligned", okay) == EDataAlignedType::Unaligned);
      EXPECT(okay);
      EXPECT(try_string_to_EDataAlignedType("WholeDataAligned", okay) == EDataAlignedType::WholeDataAligned);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EDataAlignedType("S_ngleDataAligned", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ESpeculativeBntActionType" ) {

  SETUP ( "setup ESpeculativeBntActionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ESpeculativeBntActionType_to_string(ESpeculativeBntActionType::Execute) == "Execute");
      EXPECT(ESpeculativeBntActionType_to_string(ESpeculativeBntActionType::Restore) == "Restore");
      EXPECT(ESpeculativeBntActionType_to_string(ESpeculativeBntActionType::Pop) == "Pop");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ESpeculativeBntActionType("Execute") == ESpeculativeBntActionType::Execute);
      EXPECT(string_to_ESpeculativeBntActionType("Restore") == ESpeculativeBntActionType::Restore);
      EXPECT(string_to_ESpeculativeBntActionType("Pop") == ESpeculativeBntActionType::Pop);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ESpeculativeBntActionType("E_ecute"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ESpeculativeBntActionType("Execute", okay) == ESpeculativeBntActionType::Execute);
      EXPECT(okay);
      EXPECT(try_string_to_ESpeculativeBntActionType("Restore", okay) == ESpeculativeBntActionType::Restore);
      EXPECT(okay);
      EXPECT(try_string_to_ESpeculativeBntActionType("Pop", okay) == ESpeculativeBntActionType::Pop);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ESpeculativeBntActionType("E_ecute", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EResourcePeStateType" ) {

  SETUP ( "setup EResourcePeStateType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EResourcePeStateType_to_string(EResourcePeStateType::RegisterPeState) == "RegisterPeState");
      EXPECT(EResourcePeStateType_to_string(EResourcePeStateType::MemoryPeState) == "MemoryPeState");
      EXPECT(EResourcePeStateType_to_string(EResourcePeStateType::DependencePeState) == "DependencePeState");
      EXPECT(EResourcePeStateType_to_string(EResourcePeStateType::ExceptionPeState) == "ExceptionPeState");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EResourcePeStateType("RegisterPeState") == EResourcePeStateType::RegisterPeState);
      EXPECT(string_to_EResourcePeStateType("MemoryPeState") == EResourcePeStateType::MemoryPeState);
      EXPECT(string_to_EResourcePeStateType("DependencePeState") == EResourcePeStateType::DependencePeState);
      EXPECT(string_to_EResourcePeStateType("ExceptionPeState") == EResourcePeStateType::ExceptionPeState);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EResourcePeStateType("R_gisterPeState"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EResourcePeStateType("RegisterPeState", okay) == EResourcePeStateType::RegisterPeState);
      EXPECT(okay);
      EXPECT(try_string_to_EResourcePeStateType("MemoryPeState", okay) == EResourcePeStateType::MemoryPeState);
      EXPECT(okay);
      EXPECT(try_string_to_EResourcePeStateType("DependencePeState", okay) == EResourcePeStateType::DependencePeState);
      EXPECT(okay);
      EXPECT(try_string_to_EResourcePeStateType("ExceptionPeState", okay) == EResourcePeStateType::ExceptionPeState);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EResourcePeStateType("R_gisterPeState", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EReloadingMethodType" ) {

  SETUP ( "setup EReloadingMethodType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EReloadingMethodType_to_string(EReloadingMethodType::Move) == "Move");
      EXPECT(EReloadingMethodType_to_string(EReloadingMethodType::Load) == "Load");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EReloadingMethodType("Move") == EReloadingMethodType::Move);
      EXPECT(string_to_EReloadingMethodType("Load") == EReloadingMethodType::Load);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EReloadingMethodType("M_ve"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EReloadingMethodType("Move", okay) == EReloadingMethodType::Move);
      EXPECT(okay);
      EXPECT(try_string_to_EReloadingMethodType("Load", okay) == EReloadingMethodType::Load);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EReloadingMethodType("M_ve", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ESpAlignedType" ) {

  SETUP ( "setup ESpAlignedType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ESpAlignedType_to_string(ESpAlignedType::Aligned) == "Aligned");
      EXPECT(ESpAlignedType_to_string(ESpAlignedType::Unaligned) == "Unaligned");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ESpAlignedType("Aligned") == ESpAlignedType::Aligned);
      EXPECT(string_to_ESpAlignedType("Unaligned") == ESpAlignedType::Unaligned);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ESpAlignedType("A_igned"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ESpAlignedType("Aligned", okay) == ESpAlignedType::Aligned);
      EXPECT(okay);
      EXPECT(try_string_to_ESpAlignedType("Unaligned", okay) == ESpAlignedType::Unaligned);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ESpAlignedType("A_igned", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ERestoreExclusionGroup" ) {

  SETUP ( "setup ERestoreExclusionGroup" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ERestoreExclusionGroup_to_string(ERestoreExclusionGroup::GPR) == "GPR");
      EXPECT(ERestoreExclusionGroup_to_string(ERestoreExclusionGroup::SIMDFP) == "SIMDFP");
      EXPECT(ERestoreExclusionGroup_to_string(ERestoreExclusionGroup::VECREG) == "VECREG");
      EXPECT(ERestoreExclusionGroup_to_string(ERestoreExclusionGroup::System) == "System");
      EXPECT(ERestoreExclusionGroup_to_string(ERestoreExclusionGroup::Memory) == "Memory");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ERestoreExclusionGroup("GPR") == ERestoreExclusionGroup::GPR);
      EXPECT(string_to_ERestoreExclusionGroup("SIMDFP") == ERestoreExclusionGroup::SIMDFP);
      EXPECT(string_to_ERestoreExclusionGroup("VECREG") == ERestoreExclusionGroup::VECREG);
      EXPECT(string_to_ERestoreExclusionGroup("System") == ERestoreExclusionGroup::System);
      EXPECT(string_to_ERestoreExclusionGroup("Memory") == ERestoreExclusionGroup::Memory);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ERestoreExclusionGroup("G_R"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ERestoreExclusionGroup("GPR", okay) == ERestoreExclusionGroup::GPR);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreExclusionGroup("SIMDFP", okay) == ERestoreExclusionGroup::SIMDFP);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreExclusionGroup("VECREG", okay) == ERestoreExclusionGroup::VECREG);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreExclusionGroup("System", okay) == ERestoreExclusionGroup::System);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreExclusionGroup("Memory", okay) == ERestoreExclusionGroup::Memory);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ERestoreExclusionGroup("G_R", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ESchedulingState" ) {

  SETUP ( "setup ESchedulingState" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ESchedulingState_to_string(ESchedulingState::Random) == "Random");
      EXPECT(ESchedulingState_to_string(ESchedulingState::Finishing) == "Finishing");
      EXPECT(ESchedulingState_to_string(ESchedulingState::Locked) == "Locked");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ESchedulingState("Random") == ESchedulingState::Random);
      EXPECT(string_to_ESchedulingState("Finishing") == ESchedulingState::Finishing);
      EXPECT(string_to_ESchedulingState("Locked") == ESchedulingState::Locked);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ESchedulingState("R_ndom"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ESchedulingState("Random", okay) == ESchedulingState::Random);
      EXPECT(okay);
      EXPECT(try_string_to_ESchedulingState("Finishing", okay) == ESchedulingState::Finishing);
      EXPECT(okay);
      EXPECT(try_string_to_ESchedulingState("Locked", okay) == ESchedulingState::Locked);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ESchedulingState("R_ndom", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ERestoreGroup" ) {

  SETUP ( "setup ERestoreGroup" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ERestoreGroup_to_string(ERestoreGroup::GPR) == "GPR");
      EXPECT(ERestoreGroup_to_string(ERestoreGroup::VECREG) == "VECREG");
      EXPECT(ERestoreGroup_to_string(ERestoreGroup::PREDREG) == "PREDREG");
      EXPECT(ERestoreGroup_to_string(ERestoreGroup::System) == "System");
      EXPECT(ERestoreGroup_to_string(ERestoreGroup::Memory) == "Memory");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ERestoreGroup("GPR") == ERestoreGroup::GPR);
      EXPECT(string_to_ERestoreGroup("VECREG") == ERestoreGroup::VECREG);
      EXPECT(string_to_ERestoreGroup("PREDREG") == ERestoreGroup::PREDREG);
      EXPECT(string_to_ERestoreGroup("System") == ERestoreGroup::System);
      EXPECT(string_to_ERestoreGroup("Memory") == ERestoreGroup::Memory);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ERestoreGroup("G_R"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ERestoreGroup("GPR", okay) == ERestoreGroup::GPR);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreGroup("VECREG", okay) == ERestoreGroup::VECREG);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreGroup("PREDREG", okay) == ERestoreGroup::PREDREG);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreGroup("System", okay) == ERestoreGroup::System);
      EXPECT(okay);
      EXPECT(try_string_to_ERestoreGroup("Memory", okay) == ERestoreGroup::Memory);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ERestoreGroup("G_R", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EPartitionThreadPolicy" ) {

  SETUP ( "setup EPartitionThreadPolicy" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EPartitionThreadPolicy_to_string(EPartitionThreadPolicy::Random) == "Random");
      EXPECT(EPartitionThreadPolicy_to_string(EPartitionThreadPolicy::SameCore) == "SameCore");
      EXPECT(EPartitionThreadPolicy_to_string(EPartitionThreadPolicy::SameChip) == "SameChip");
      EXPECT(EPartitionThreadPolicy_to_string(EPartitionThreadPolicy::DiffChip) == "DiffChip");
      EXPECT(EPartitionThreadPolicy_to_string(EPartitionThreadPolicy::DiffCore) == "DiffCore");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EPartitionThreadPolicy("Random") == EPartitionThreadPolicy::Random);
      EXPECT(string_to_EPartitionThreadPolicy("SameCore") == EPartitionThreadPolicy::SameCore);
      EXPECT(string_to_EPartitionThreadPolicy("SameChip") == EPartitionThreadPolicy::SameChip);
      EXPECT(string_to_EPartitionThreadPolicy("DiffChip") == EPartitionThreadPolicy::DiffChip);
      EXPECT(string_to_EPartitionThreadPolicy("DiffCore") == EPartitionThreadPolicy::DiffCore);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EPartitionThreadPolicy("R_ndom"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EPartitionThreadPolicy("Random", okay) == EPartitionThreadPolicy::Random);
      EXPECT(okay);
      EXPECT(try_string_to_EPartitionThreadPolicy("SameCore", okay) == EPartitionThreadPolicy::SameCore);
      EXPECT(okay);
      EXPECT(try_string_to_EPartitionThreadPolicy("SameChip", okay) == EPartitionThreadPolicy::SameChip);
      EXPECT(okay);
      EXPECT(try_string_to_EPartitionThreadPolicy("DiffChip", okay) == EPartitionThreadPolicy::DiffChip);
      EXPECT(okay);
      EXPECT(try_string_to_EPartitionThreadPolicy("DiffCore", okay) == EPartitionThreadPolicy::DiffCore);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EPartitionThreadPolicy("R_ndom", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for ELargeConstraintSetState" ) {

  SETUP ( "setup ELargeConstraintSetState" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(ELargeConstraintSetState_to_string(ELargeConstraintSetState::Clean) == "Clean");
      EXPECT(ELargeConstraintSetState_to_string(ELargeConstraintSetState::AddCached) == "AddCached");
      EXPECT(ELargeConstraintSetState_to_string(ELargeConstraintSetState::SubCached) == "SubCached");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_ELargeConstraintSetState("Clean") == ELargeConstraintSetState::Clean);
      EXPECT(string_to_ELargeConstraintSetState("AddCached") == ELargeConstraintSetState::AddCached);
      EXPECT(string_to_ELargeConstraintSetState("SubCached") == ELargeConstraintSetState::SubCached);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_ELargeConstraintSetState("C_ean"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_ELargeConstraintSetState("Clean", okay) == ELargeConstraintSetState::Clean);
      EXPECT(okay);
      EXPECT(try_string_to_ELargeConstraintSetState("AddCached", okay) == ELargeConstraintSetState::AddCached);
      EXPECT(okay);
      EXPECT(try_string_to_ELargeConstraintSetState("SubCached", okay) == ELargeConstraintSetState::SubCached);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_ELargeConstraintSetState("C_ean", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EAddressReuseType" ) {

  SETUP ( "setup EAddressReuseType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EAddressReuseType_to_string(EAddressReuseType::ReadAfterRead) == "ReadAfterRead");
      EXPECT(EAddressReuseType_to_string(EAddressReuseType::ReadAfterWrite) == "ReadAfterWrite");
      EXPECT(EAddressReuseType_to_string(EAddressReuseType::WriteAfterRead) == "WriteAfterRead");
      EXPECT(EAddressReuseType_to_string(EAddressReuseType::WriteAfterWrite) == "WriteAfterWrite");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EAddressReuseType("ReadAfterRead") == EAddressReuseType::ReadAfterRead);
      EXPECT(string_to_EAddressReuseType("ReadAfterWrite") == EAddressReuseType::ReadAfterWrite);
      EXPECT(string_to_EAddressReuseType("WriteAfterRead") == EAddressReuseType::WriteAfterRead);
      EXPECT(string_to_EAddressReuseType("WriteAfterWrite") == EAddressReuseType::WriteAfterWrite);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EAddressReuseType("R_adAfterRead"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EAddressReuseType("ReadAfterRead", okay) == EAddressReuseType::ReadAfterRead);
      EXPECT(okay);
      EXPECT(try_string_to_EAddressReuseType("ReadAfterWrite", okay) == EAddressReuseType::ReadAfterWrite);
      EXPECT(okay);
      EXPECT(try_string_to_EAddressReuseType("WriteAfterRead", okay) == EAddressReuseType::WriteAfterRead);
      EXPECT(okay);
      EXPECT(try_string_to_EAddressReuseType("WriteAfterWrite", okay) == EAddressReuseType::WriteAfterWrite);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EAddressReuseType("R_adAfterRead", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EStateElementDuplicateMode" ) {

  SETUP ( "setup EStateElementDuplicateMode" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EStateElementDuplicateMode_to_string(EStateElementDuplicateMode::Fail) == "Fail");
      EXPECT(EStateElementDuplicateMode_to_string(EStateElementDuplicateMode::Replace) == "Replace");
      EXPECT(EStateElementDuplicateMode_to_string(EStateElementDuplicateMode::Ignore) == "Ignore");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EStateElementDuplicateMode("Fail") == EStateElementDuplicateMode::Fail);
      EXPECT(string_to_EStateElementDuplicateMode("Replace") == EStateElementDuplicateMode::Replace);
      EXPECT(string_to_EStateElementDuplicateMode("Ignore") == EStateElementDuplicateMode::Ignore);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EStateElementDuplicateMode("F_il"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EStateElementDuplicateMode("Fail", okay) == EStateElementDuplicateMode::Fail);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementDuplicateMode("Replace", okay) == EStateElementDuplicateMode::Replace);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementDuplicateMode("Ignore", okay) == EStateElementDuplicateMode::Ignore);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EStateElementDuplicateMode("F_il", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EStateTransitionType" ) {

  SETUP ( "setup EStateTransitionType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EStateTransitionType_to_string(EStateTransitionType::Boot) == "Boot");
      EXPECT(EStateTransitionType_to_string(EStateTransitionType::Explicit) == "Explicit");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EStateTransitionType("Boot") == EStateTransitionType::Boot);
      EXPECT(string_to_EStateTransitionType("Explicit") == EStateTransitionType::Explicit);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EStateTransitionType("B_ot"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EStateTransitionType("Boot", okay) == EStateTransitionType::Boot);
      EXPECT(okay);
      EXPECT(try_string_to_EStateTransitionType("Explicit", okay) == EStateTransitionType::Explicit);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EStateTransitionType("B_ot", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EStateTransitionOrderMode" ) {

  SETUP ( "setup EStateTransitionOrderMode" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EStateTransitionOrderMode_to_string(EStateTransitionOrderMode::UseDefault) == "UseDefault");
      EXPECT(EStateTransitionOrderMode_to_string(EStateTransitionOrderMode::AsSpecified) == "AsSpecified");
      EXPECT(EStateTransitionOrderMode_to_string(EStateTransitionOrderMode::ByStateElementType) == "ByStateElementType");
      EXPECT(EStateTransitionOrderMode_to_string(EStateTransitionOrderMode::ByPriority) == "ByPriority");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EStateTransitionOrderMode("UseDefault") == EStateTransitionOrderMode::UseDefault);
      EXPECT(string_to_EStateTransitionOrderMode("AsSpecified") == EStateTransitionOrderMode::AsSpecified);
      EXPECT(string_to_EStateTransitionOrderMode("ByStateElementType") == EStateTransitionOrderMode::ByStateElementType);
      EXPECT(string_to_EStateTransitionOrderMode("ByPriority") == EStateTransitionOrderMode::ByPriority);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EStateTransitionOrderMode("U_eDefault"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EStateTransitionOrderMode("UseDefault", okay) == EStateTransitionOrderMode::UseDefault);
      EXPECT(okay);
      EXPECT(try_string_to_EStateTransitionOrderMode("AsSpecified", okay) == EStateTransitionOrderMode::AsSpecified);
      EXPECT(okay);
      EXPECT(try_string_to_EStateTransitionOrderMode("ByStateElementType", okay) == EStateTransitionOrderMode::ByStateElementType);
      EXPECT(okay);
      EXPECT(try_string_to_EStateTransitionOrderMode("ByPriority", okay) == EStateTransitionOrderMode::ByPriority);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EStateTransitionOrderMode("U_eDefault", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EStateElementType" ) {

  SETUP ( "setup EStateElementType" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EStateElementType_to_string(EStateElementType::Memory) == "Memory");
      EXPECT(EStateElementType_to_string(EStateElementType::SystemRegister) == "SystemRegister");
      EXPECT(EStateElementType_to_string(EStateElementType::VectorRegister) == "VectorRegister");
      EXPECT(EStateElementType_to_string(EStateElementType::GPR) == "GPR");
      EXPECT(EStateElementType_to_string(EStateElementType::VmContext) == "VmContext");
      EXPECT(EStateElementType_to_string(EStateElementType::PrivilegeLevel) == "PrivilegeLevel");
      EXPECT(EStateElementType_to_string(EStateElementType::PC) == "PC");
      EXPECT(EStateElementType_to_string(EStateElementType::FloatingPointRegister) == "FloatingPointRegister");
      EXPECT(EStateElementType_to_string(EStateElementType::PredicateRegister) == "PredicateRegister");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EStateElementType("Memory") == EStateElementType::Memory);
      EXPECT(string_to_EStateElementType("SystemRegister") == EStateElementType::SystemRegister);
      EXPECT(string_to_EStateElementType("VectorRegister") == EStateElementType::VectorRegister);
      EXPECT(string_to_EStateElementType("GPR") == EStateElementType::GPR);
      EXPECT(string_to_EStateElementType("VmContext") == EStateElementType::VmContext);
      EXPECT(string_to_EStateElementType("PrivilegeLevel") == EStateElementType::PrivilegeLevel);
      EXPECT(string_to_EStateElementType("PC") == EStateElementType::PC);
      EXPECT(string_to_EStateElementType("FloatingPointRegister") == EStateElementType::FloatingPointRegister);
      EXPECT(string_to_EStateElementType("PredicateRegister") == EStateElementType::PredicateRegister);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EStateElementType("M_mory"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EStateElementType("Memory", okay) == EStateElementType::Memory);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("SystemRegister", okay) == EStateElementType::SystemRegister);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("VectorRegister", okay) == EStateElementType::VectorRegister);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("GPR", okay) == EStateElementType::GPR);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("VmContext", okay) == EStateElementType::VmContext);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("PrivilegeLevel", okay) == EStateElementType::PrivilegeLevel);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("PC", okay) == EStateElementType::PC);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("FloatingPointRegister", okay) == EStateElementType::FloatingPointRegister);
      EXPECT(okay);
      EXPECT(try_string_to_EStateElementType("PredicateRegister", okay) == EStateElementType::PredicateRegister);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EStateElementType("M_mory", okay);
      EXPECT(!okay);
    }
  }
},


CASE( "tests for EEndianness" ) {

  SETUP ( "setup EEndianness" )  {

    SECTION( "test enum to string conversion" ) {
      EXPECT(EEndianness_to_string(EEndianness::LittleEndian) == "LittleEndian");
      EXPECT(EEndianness_to_string(EEndianness::BigEndian) == "BigEndian");
    }

    SECTION( "test string to enum conversion" ) {
      EXPECT(string_to_EEndianness("LittleEndian") == EEndianness::LittleEndian);
      EXPECT(string_to_EEndianness("BigEndian") == EEndianness::BigEndian);
    }

    SECTION( "test string to enum conversion with non-matching string" ) {
      EXPECT_THROWS_AS(string_to_EEndianness("L_ttleEndian"), EnumTypeError);
    }

    SECTION( "test non-throwing string to enum conversion" ) {
      bool okay = false;
      EXPECT(try_string_to_EEndianness("LittleEndian", okay) == EEndianness::LittleEndian);
      EXPECT(okay);
      EXPECT(try_string_to_EEndianness("BigEndian", okay) == EEndianness::BigEndian);
      EXPECT(okay);
    }

    SECTION( "test non-throwing string to enum conversion with non-matching string" ) {
      bool okay = false;
      try_string_to_EEndianness("L_ttleEndian", okay);
      EXPECT(!okay);
    }
  }
},

};

int main(int argc, char* argv[])
{
  Logger::Initialize();
  int ret = lest::run(specification, argc, argv);
  Logger::Destroy();
  return ret;
}
