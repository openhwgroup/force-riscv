From a6701bb633a789071dbc9258f7f68e461af5b98c Mon Sep 17 00:00:00 2001
From: "binguang.zhao" <binguang.zhao@linux.alibaba.com>
Date: Fri, 8 Jul 2022 08:47:21 +0000
Subject: [PATCH] feature added:handcar from force-riscv project; cmake build
 system ready

Author:    binguang.zhao <binguang.zhao@linux.alibaba.com>
Date:      Fri Jul 8 08:47:21 2022 +0000

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 00000000..5baec9e4
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,169 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(handcar_cosim VERSION 1.1.0)
+
+include(CTest)
+enable_testing()
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+# cmake install path
+if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
+  message(STATUS "Setting default CMAKE_INSTALL_PREFIX path to ${PROJECT_SOURCE_DIR}")
+  set(CMAKE_INSTALL_PREFIX "${PROJECT_SOURCE_DIR}" CACHE STRING "The path to use for make install" FORCE)
+endif()
+
+# depends
+find_package(Boost 1.53 COMPONENTS Asio regex)
+if (NOT Boost_FOUND)
+  message("Not found Boost")
+endif()
+
+#--------------------------------------
+# config file
+set(DEFAULT_ISA "RV64IMAFDC" CACHE STRING "Default value for --isa switch" FORCE)
+set(DEFAULT_PRIV "MSU" CACHE STRING "Default value for --priv switch" FORCE)
+set(DEFAULT_VARCH "vlen:128,elen:64" CACHE STRING "Default value for --varch switch" FORCE)
+set(TARGET_ARCH "riscv64-unknown-elf" CACHE STRING "Default value for --target switch" FORCE)
+option(ENABLE_COMMITLOG "Enable commit log generation" OFF)
+if (ENABLE_COMMITLOG)
+    set(RISCV_ENABLE_COMMITLOG)
+endif()
+option(ENABLE_HISTOGRAM "Enable PC histogram generation" OFF)
+if (ENABLE_HISTOGRAM)
+    set(RISCV_ENABLE_HISTOGRAM)
+endif()
+option(ENABLE_DIRTY "Enable hardware management of PTE accessed and dirty bits" OFF)
+if (ENABLE_DIRTY)
+    set(RISCV_ENABLE_DIRTY)
+endif()
+option(ENABLE_MISALIGNED "Enable hardware support for misaligned loads and stores" OFF)
+if (ENABLE_MISALIGNED)
+    set(RISCV_ENABLE_MISALIGNED)
+endif()
+option(ENABLE_DUAL_ENDIAN "Enable support for running target in either endianness" OFF)
+if (ENABLE_MISALIGNED)
+    set(RISCV_ENABLE_DUAL_ENDIAN)
+endif()
+if (DEFINED CMAKE_DL_LIBS)
+    set(HAVE_DLOPEN TRUE CACHE BOOL "Dynamic library loading is supported" FORCE)
+endif()
+find_package(Threads REQUIRED)
+if (Threads_FOUND)
+    set(HAVE_LIBPTHREAD TRUE CACHE BOOL "libpthread is required" FORCE)
+endif()
+
+set(SOFTFLOAT_ENABLED TRUE CACHE BOOL "softflat is enabled" FORCE)
+set(SPIKE_DASM_ENABLED TRUE CACHE BOOL "spike dasm is enabled" FORCE)
+set(SPIKE_MAIN_ENABLED TRUE CACHE BOOL "spike main is enabled" FORCE)
+set(RISCV_ENABLED TRUE CACHE BOOL "riscv is enabled" FORCE)
+
+# header check
+macro(CHECK_INCLUDE_FILE_ERROR INCLUDE_FILE HAVE_FILE)
+    CHECK_INCLUDE_FILE(${INCLUDE_FILE} ${HAVE_FILE})
+    IF(NOT ${HAVE_FILE})
+        UNSET(HAVE_FILE CACHE)
+        message( FATAL_ERROR "${INCLUDE_FILE} is not found" )
+    ENDIF()
+endmacro()
+CHECK_INCLUDE_FILE_ERROR("strings.h" HAVE_STRINGS_H)
+CHECK_INCLUDE_FILE_ERROR("string.h" HAVE_STRING_H)
+CHECK_INCLUDE_FILE_ERROR("memory.h" HAVE_MEMORY_H)
+CHECK_INCLUDE_FILE_ERROR("inttypes.h" HAVE_INTTYPES_H)
+CHECK_INCLUDE_FILE_ERROR("stdint.h" HAVE_STDINT_H)
+CHECK_INCLUDE_FILE_ERROR("stdlib.h" HAVE_STDLIB_H)
+CHECK_INCLUDE_FILE_ERROR("unistd.h" HAVE_UNISTD_H)
+CHECK_INCLUDE_FILE_ERROR("sys/stat.h" HAVE_SYS_STAT_H)
+CHECK_INCLUDE_FILE_ERROR("sys/types.h" HAVE_SYS_TYPES_H)
+#TODO: fix following options
+include(CheckStructHasMember)
+CHECK_STRUCT_HAS_MEMBER("struct statx" st_ino sys/stat.h HAVE_STATX)
+CHECK_STRUCT_HAS_MEMBER("struct statx" st_mnt_id sys/stat.h HAVE_STATX_MNT_ID)
+#TODO: fix following options
+set(STDC_HEADERS TRUE CACHE BOOL "stdc headers exists" FORCE)
+# set(HAVE_STATX TRUE CACHE BOOL "Define to 1 if struct statx exists." FORCE)
+# set(HAVE_STATX_MNT_ID TRUE CACHE BOOL "Define to 1 if struct statx has stx_mnt_id." FORCE)
+
+configure_file(${CMAKE_SOURCE_DIR}/config.h.in.cmake ${CMAKE_BINARY_DIR}/config.h)
+
+#------------------------
+include_directories(${CMAKE_SOURCE_DIR}
+                    ${CMAKE_SOURCE_DIR}/riscv
+                    ${CMAKE_SOURCE_DIR}/riscv/insns
+                    ${CMAKE_SOURCE_DIR}/fesvr
+                    ${CMAKE_SOURCE_DIR}/softfloat
+                    ${CMAKE_SOURCE_DIR}/force_mod
+                    ${CMAKE_SOURCE_DIR}/customext
+                    ${CMAKE_SOURCE_DIR}/disasm
+                    ${CMAKE_SOURCE_DIR}/fdt
+                    ${CMAKE_SOURCE_DIR}/spike_main
+                    ${CMAKE_BINARY_DIR})
+# other targets
+add_subdirectory(./disasm)
+add_subdirectory(./fdt)
+add_subdirectory(./fesvr)
+add_subdirectory(./force_mod)
+# add_subdirectory(./customext)
+add_subdirectory(./riscv)
+add_subdirectory(./softfloat)
+
+add_library(${PROJECT_NAME} SHARED ./spike_main/spike.cc)
+target_link_libraries(${PROJECT_NAME} riscv softfloat disasm fesvr force_mod)
+set_target_properties(${PROJECT_NAME} PROPERTIES PREFIX "")
+# Set the public header property to the one with the actual API.
+set_target_properties(${PROJECT_NAME} PROPERTIES PUBLIC_HEADER ./spike_main/handcar_cosim_wrapper.h)
+#--------------------------------------
+# custom cmd: 
+# . insns/*.h->insnc/*.cc
+# . generate insn_list.h
+include(CheckTypeSize)
+check_type_size("__int128_t" SIZEOF_INT128)
+if(${SIZEOF_INT128})
+    set(HAVE_INT128 TRUE CACHE BOOL "have int128" FORCE)
+else()
+    message(FATAL_ERROR "__int128_t is not supported!!!")
+endif()
+
+# get all ins
+file(GLOB INSN_SRCS "riscv/insns/*.h")
+list(FILTER INSN_SRCS EXCLUDE REGEX "aes_common.h")
+list(FILTER INSN_SRCS EXCLUDE REGEX "clmulhw.h")
+list(FILTER INSN_SRCS EXCLUDE REGEX "clmulrw.h")
+list(FILTER INSN_SRCS EXCLUDE REGEX "clmulw.h")
+list(FILTER INSN_SRCS EXCLUDE REGEX "sm4_common.h")
+list(FILTER INSN_SRCS EXCLUDE REGEX "vmvnfr_v.h")
+
+# insn_list.h
+foreach(insn_tmp IN LISTS INSN_SRCS)
+    get_filename_component(insn_name_tmp ${insn_tmp} NAME_WE)
+    string(APPEND ins_macro "DEFINE_INSN(${insn_name_tmp})\n")
+endforeach()
+file(WRITE "${CMAKE_BINARY_DIR}/riscv/insn_list.h" ${ins_macro})
+# {insn}.cc
+file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/riscv/insns)
+foreach(insn_tmp IN LISTS INSN_SRCS)
+    get_filename_component(insn_name_tmp ${insn_tmp} NAME_WE)
+    set(insn_cc ${CMAKE_BINARY_DIR}/riscv/insns/${insn_name_tmp}.cc)
+    add_custom_command(
+        OUTPUT ${insn_cc}
+        COMMAND ${CMAKE_SOURCE_DIR}/scripts/gen_src.sh ${insn_name_tmp} ${CMAKE_BINARY_DIR}/riscv/insns
+        DEPENDS ${CMAKE_SOURCE_DIR}/riscv/insns/${insn_name_tmp}.h
+        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/riscv
+        VERBATIM
+    )
+    target_sources(${PROJECT_NAME} PRIVATE ${insn_cc})
+endforeach()
\ No newline at end of file
diff --git a/config.h.in.cmake b/config.h.in.cmake
new file mode 100644
index 00000000..aed7b0ef
--- /dev/null
+++ b/config.h.in.cmake
@@ -0,0 +1,144 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* define if subproject MCPPBS_SPROJ_NORM is enabled */
+#define CUSTOMEXT_ENABLED /**/
+
+/* Default value for --isa switch */
+#cmakedefine DEFAULT_ISA "@DEFAULT_ISA@"
+
+/* Default value for --priv switch */
+#cmakedefine DEFAULT_PRIV "@DEFAULT_PRIV@"
+
+/* Default value for --varch switch */
+#cmakedefine DEFAULT_VARCH "@DEFAULT_VARCH@"
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine DISASM_ENABLED /**/
+
+/* Executable name of device-tree-compiler */
+#cmakedefine DTC "dtc"
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine FDT_ENABLED /**/
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine FESVR_ENABLED /**/
+
+/* cmakedefine if the Boost library is available */
+#cmakedefine HAVE_BOOST /**/
+
+/* cmakedefine if the Boost::ASIO library is available */
+#cmakedefine HAVE_BOOST_ASIO /**/
+
+/* Dynamic library loading is supported */
+#cmakedefine HAVE_DLOPEN /**/
+
+/* cmakedefine to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H 1
+
+/* cmakedefine to 1 if you have the `boost_regex' library (-lboost_regex). */
+#cmakedefine HAVE_LIBBOOST_REGEX 1
+
+/* cmakedefine to 1 if you have the `boost_system' library (-lboost_system). */
+#cmakedefine HAVE_LIBBOOST_SYSTEM 1
+
+/* cmakedefine to 1 if you have the `pthread' library (-lpthread). */
+#cmakedefine HAVE_LIBPTHREAD 1
+
+/* cmakedefine to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H 1
+
+/* cmakedefine to 1 if struct statx exists. */
+#cmakedefine HAVE_STATX
+
+/* cmakedefine to 1 if struct statx has stx_mnt_id. */
+#cmakedefine HAVE_STATX_MNT_ID
+
+/* cmakedefine to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H 1
+
+/* cmakedefine to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H 1
+
+/* cmakedefine to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H 1
+
+/* cmakedefine to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H 1
+
+/* cmakedefine to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H 1
+
+/* cmakedefine to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H 1
+
+/* cmakedefine to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H 1
+
+/* cmakedefine to the address where bug reports for this package should be sent. */
+#cmakedefine PACKAGE_BUGREPORT "Andrew Waterman"
+
+/* cmakedefine to the full name of this package. */
+#cmakedefine PACKAGE_NAME "RISC-V ISA Simulator"
+
+/* cmakedefine to the full name and version of this package. */
+#cmakedefine PACKAGE_STRING "RISC-V ISA Simulator ?"
+
+/* cmakedefine to the one symbol short name of this package. */
+#cmakedefine PACKAGE_TARNAME "spike"
+
+/* cmakedefine to the home page for this package. */
+#cmakedefine PACKAGE_URL ""
+
+/* cmakedefine to the version of this package. */
+#cmakedefine PACKAGE_VERSION "?"
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine RISCV_ENABLED /**/
+
+/* Enable commit log generation */
+#cmakedefine RISCV_ENABLE_COMMITLOG
+
+/* Enable hardware management of PTE accessed and dirty bits */
+#cmakedefine RISCV_ENABLE_DIRTY
+
+/* Enable support for running target in either endianness */
+#cmakedefine RISCV_ENABLE_DUAL_ENDIAN
+
+/* Enable PC histogram generation */
+#cmakedefine RISCV_ENABLE_HISTOGRAM
+
+/* Enable hardware support for misaligned loads and stores */
+#cmakedefine RISCV_ENABLE_MISALIGNED
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine SOFTFLOAT_ENABLED
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine SPIKE_DASM_ENABLED
+
+/* cmakedefine if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine SPIKE_MAIN_ENABLED
+
+/* cmakedefine to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS 1
+
+/* Default value for --with-target switch */
+#cmakedefine TARGET_ARCH "riscv64-unknown-elf"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
+
diff --git a/customext/CMakeLists.txt b/customext/CMakeLists.txt
new file mode 100644
index 00000000..19ca5dc9
--- /dev/null
+++ b/customext/CMakeLists.txt
@@ -0,0 +1,26 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(customext VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+set(CUSTOMEXT_SRCS 
+    ./dummy_rocc.cc
+    ./cflush.cc)
+
+add_library(${PROJECT_NAME} ${CUSTOMEXT_SRCS})
+target_include_directories(${PROJECT_NAME} PUBLIC ./)
\ No newline at end of file
diff --git a/disasm/CMakeLists.txt b/disasm/CMakeLists.txt
new file mode 100644
index 00000000..55f3dc3a
--- /dev/null
+++ b/disasm/CMakeLists.txt
@@ -0,0 +1,25 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(disasm VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+aux_source_directory(${PROJECT_SOURCE_DIR} DISASM_SRCS)
+
+# target
+add_library(${PROJECT_NAME} INTERFACE)
+target_sources(${PROJECT_NAME} INTERFACE ${DISASM_SRCS})
\ No newline at end of file
diff --git a/disasm/disasm.cc b/disasm/disasm.cc
index 4eb69709..1d6892fd 100644
--- a/disasm/disasm.cc
+++ b/disasm/disasm.cc
@@ -15,67 +15,67 @@ static const arg_t* opt = nullptr;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.i_imm()) + '(' + xpr_name[insn.rs1()] + ')';
+    return std::to_string((int)insn.i_imm()) + '(' + xpr_arch_name[insn.rs1()] + ')';
   }
 } load_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.s_imm()) + '(' + xpr_name[insn.rs1()] + ')';
+    return std::to_string((int)insn.s_imm()) + '(' + xpr_arch_name[insn.rs1()] + ')';
   }
 } store_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::string("(") + xpr_name[insn.rs1()] + ')';
+    return std::string("(") + xpr_arch_name[insn.rs1()] + ')';
   }
 } base_only_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rd()];
+    return xpr_arch_name[insn.rd()];
   }
 } xrd;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rs1()];
+    return xpr_arch_name[insn.rs1()];
   }
 } xrs1;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rs2()];
+    return xpr_arch_name[insn.rs2()];
   }
 } xrs2;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rs3()];
+    return xpr_arch_name[insn.rs3()];
   }
 } xrs3;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return fpr_name[insn.rd()];
+    return fpr_arch_name[insn.rd()];
   }
 } frd;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return fpr_name[insn.rs1()];
+    return fpr_arch_name[insn.rs1()];
   }
 } frs1;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return fpr_name[insn.rs2()];
+    return fpr_arch_name[insn.rs2()];
   }
 } frs2;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return fpr_name[insn.rs3()];
+    return fpr_arch_name[insn.rs3()];
   }
 } frs3;
 
@@ -144,43 +144,43 @@ struct : public arg_t {
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rvc_rs1()];
+    return xpr_arch_name[insn.rvc_rs1()];
   }
 } rvc_rs1;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rvc_rs2()];
+    return xpr_arch_name[insn.rvc_rs2()];
   }
 } rvc_rs2;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return fpr_name[insn.rvc_rs2()];
+    return fpr_arch_name[insn.rvc_rs2()];
   }
 } rvc_fp_rs2;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rvc_rs1s()];
+    return xpr_arch_name[insn.rvc_rs1s()];
   }
 } rvc_rs1s;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[insn.rvc_rs2s()];
+    return xpr_arch_name[insn.rvc_rs2s()];
   }
 } rvc_rs2s;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return fpr_name[insn.rvc_rs2s()];
+    return fpr_arch_name[insn.rvc_rs2s()];
   }
 } rvc_fp_rs2s;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return xpr_name[X_SP];
+    return xpr_arch_name[X_SP];
   }
 } rvc_sp;
 
@@ -224,37 +224,37 @@ struct : public arg_t {
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.rvc_lwsp_imm()) + '(' + xpr_name[X_SP] + ')';
+    return std::to_string((int)insn.rvc_lwsp_imm()) + '(' + xpr_arch_name[X_SP] + ')';
   }
 } rvc_lwsp_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.rvc_ldsp_imm()) + '(' + xpr_name[X_SP] + ')';
+    return std::to_string((int)insn.rvc_ldsp_imm()) + '(' + xpr_arch_name[X_SP] + ')';
   }
 } rvc_ldsp_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.rvc_swsp_imm()) + '(' + xpr_name[X_SP] + ')';
+    return std::to_string((int)insn.rvc_swsp_imm()) + '(' + xpr_arch_name[X_SP] + ')';
   }
 } rvc_swsp_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.rvc_sdsp_imm()) + '(' + xpr_name[X_SP] + ')';
+    return std::to_string((int)insn.rvc_sdsp_imm()) + '(' + xpr_arch_name[X_SP] + ')';
   }
 } rvc_sdsp_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.rvc_lw_imm()) + '(' + xpr_name[insn.rvc_rs1s()] + ')';
+    return std::to_string((int)insn.rvc_lw_imm()) + '(' + xpr_arch_name[insn.rvc_rs1s()] + ')';
   }
 } rvc_lw_address;
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::to_string((int)insn.rvc_ld_imm()) + '(' + xpr_name[insn.rvc_rs1s()] + ')';
+    return std::to_string((int)insn.rvc_ld_imm()) + '(' + xpr_arch_name[insn.rvc_rs1s()] + ')';
   }
 } rvc_ld_address;
 
@@ -280,7 +280,7 @@ struct : public arg_t {
 
 struct : public arg_t {
   std::string to_string(insn_t insn) const {
-    return std::string("(") + xpr_name[insn.rs1()] + ')';
+    return std::string("(") + xpr_arch_name[insn.rs1()] + ')';
   }
 } v_address;
 
diff --git a/disasm/regnames.cc b/disasm/regnames.cc
index 0a7fd4d2..19159abb 100644
--- a/disasm/regnames.cc
+++ b/disasm/regnames.cc
@@ -9,6 +9,13 @@ const char* xpr_name[] = {
   "s8",   "s9", "s10", "s11", "t3", "t4",  "t5",  "t6"
 };
 
+const char* xpr_arch_name[] = {
+  "x0", "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7", 
+  "x8",   "x9",  "x10", "x11", "x12", "x13", "x14", "x15",
+  "x16",  "x17", "x18", "x19", "x20", "x21", "x22", "x23",
+  "x24",  "x25", "x26", "x27", "x28", "x29", "x30", "x31"
+};
+
 const char* fpr_name[] = {
   "ft0", "ft1", "ft2",  "ft3",  "ft4", "ft5", "ft6",  "ft7",
   "fs0", "fs1", "fa0",  "fa1",  "fa2", "fa3", "fa4",  "fa5",
@@ -16,6 +23,13 @@ const char* fpr_name[] = {
   "fs8", "fs9", "fs10", "fs11", "ft8", "ft9", "ft10", "ft11"
 };
 
+const char* fpr_arch_name[] = {
+  "f0", "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
+  "f8",   "f9",  "f10", "f11", "f12", "f13", "f14", "f15",
+  "f16",  "f17", "f18", "f19", "f20", "f21", "f22", "f23",
+  "f24",  "f25", "f26", "f27", "f28", "f29", "f30", "f31"
+};
+
 const char* vr_name[] = {
   "v0",  "v1",  "v2",  "v3",  "v4",  "v5",  "v6",  "v7",
   "v8",  "v9",  "v10", "v11", "v12", "v13", "v14", "v15",
diff --git a/fdt/CMakeLists.txt b/fdt/CMakeLists.txt
new file mode 100644
index 00000000..84e14ca6
--- /dev/null
+++ b/fdt/CMakeLists.txt
@@ -0,0 +1,24 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(fdt VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+aux_source_directory(${PROJECT_SOURCE_DIR} FDT_SRCS)
+
+add_library(${PROJECT_NAME} INTERFACE)
+target_sources(${PROJECT_NAME} INTERFACE ${FDT_SRCS})
\ No newline at end of file
diff --git a/fesvr/CMakeLists.txt b/fesvr/CMakeLists.txt
new file mode 100644
index 00000000..799f480a
--- /dev/null
+++ b/fesvr/CMakeLists.txt
@@ -0,0 +1,40 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(fesvr VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+aux_source_directory(${PROJECT_SOURCE_DIR} FESVR_SRCS)
+list(REMOVE_ITEM FESVR_SRCS
+    ${PROJECT_SOURCE_DIR}/dtm.cc
+    ${PROJECT_SOURCE_DIR}/elf2hex.cc
+    ${PROJECT_SOURCE_DIR}/htif.cc
+    ${PROJECT_SOURCE_DIR}/htif_hexwriter.cc
+    ${PROJECT_SOURCE_DIR}/htif_pthread.cc
+    ${PROJECT_SOURCE_DIR}/syscall.cc
+    ${PROJECT_SOURCE_DIR}/term.cc
+    ${PROJECT_SOURCE_DIR}/tsi.cc
+)
+message("fesvr=${FESVR_SRCS}")
+
+# pthread
+find_package(Threads REQUIRED)
+
+# target
+add_library(${PROJECT_NAME} INTERFACE)
+target_sources(${PROJECT_NAME} INTERFACE ${FESVR_SRCS})
+target_link_libraries(${PROJECT_NAME} INTERFACE ${CMAKE_THREAD_LIBS_INIT})
\ No newline at end of file
diff --git a/force_mod/CMakeLists.txt b/force_mod/CMakeLists.txt
new file mode 100644
index 00000000..100f320b
--- /dev/null
+++ b/force_mod/CMakeLists.txt
@@ -0,0 +1,24 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(force_mod VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+aux_source_directory(${PROJECT_SOURCE_DIR} FORCE_MOD_SRCS)
+
+add_library(${PROJECT_NAME} INTERFACE)
+target_link_libraries(${PROJECT_NAME} INTERFACE ${FORCE_MOD_SRCS})
\ No newline at end of file
diff --git a/force_mod/Force_Defines.h b/force_mod/Force_Defines.h
new file mode 100644
index 00000000..d2b7dbc5
--- /dev/null
+++ b/force_mod/Force_Defines.h
@@ -0,0 +1,64 @@
+//
+// Copyright (C) [2020] Futurewei Technologies, Inc.
+//
+// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
+// FIT FOR A PARTICULAR PURPOSE.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#ifndef Force_Defines_H
+#define Force_Defines_H
+
+/*!
+  \namespace Force
+  \brief Application scope name space
+
+  Namespace for the FORCE ISG code.
+ */
+namespace Force {
+
+  typedef unsigned long long uint64;
+  typedef unsigned int uint32;
+  typedef unsigned char uint8;
+  typedef long long int64;
+  typedef signed int int32;
+  typedef signed char int8;
+
+  typedef const unsigned long long cuint64;
+  typedef const unsigned int cuint32;
+  typedef const unsigned char cuint8;
+  typedef const long long cint64;
+  typedef const signed int cint32;
+  typedef const signed char cint8;
+  typedef const bool cbool;
+
+#define MAX_UINT32 0xffffffff
+#define MAX_UINT64 0xffffffffffffffffULL
+#define MAX_ENUM_SIZE 100
+#define MAX_ASM_SIZE 128
+#define MAX_PAGE_TABLE_LEVEL 3
+
+#define ASSIGNMENT_OPERATOR_ABSENT(ClassName) ClassName& operator=(const ClassName&) = delete
+#define ASSIGNMENT_OPERATOR_DEFAULT(ClassName) ClassName& operator=(const ClassName&) = default
+#define COPY_CONSTRUCTOR_ABSENT(ClassName) ClassName(const ClassName&) = delete
+#define COPY_CONSTRUCTOR_DEFAULT(ClassName) ClassName(const ClassName&) = default
+#define DEFAULT_CONSTRUCTOR_ABSENT(ClassName) ClassName() = delete
+#define DEFAULT_CONSTRUCTOR_DEFAULT(ClassName) ClassName() = default
+#define DESTRUCTOR_DEFAULT(ClassName) ~ClassName() = default
+#define SUBCLASS_DESTRUCTOR_DEFAULT(ClassName) ~ClassName() override = default
+#define SUPERCLASS_DESTRUCTOR_DEFAULT(ClassName) virtual ~ClassName() = default
+#define PICKY_IGNORED _Pragma("GCC diagnostic ignored \"-Weffc++\"")
+#define PICKY_IGNORE_BLOCK_START _Pragma("GCC diagnostic push") \
+_Pragma("GCC diagnostic ignored \"-Weffc++\"")
+#define PICKY_IGNORE_BLOCK_END _Pragma("GCC diagnostic pop")
+}
+
+#endif
diff --git a/force_mod/Force_Enums.cc b/force_mod/Force_Enums.cc
new file mode 100644
index 00000000..80ec6f46
--- /dev/null
+++ b/force_mod/Force_Enums.cc
@@ -0,0 +1,354 @@
+//
+// Copyright (C) [2020] Futurewei Technologies, Inc.
+//
+// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
+// FIT FOR A PARTICULAR PURPOSE.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+/*  !!! NOTICE !!!
+    This file is automatically generated by the script: utils/enum_classes/create_enum_files.py
+    Please do not modify this file manually.  Instead, modify the above mentioned script to re-generate this file.
+*/
+
+#include "Force_Enums.h"
+#include <sstream>
+#include <iostream>
+#include <cassert>
+
+using namespace std;
+
+namespace Force {
+
+
+  /*!
+    Report an unknown enum value of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
+  */
+  static void unknown_enum_value(const string& enum_type_name, unsigned long long value)
+  {
+    stringstream err_stream;
+    err_stream << "Unknown " << enum_type_name << " enum value: " << dec << value;
+    assert(false && err_stream);
+    //throw EnumTypeError(err_stream.str());
+  }
+
+  /*!
+    Report an unknown enum name of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
+  */
+  static void unknown_enum_name(const string& enum_type_name, const string& enum_name)
+  {
+    stringstream err_stream;
+    err_stream << "Unknown " << enum_type_name << " enum name: " << enum_name;
+    assert(false && err_stream);
+    //throw EnumTypeError(err_stream.str());
+  }
+
+  /*!
+    Throw an exception if in_str and enum_name are not identical.
+  */
+  static void validate(const string& specified_enum_name, const string& expected_enum_name, const string& enum_type_name)
+  {
+    if (specified_enum_name != expected_enum_name) {
+      unknown_enum_name(enum_type_name, specified_enum_name);
+    }
+  }
+
+  unsigned char ELimitTypeSize = 12;
+
+  const string ELimitType_to_string(ELimitType in_enum)
+  {
+    switch(in_enum) {
+    case ELimitType::ThreadsLimit: return "ThreadsLimit";
+    case ELimitType::CoresLimit: return "CoresLimit";
+    case ELimitType::ChipsLimit: return "ChipsLimit";
+    case ELimitType::PhysicalAddressLimit: return "PhysicalAddressLimit";
+    case ELimitType::MaxInstructions: return "MaxInstructions";
+    case ELimitType::PerMonRegisterNumber: return "PerMonRegisterNumber";
+    case ELimitType::DependencyHistoryLimit: return "DependencyHistoryLimit";
+    case ELimitType::BranchNotTakenLimit: return "BranchNotTakenLimit";
+    case ELimitType::SpeculativeBntLevelLimit: return "SpeculativeBntLevelLimit";
+    case ELimitType::ErrRegisterNumber: return "ErrRegisterNumber";
+    case ELimitType::SpeculativeBntInstructionLimit: return "SpeculativeBntInstructionLimit";
+    default:
+      unknown_enum_value("ELimitType", (unsigned char)(in_enum));
+    }
+    return "";
+  }
+
+  ELimitType string_to_ELimitType(const string& in_str)
+  {
+    string enum_type_name = "ELimitType";
+    size_t size = in_str.size();
+    char hash_value = in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(20 < size ? 20 : 20 % size);
+
+    switch(hash_value) {
+    case 0:
+      validate(in_str, "BranchNotTakenLimit", enum_type_name);
+      return ELimitType::BranchNotTakenLimit;
+    case 1:
+      validate(in_str, "ThreadsLimit", enum_type_name);
+      return ELimitType::ThreadsLimit;
+    case 12:
+      validate(in_str, "DependencyHistoryLimit", enum_type_name);
+      return ELimitType::DependencyHistoryLimit;
+    case 18:
+      validate(in_str, "MaxInstructions", enum_type_name);
+      return ELimitType::MaxInstructions;
+    case 19:
+      validate(in_str, "SpeculativeBntInstructionLimit", enum_type_name);
+      return ELimitType::SpeculativeBntInstructionLimit;
+    case 25:
+      validate(in_str, "SpeculativeBntLevelLimit", enum_type_name);
+      return ELimitType::SpeculativeBntLevelLimit;
+    case 32:
+      validate(in_str, "ErrRegisterNumber", enum_type_name);
+      return ELimitType::ErrRegisterNumber;
+    case 43:
+      validate(in_str, "ChipsLimit", enum_type_name);
+      return ELimitType::ChipsLimit;
+    case 44:
+      validate(in_str, "CoresLimit", enum_type_name);
+      return ELimitType::CoresLimit;
+    case 53:
+      validate(in_str, "PerMonRegisterNumber", enum_type_name);
+      return ELimitType::PerMonRegisterNumber;
+    case 56:
+      validate(in_str, "PhysicalAddressLimit", enum_type_name);
+      return ELimitType::PhysicalAddressLimit;
+    default:
+      unknown_enum_name(enum_type_name, in_str);
+    }
+    return ELimitType::ThreadsLimit;
+  }
+
+  ELimitType try_string_to_ELimitType(const string& in_str, bool& okay)
+  {
+    okay = true;
+    size_t size = in_str.size();
+    char hash_value = in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(20 < size ? 20 : 20 % size);
+
+    switch(hash_value) {
+    case 0:
+      okay = (in_str == "BranchNotTakenLimit");
+      return ELimitType::BranchNotTakenLimit;
+    case 1:
+      okay = (in_str == "ThreadsLimit");
+      return ELimitType::ThreadsLimit;
+    case 12:
+      okay = (in_str == "DependencyHistoryLimit");
+      return ELimitType::DependencyHistoryLimit;
+    case 18:
+      okay = (in_str == "MaxInstructions");
+      return ELimitType::MaxInstructions;
+    case 19:
+      okay = (in_str == "SpeculativeBntInstructionLimit");
+      return ELimitType::SpeculativeBntInstructionLimit;
+    case 25:
+      okay = (in_str == "SpeculativeBntLevelLimit");
+      return ELimitType::SpeculativeBntLevelLimit;
+    case 32:
+      okay = (in_str == "ErrRegisterNumber");
+      return ELimitType::ErrRegisterNumber;
+    case 43:
+      okay = (in_str == "ChipsLimit");
+      return ELimitType::ChipsLimit;
+    case 44:
+      okay = (in_str == "CoresLimit");
+      return ELimitType::CoresLimit;
+    case 53:
+      okay = (in_str == "PerMonRegisterNumber");
+      return ELimitType::PerMonRegisterNumber;
+    case 56:
+      okay = (in_str == "PhysicalAddressLimit");
+      return ELimitType::PhysicalAddressLimit;
+    default:
+      okay = false;
+      return ELimitType::ThreadsLimit;
+    }
+    return ELimitType::ThreadsLimit;
+  }
+
+  unsigned char EMemDataTypeSize = 4;
+
+  const string EMemDataType_to_string(EMemDataType in_enum)
+  {
+    switch(in_enum) {
+    case EMemDataType::Init: return "Init";
+    case EMemDataType::Instruction: return "Instruction";
+    case EMemDataType::Data: return "Data";
+    case EMemDataType::Both: return "Both";
+    default:
+      unknown_enum_value("EMemDataType", (unsigned char)(in_enum));
+    }
+    return "";
+  }
+
+  EMemDataType string_to_EMemDataType(const string& in_str)
+  {
+    string enum_type_name = "EMemDataType";
+    size_t size = in_str.size();
+    char hash_value = in_str.at(4 < size ? 4 : 4 % size);
+
+    switch(hash_value) {
+    case 66:
+      validate(in_str, "Both", enum_type_name);
+      return EMemDataType::Both;
+    case 68:
+      validate(in_str, "Data", enum_type_name);
+      return EMemDataType::Data;
+    case 73:
+      validate(in_str, "Init", enum_type_name);
+      return EMemDataType::Init;
+    case 114:
+      validate(in_str, "Instruction", enum_type_name);
+      return EMemDataType::Instruction;
+    default:
+      unknown_enum_name(enum_type_name, in_str);
+    }
+    return EMemDataType::Init;
+  }
+
+  EMemDataType try_string_to_EMemDataType(const string& in_str, bool& okay)
+  {
+    okay = true;
+    size_t size = in_str.size();
+    char hash_value = in_str.at(4 < size ? 4 : 4 % size);
+
+    switch(hash_value) {
+    case 66:
+      okay = (in_str == "Both");
+      return EMemDataType::Both;
+    case 68:
+      okay = (in_str == "Data");
+      return EMemDataType::Data;
+    case 73:
+      okay = (in_str == "Init");
+      return EMemDataType::Init;
+    case 114:
+      okay = (in_str == "Instruction");
+      return EMemDataType::Instruction;
+    default:
+      okay = false;
+      return EMemDataType::Init;
+    }
+    return EMemDataType::Init;
+  }
+
+  unsigned char EMemAccessTypeSize = 4;
+
+  const string EMemAccessType_to_string(EMemAccessType in_enum)
+  {
+    switch(in_enum) {
+    case EMemAccessType::Unknown: return "Unknown";
+    case EMemAccessType::Read: return "Read";
+    case EMemAccessType::Write: return "Write";
+    case EMemAccessType::ReadWrite: return "ReadWrite";
+    default:
+      unknown_enum_value("EMemAccessType", (unsigned char)(in_enum));
+    }
+    return "";
+  }
+
+  EMemAccessType string_to_EMemAccessType(const string& in_str)
+  {
+    string enum_type_name = "EMemAccessType";
+    size_t size = in_str.size();
+    char hash_value = in_str.at(4 < size ? 4 : 4 % size);
+
+    switch(hash_value) {
+    case 82:
+      validate(in_str, "Read", enum_type_name);
+      return EMemAccessType::Read;
+    case 87:
+      validate(in_str, "ReadWrite", enum_type_name);
+      return EMemAccessType::ReadWrite;
+    case 101:
+      validate(in_str, "Write", enum_type_name);
+      return EMemAccessType::Write;
+    case 111:
+      validate(in_str, "Unknown", enum_type_name);
+      return EMemAccessType::Unknown;
+    default:
+      unknown_enum_name(enum_type_name, in_str);
+    }
+    return EMemAccessType::Unknown;
+  }
+
+  EMemAccessType try_string_to_EMemAccessType(const string& in_str, bool& okay)
+  {
+    okay = true;
+    size_t size = in_str.size();
+    char hash_value = in_str.at(4 < size ? 4 : 4 % size);
+
+    switch(hash_value) {
+    case 82:
+      okay = (in_str == "Read");
+      return EMemAccessType::Read;
+    case 87:
+      okay = (in_str == "ReadWrite");
+      return EMemAccessType::ReadWrite;
+    case 101:
+      okay = (in_str == "Write");
+      return EMemAccessType::Write;
+    case 111:
+      okay = (in_str == "Unknown");
+      return EMemAccessType::Unknown;
+    default:
+      okay = false;
+      return EMemAccessType::Unknown;
+    }
+    return EMemAccessType::Unknown;
+  }
+
+  unsigned char EMemBankTypeSize = 1;
+
+  const string EMemBankType_to_string(EMemBankType in_enum)
+  {
+    switch (in_enum) {
+    case EMemBankType::Default: return "Default";
+    default:
+      unknown_enum_value("EMemBankType", (unsigned char)(in_enum));
+    }
+    return "";
+  }
+
+  EMemBankType string_to_EMemBankType(const string& in_str)
+  {
+    string enum_type_name = "EMemBankType";
+    char hash_value = in_str.at(0);
+
+    switch (hash_value) {
+    case 68:
+      validate(in_str, "Default", enum_type_name);
+      return EMemBankType::Default;
+    default:
+      unknown_enum_name(enum_type_name, in_str);
+    }
+    return EMemBankType::Default;
+  }
+
+  EMemBankType try_string_to_EMemBankType(const string& in_str, bool& okay)
+  {
+    okay = true;
+    char hash_value = in_str.at(0);
+
+    switch (hash_value) {
+    case 68:
+      okay = (in_str == "Default");
+      return EMemBankType::Default;
+    default:
+      okay = false;
+      return EMemBankType::Default;
+    }
+    return EMemBankType::Default;
+  }
+
+}
diff --git a/force_mod/Force_Enums.h b/force_mod/Force_Enums.h
new file mode 100644
index 00000000..0042f2c7
--- /dev/null
+++ b/force_mod/Force_Enums.h
@@ -0,0 +1,96 @@
+//
+// Copyright (C) [2020] Futurewei Technologies, Inc.
+//
+// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
+// FIT FOR A PARTICULAR PURPOSE.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+/*  !!! NOTICE !!!
+    This file is automatically generated by the script: utils/enum_classes/create_enum_files.py
+    Please do not modify this file manually.  Instead, modify the above mentioned script to re-generate this file.
+*/
+
+#ifndef Force_Enums_H
+#define Force_Enums_H
+
+#include <string>
+
+namespace Force {
+
+  /*!
+    Various limitation values
+  */
+  enum class ELimitType : unsigned char {
+    ThreadsLimit = 0,
+    CoresLimit = 1,
+    ChipsLimit = 2,
+    PhysicalAddressLimit = 3,
+    MaxInstructions = 4,
+    PerMonRegisterNumber = 5,
+    DependencyHistoryLimit = 6,
+    BranchNotTakenLimit = 7,
+    SpeculativeBntLevelLimit = 8,
+    ErrRegisterNumber = 9,
+    SpeculativeBntInstructionLimit = 10,
+  };
+  extern unsigned char ELimitTypeSize;
+  extern const std::string ELimitType_to_string(ELimitType in_enum); //!< Get string name for enum.
+  extern ELimitType string_to_ELimitType(const std::string& in_str); //!< Get enum value for string name.
+  extern ELimitType try_string_to_ELimitType(const std::string& in_str, bool& okay); //!< Try to get enum value for string name, set status to indicate if conversion successful. Return value is indeterminate on failure.
+  typedef unsigned char ELimitTypeBaseType; //!< Define a type name for the enum base data type.
+
+
+  /*!
+    Memory data types in memory model
+  */
+  enum class EMemDataType : unsigned char {
+    Init = 1,
+    Instruction = 2,
+    Data = 4,
+    Both = 6,
+  };
+  extern unsigned char EMemDataTypeSize;
+  extern const std::string EMemDataType_to_string(EMemDataType in_enum); //!< Get string name for enum.
+  extern EMemDataType string_to_EMemDataType(const std::string& in_str); //!< Get enum value for string name.
+  extern EMemDataType try_string_to_EMemDataType(const std::string& in_str, bool& okay); //!< Try to get enum value for string name, set status to indicate if conversion successful. Return value is indeterminate on failure.
+  typedef unsigned char EMemDataTypeBaseType; //!< Define a type name for the enum base data type.
+
+  /*!
+    Memory access types
+  */
+  enum class EMemAccessType : unsigned char {
+    Unknown = 0,
+    Read = 1,
+    Write = 2,
+    ReadWrite = 3,
+  };
+  extern unsigned char EMemAccessTypeSize;
+  extern const std::string EMemAccessType_to_string(EMemAccessType in_enum); //!< Get string name for enum.
+  extern EMemAccessType string_to_EMemAccessType(const std::string& in_str); //!< Get enum value for string name.
+  extern EMemAccessType try_string_to_EMemAccessType(const std::string& in_str, bool& okay); //!< Try to get enum value for string name, set status to indicate if conversion successful. Return value is indeterminate on failure.
+  typedef unsigned char EMemAccessTypeBaseType; //!< Define a type name for the enum base data type.
+
+  /*!
+    Memory bank types
+  */
+  enum class EMemBankType : unsigned char {
+    Default = 0,
+  };
+  extern unsigned char EMemBankTypeSize;
+  extern const std::string EMemBankType_to_string(EMemBankType in_enum); //!< Get string name for enum.
+  extern EMemBankType string_to_EMemBankType(const std::string& in_str); //!< Get enum value for string name.
+  extern EMemBankType try_string_to_EMemBankType(const std::string& in_str, bool& okay); //!< Try to get enum value for string name, set status to indicate if conversion successful. Return value is indeterminate on failure.
+  typedef unsigned char EMemBankTypeBaseType; //!< Define a type name for the enum base data type.
+
+}
+
+#endif
diff --git a/force_mod/Force_Memory.cc b/force_mod/Force_Memory.cc
new file mode 100644
index 00000000..7e444811
--- /dev/null
+++ b/force_mod/Force_Memory.cc
@@ -0,0 +1,1041 @@
+//
+// Copyright (C) [2020] Futurewei Technologies, Inc.
+//
+// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
+// FIT FOR A PARTICULAR PURPOSE.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#include "Force_Memory.h"
+
+#include <algorithm>
+#include <cassert>
+#include "fmt.h"
+#include <iomanip>
+#include <iostream>
+#include <ostream>
+
+using namespace std;
+
+/*!
+  \file Memory.cc
+  \brief Code for big endian memory model
+*/
+
+namespace Force {
+
+#define  BASE_INIT_MASK  0x0101010101010101ull
+#define  MEM_BYTES       8                         //!< memory bytes, fixed as 8 bytes so far
+#define  ADDR_ALIGN(a)   ((a) & ~(MEM_BYTES - 1))
+#define  ADDR_OFFSET(a)  ((a) & (MEM_BYTES - 1))
+
+#define MASK(len, pos)   ((len == 64) ? (-1ull << pos) : (((1ull << len) - 1) << pos))
+
+//Replace macros for logging and asserts
+#define FAIL(message) assert(false && message)  
+#define LOG(level) std::cerr << "Force_Memory: " << #level << " message: "  
+
+  bool Memory::msRandomPattern = true;
+  uint64 Memory::msValuePattern = 0;
+
+//utility functions
+/*!
+  The caller should ensure the data_array pointer points to a byte stream array of at least num_bytes size.
+  num_bytes is limited to 1-8 bytes.
+*/
+  void value_to_data_array_big_endian(uint64 value, uint32 num_bytes, uint8* data_array)
+  {
+    switch (num_bytes) {
+    case 8:
+      data_array[7] = (uint8)(value & 0xff);
+      value >>= 8;
+      // fall through
+    case 7:
+      data_array[6] = (uint8)(value & 0xff);
+      value >>= 8;
+    case 6:
+      // fall through
+      data_array[5] = (uint8)(value & 0xff);
+      value >>= 8;
+    case 5:
+      // fall through
+      data_array[4] = (uint8)(value & 0xff);
+      value >>= 8;
+      // fall through
+    case 4:
+      data_array[3] = (uint8)(value & 0xff);
+      value >>= 8;
+      // fall through
+    case 3:
+      data_array[2] = (uint8)(value & 0xff);
+      value >>= 8;
+      // fall through
+    case 2:
+      data_array[1] = (uint8)(value & 0xff);
+      value >>= 8;
+      // fall through
+    case 1:
+      data_array[0] = (uint8)(value & 0xff);
+      break;
+    default:
+      LOG(fail) << "Unexpected data size: " << dec << num_bytes << endl;
+      FAIL("unexpected-data-size");
+    }
+  }
+
+
+ /*!
+    \class MemoryBytes
+    \brief class for a memory chunk.
+  */
+  class MemoryBytes {
+  public:
+    explicit MemoryBytes(uint64 addr) : mValue(0ull), mInitialValue(0ull), mAttributes(0ull), mAddress(addr) { }  //!< Constructor.
+
+    ~MemoryBytes() { }      //!< Destructor, empty.
+
+    /*!
+      Initialize a memory chunk.
+     */
+    void Initialize(uint32 offset, uint64 value, uint64 attrs, uint32 nBytes, EMemDataType type)
+    {
+      if (offset + nBytes > sizeof(mInitialValue)) {
+        FAIL("out-of-boundary");
+      }
+      if (nBytes != sizeof(value) && value >= (1ull << (nBytes << 3))) {
+        FAIL("value-out-of-byte-range ");
+      }
+
+      if (!DoesInitializationMatch(offset, attrs, nBytes)) {
+        LOG(fail) << "Reinitialize memory range (base, offset, size) = (0x" << fmtx0(mAddress, 16)
+                                                                            << ", " << offset
+                                                                            << ", " << nBytes << ")" << endl ;
+        FAIL("reinitilize-memory");
+      }
+
+      uint8 attr_byte = (uint8) IsInit;
+      attr_byte |= (uint8) type;
+
+      uint64 attribute = 0;
+      for (auto i = 0u; i < nBytes; i++) {
+        attribute |= (uint64)attr_byte << (i << 3);
+      }
+
+      // Only initialize the uninitialized bytes.
+      uint64 init_mask = GetInitializedMask(offset, attrs, nBytes);
+      MergeMaskedValue(offset, value, ~init_mask, nBytes, mInitialValue);
+      MergeMaskedValue(offset, value, ~init_mask, nBytes, mValue);
+      MergeMaskedValue(offset, attribute, ~init_mask, nBytes, mAttributes);
+    }
+
+    /*!
+      Check a memory chunk is initialized or not
+    */
+    bool IsInitialized(uint32 offset, uint32 nBytes) const
+    {
+      uint64 mask = BASE_INIT_MASK;
+      uint32 mem_bytes = sizeof(mAttributes);
+      uint32 pos_in_bits = (mem_bytes - (offset + nBytes)) << 3;
+
+      if (offset + nBytes > mem_bytes) {
+        FAIL("out-of-boundary");
+      }
+
+      mask <<= pos_in_bits;
+      mask <<= (offset << 3);
+      mask >>= (offset << 3);
+
+      return (mAttributes & mask) == mask;
+    }
+
+    /*!
+      Write value to a memory chunk
+    */
+    void Write(uint32 offset, uint64 value, uint32 nBytes)
+    {
+      if (offset + nBytes > sizeof(mValue)) {
+        FAIL("out-of-boundary");
+      }
+      if (nBytes != sizeof(value) && value >= (1ull << (nBytes << 3))) {
+        FAIL("value-out-of-byte-range ");
+      }
+      if (!IsInitialized(offset, nBytes)) {
+        LOG(fail) << "write un-initialized memory range (base, offset, size) = (0x" << fmtx0(mAddress, 16)
+                                                                            << ", " << offset
+                                                                            << ", " << nBytes << ")" << endl ;
+        FAIL("write-un-initialized-memory");
+      }
+      MergeValue(offset, value, nBytes, mValue);
+    }
+
+    /*!
+      Read value from a memory chunk
+    */
+    uint64 Read(uint32 offset, uint32 nBytes) const
+    {
+      uint32 mem_bytes = sizeof(mValue);
+      uint32 len_in_bits = nBytes << 3;
+      uint32 pos_in_bits = (mem_bytes - (offset + nBytes)) << 3;
+      uint64 mask = MASK(len_in_bits, pos_in_bits);
+
+      if (offset + nBytes > mem_bytes) {
+        FAIL("out-of-boundary");
+      }
+      if (!IsInitialized(offset, nBytes)) {
+        LOG(fail) << "read un-initialized memory range (base, offset, size) = (0x" << fmtx0(mAddress, 16)
+                                                                            << ", " << offset
+                                                                            << ", " << nBytes << ")" << endl ;
+        FAIL("read-un-initialized-memory");
+      }
+
+      return ((mValue & mask) >> pos_in_bits);
+    }
+
+    /*!
+      Read initial value from a memory chunk
+    */
+    uint64 ReadInitialValue(uint32 offset, uint32 nBytes) const
+    {
+      uint32 mem_bytes = sizeof(mInitialValue);
+      uint32 len_in_bits = nBytes << 3;
+      uint32 pos_in_bits = (mem_bytes - (offset + nBytes)) << 3;
+      uint64 mask = MASK(len_in_bits, pos_in_bits);
+
+      if (offset + nBytes > mem_bytes) {
+        FAIL("out-of-boundary");
+      }
+      if (!IsInitialized(offset, nBytes)) {
+        LOG(fail) << "read un-initialized memory range (base, offset, size) = (0x" << fmtx0(mAddress, 16)
+                                                                            << ", " << offset
+                                                                            << ", " << nBytes << ")" << endl ;
+        FAIL("read-un-initialized-memory");
+      }
+
+      return ((mInitialValue & mask) >> pos_in_bits);
+    }
+
+    /*!
+      Return memory attributes of the specified address offset.
+    */
+    uint8 GetMemoryAttributes(uint32 offset) const
+    {
+      uint32 shift = (MEM_BYTES - (offset + 1)) << 3;
+
+      // << "{GetMemoryAttributes} offset=" << dec << offset << " shift: " << shift << endl;
+
+      return static_cast<uint8>((mAttributes >> shift) & 0xff);
+    }
+
+    /*!
+      Read initial value in big-endian. If a byte is not initialized, randomize it if randomPattern is true; otherwise, set it to the value in valuePattern.
+    */
+    uint64 ReadInitialWithPattern(cbool randomPattern, cuint64 valuePattern)
+    {
+      return ApplyPattern(mInitialValue, randomPattern, valuePattern);
+    }
+
+    /*!
+      Read value in big-endian. If a byte is not initialized, randomize it if randomPattern is true; otherwise, set it to the value in valuePattern.
+    */
+    uint64 ReadWithPattern(cuint32 offset, cuint32 nBytes, cbool randomPattern, cuint64 valuePattern) const
+    {
+      if ((offset + nBytes) > MEM_BYTES) {
+        FAIL("out-of-boundary");
+      }
+
+      uint64 value_with_pattern = ApplyPattern(mValue, randomPattern, valuePattern);
+
+      uint32 len_in_bits = nBytes << 3;
+      uint32 pos_in_bits = (MEM_BYTES - (offset + nBytes)) << 3;
+      uint64 mask = MASK(len_in_bits, pos_in_bits);
+
+      return ((value_with_pattern & mask) >> pos_in_bits);
+    }
+
+    /*!
+      Get uniformed data type for memory bytes
+      If some bytes are no-init and the others are Instrunction, uniformed attribute is Instruction
+      If some bytes are no-init and the others are Data, uniformed attribute is Data
+      If some bytes are no-init and the others are Both, uniformed attribute is Both
+      If some bytes are Insturction, and some bytes are Data, uniformed attribute is Instruction
+    */
+    EMemDataType GetUniformedType(void) const
+    {
+      uint64 init_mask = BASE_INIT_MASK;
+      uint64 inst_mask = init_mask << 1;
+      uint64 data_mask = init_mask << 2;
+
+      if (!(mAttributes & init_mask)) {
+         FAIL("un-initialized-memory-bytes");
+      }
+
+      if ((mAttributes & inst_mask) && (mAttributes & data_mask)) {
+        return EMemDataType::Both;
+      }
+      if (mAttributes & inst_mask) {
+        return  EMemDataType::Instruction;
+      }
+      if (mAttributes & data_mask) {
+        return  EMemDataType::Data;
+      }
+
+       return EMemDataType::Init;
+    }
+
+    /*!
+      Dump data from memory chunk
+    */
+    void Dump(ostream& out_str) const
+    {
+      Dump(out_str, mValue);
+      out_str << "  ";
+      Dump(out_str, mAttributes);
+      out_str << endl;
+    }
+
+  private:
+    /*!
+      Check if specified attributes match current initialization.
+    */
+    bool DoesInitializationMatch(cuint32 offset, cuint64 attrs, cuint32 nBytes) const
+    {
+      if (offset + nBytes > MEM_BYTES) {
+        FAIL("out-of-boundary");
+      }
+
+      uint64 init_attrs = attrs & BASE_INIT_MASK;
+      uint64 stored_init_attrs = mAttributes & BASE_INIT_MASK;
+      uint32 len_in_bits = nBytes << 3;
+      uint32 pos_in_bits = (MEM_BYTES - (offset + nBytes)) << 3;
+      uint64 mask = MASK(len_in_bits, pos_in_bits);
+
+      return ((init_attrs << pos_in_bits) == (stored_init_attrs & mask));
+    }
+
+    /*!
+      Dump data in big endian format
+    */
+    static void Dump(ostream& out_str, uint64 value)
+    {
+      uint64 data;
+      for (auto i = sizeof(value) - 1; i > 0; i --) {
+        data = (value >> (i << 3)) & 0xff;
+        out_str << fmtx0(data, 2) << "_";
+      }
+      data = value & 0xff;  // least significant byte
+      out_str << fmtx0(data, 2);
+    }
+
+    /*!
+      \merge value into big endian data
+      \value:  the value to merge
+      \data:   the reference for the merged data
+      \Cautious: the caller should assure value|nBytes validation.
+    */
+    static void MergeValue(uint32 offset, uint64 value, uint32 nBytes, uint64& data)
+    {
+      uint32 mem_bytes = sizeof(data);
+      uint32 len_in_bits = nBytes << 3;
+      uint32 pos_in_bits = (mem_bytes - (offset + nBytes)) << 3;
+
+      uint64 mask = MASK(len_in_bits, pos_in_bits);
+      data &= ~mask;
+      data |= value << pos_in_bits;
+    }
+
+    /*!
+      \merge value into big endian data
+      \value: the value to merge
+      \mergeMask: a mask indicating which bytes of value should be merged
+      \data: the reference for the merged data
+      \Cautious: the caller should assure value|nBytes validation.
+    */
+    static void MergeMaskedValue (uint32 offset, uint64 value, uint64 mergeMask, uint32 nBytes, uint64& data)
+    {
+      uint32 mem_bytes = sizeof(data);
+      uint32 len_in_bits = nBytes << 3;
+      uint32 pos_in_bits = (mem_bytes - (offset + nBytes)) << 3;
+
+      uint64 mask = MASK(len_in_bits, pos_in_bits);
+      data &= ~(mask & mergeMask);
+      data |= (value << pos_in_bits) & mergeMask;
+    }
+
+    uint64 ApplyPattern(cuint64 value, cbool randomPattern, cuint64 valuePattern) const
+    {
+      uint64 init_mask = GetInitializedMask(0, mAttributes, MEM_BYTES);
+
+      // If all bytes are initialized, there's nothing to fill in
+      if (init_mask == MAX_UINT64) {
+        return value;
+      }
+
+      return (valuePattern & ~init_mask) | (value & init_mask);
+    }
+
+    static uint64 GetInitializedMask(cuint32 offset, cuint64 attrs, cuint32 nBytes)
+    {
+      uint32 pos_in_bits = (MEM_BYTES - (offset + nBytes)) << 3;
+      uint64 init_mask = BASE_INIT_MASK & (attrs << pos_in_bits); // mask to 0x00000101_01010000 as an example
+
+      init_mask |= init_mask << 1;
+      init_mask |= init_mask << 2;
+      init_mask |= init_mask << 4;  // mask to 0x0000ffff_ffff0000 as an example
+
+      return init_mask;
+    }
+
+    MemoryBytes() : mValue(0), mInitialValue(0), mAttributes(0), mAddress(0) { } //!< Default constructor.
+  private:
+    enum {
+    IsInit  =  (1 << 0),
+    IsInstr =  (1 << 1),
+    IsData  =  (1 << 2)
+    };
+
+    uint64 mValue;         //!< Current memory data value, big endian format.
+    uint64 mInitialValue;  //!< Initial memory data value, big endian format.
+    uint64 mAttributes;    //!< Memory bytes attributes, big endian format.
+    uint64 mAddress;       //!< Memory bytes starting address.
+  };
+
+  bool Section::Intersects(const Section& rOther) const
+  {
+    if ((GetEndAddress() >= rOther.mAddress) and (rOther.GetEndAddress() >= mAddress)) {
+      return true;
+    }
+
+    return false;
+  }
+
+  bool Section::Contains(const Section& rOther) const
+  {
+    if ((mAddress <= rOther.mAddress) and (GetEndAddress() >= rOther.GetEndAddress())) {
+      return true;
+    }
+
+    return false;
+  }
+
+  bool Section::operator<(const Section& rOther) const
+  {
+    if (mAddress < rOther.mAddress) {
+      return true;
+    }
+
+    return false;
+  }
+
+  uint64 Section::GetEndAddress() const
+  {
+    return (mAddress + mSize - 1);
+  }
+
+  Memory::~Memory()
+  {
+    for (auto &map_item : mContent)
+      delete map_item.second;
+  }
+
+  /*!
+    \class MetaAccess
+    \brief class for aligned memory access.
+  */
+  struct MetaAccess {
+  public:
+    MetaAccess(uint64 addr, uint32 offset, uint32 nbytes, uint64 data)
+      : MetaAccess(addr, offset, nbytes, data, 0)
+    {
+    }
+
+    MetaAccess(uint64 addr, uint32 offset, uint32 nbytes, uint64 data, uint64 attrs)
+      : mAddress(addr), mOffset(offset), mSize(nbytes), mData(data), mAttrs(attrs)
+    {
+    }
+
+  private:
+    MetaAccess() : mAddress(0), mOffset(0), mSize(0), mData(0), mAttrs(0) { } //!< Default constructor.
+  public:
+      uint64 mAddress;  //!< address aligned by dword
+      uint32 mOffset;
+      uint32 mSize;
+      uint64 mData;     //!< data in big endian
+      uint64 mAttrs;    //!< attributes corresponding to data
+  };
+
+  //!< switch a byte ordering buffer to big endian dword number, buffer[0] respondes to the lowest address
+  static uint64 ToBigEndian(cuint8* buffer, uint32 nSize)
+  {
+    uint64 data = 0;
+
+    if (nSize == 0 || nSize > sizeof(data)) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    for (auto i = 0u; i < nSize; i ++)
+      data |= ((uint64) buffer[i]) << ((nSize - 1 - i) * 8);
+
+    return data;
+  }
+
+  void Memory::AutoInitialize(uint64 address, uint32 nBytes)
+  {
+    // Need to pass in the memory attributes to the Initialize() call to indicate which bytes
+    // are already initialized
+    vector<uint8> attrs(nBytes, 0);
+    GetMemoryAttributes(address, nBytes, attrs.data());
+
+    vector<uint8> data(nBytes, 0);
+    Initialize(address, data.data(), attrs.data(), nBytes, EMemDataType::Both);
+  }
+
+  //!< the parameter value is in big endian
+  void Memory::Initialize(uint64 address, uint64 value, uint32 nBytes, EMemDataType type)
+  {
+    uint32 mem_bytes = sizeof(value);
+
+    if (nBytes == 0 || nBytes > mem_bytes) {
+      FAIL("unsupported-number-of-bytes");
+    }
+    if (nBytes != mem_bytes && value >= (1ull << (nBytes << 3))) {
+      FAIL("value-out-of-byte-range ");
+    }
+    if (IsInitialized(address, nBytes)) {
+      LOG(fail) << "reinitialize memory range (address, size) = (0x"
+                << fmtx0(address) << ", " << nBytes << ")" << endl;
+      FAIL("reinitilize-memory");
+    }
+
+    uint32 nbytes = (ADDR_OFFSET(address) + nBytes <= mem_bytes) ?
+                    nBytes : mem_bytes - ADDR_OFFSET(address);
+    MetaAccess ma_low(ADDR_ALIGN(address), ADDR_OFFSET(address), nbytes,
+                                           value >> ((nBytes - nbytes) << 3));
+    InitializeMemoryBytes(ma_low, type);
+    if (ma_low.mAddress == ADDR_ALIGN(address + nBytes - 1)) {  // the whole line resides in low address access
+      return;
+    }
+
+    MetaAccess ma_high(ADDR_ALIGN(address + nBytes - 1), 0, nBytes - ma_low.mSize,
+                                  value - (ma_low.mData << ((nBytes - ma_low.mSize) << 3)));
+    InitializeMemoryBytes(ma_high, type);
+  }
+
+  //!< the data stream is byte ordering, data[0] responds to the lowerest address.
+  void Memory::Initialize(uint64 address, cuint8* data, cuint8* attrs, uint32 nBytes, EMemDataType type)
+  {
+    if (nBytes == 0) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    // handle crossing part
+    uint32 nSize = ADDR_ALIGN(address + MEM_BYTES - 1) - address;
+    if (nSize) {
+      uint64 data_value = ToBigEndian(data, (nSize > nBytes) ? nBytes : nSize);
+      uint64 attr_value = ToBigEndian(attrs, (nSize > nBytes) ? nBytes : nSize);
+      MetaAccess ma_first(ADDR_ALIGN(address), ADDR_OFFSET(address), (nSize > nBytes) ? nBytes : nSize, data_value, attr_value);
+      InitializeMemoryBytes(ma_first, type);
+    }
+    if (nSize >= nBytes) {
+      return;
+    }
+
+    // handle aligned parts
+    uint32 dword;
+    address += nSize;
+    data += nSize;
+    attrs += nSize;
+    nBytes -= nSize;
+    for (dword = 0; dword < nBytes/8; dword ++) {
+      uint64 data_value = ToBigEndian(data + (dword << 3), 8);
+      uint64 attr_value = ToBigEndian(attrs + (dword << 3), 8);
+      MetaAccess ma_mid(address + (dword << 3), 0, 8, data_value, attr_value);
+      InitializeMemoryBytes(ma_mid, type);
+    }
+
+    // handle remaining part
+    nBytes = nBytes % 8;
+    if (nBytes) {
+      uint64 data_value = ToBigEndian(data + (dword << 3), nBytes);
+      uint64 attr_value = ToBigEndian(attrs + (dword << 3), nBytes);
+      MetaAccess ma_last(address + (dword << 3), 0, nBytes, data_value, attr_value);
+      InitializeMemoryBytes(ma_last, type);
+    }
+  }
+
+  bool Memory::IsInitialized(uint64 address, uint32 nBytes) const
+  {
+    if (nBytes == 0) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    // handle crossing part
+    uint32 nSize = ADDR_ALIGN(address + MEM_BYTES - 1) - address;
+    if (nSize) {
+      MetaAccess ma(ADDR_ALIGN(address), ADDR_OFFSET(address),  (nSize > nBytes) ? nBytes : nSize, 0);
+      if (!IsInitializedMemoryBytes(ma)) {
+        return false;
+      }
+    }
+    if (nSize >= nBytes) {
+      return true;
+    }
+
+    //handle aligned parts
+    uint32 dword;
+    address += nSize;
+    nBytes -= nSize;
+    for (dword = 0; dword < nBytes/8; dword ++) {
+      MetaAccess ma(address + (dword << 3), 0, 8, 0);
+        if (!IsInitializedMemoryBytes(ma)) {
+          return false;
+        }
+    }
+
+    // handle remaining part
+    nBytes = nBytes % 8;
+    if (nBytes) {
+       MetaAccess ma(address + (dword << 3), 0, nBytes, 0);
+       if (!IsInitializedMemoryBytes(ma)) {
+         return false;
+       }
+    }
+
+    return true;
+  }
+
+  uint64 Memory::Read(uint64 address, uint32 nBytes)
+  {
+    uint32 mem_bytes = 8;
+
+    if (nBytes == 0 || nBytes > mem_bytes) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    EnsureInitialization(address, nBytes);
+
+    uint32 nbytes = (ADDR_OFFSET(address) + nBytes <= mem_bytes) ?
+                    nBytes : mem_bytes - ADDR_OFFSET(address);
+    MetaAccess ma_low(ADDR_ALIGN(address), ADDR_OFFSET(address), nbytes, 0);
+    ReadMemoryBytes(ma_low);
+    if (ma_low.mAddress == ADDR_ALIGN(address + nBytes - 1)) {  // the whole line resides in low address access
+      return ma_low.mData;
+    }
+
+    MetaAccess ma_high(ADDR_ALIGN(address + nBytes - 1), 0, nBytes - ma_low.mSize, 0);
+    ReadMemoryBytes(ma_high);
+    return (ma_low.mData << (ma_high.mSize << 3)) | ma_high.mData;
+  }
+
+  void Memory::Write(uint64 address, uint64 value, uint32 nBytes)
+  {
+    uint32 mem_bytes = sizeof(value);
+    if (nBytes == 0 || nBytes > sizeof(value)) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    if (nBytes != sizeof(value) && value >= (1ull << (nBytes << 3))) {
+      FAIL("value-out-of-byte-range ");
+    }
+
+    EnsureInitialization(address, nBytes);
+
+    Unreserve(address, nBytes);
+
+    uint32 nbytes = (ADDR_OFFSET(address) + nBytes <= mem_bytes) ?
+                    nBytes : mem_bytes - ADDR_OFFSET(address);
+    MetaAccess ma_low(ADDR_ALIGN(address), ADDR_OFFSET(address), nbytes,
+                      value >> ((nBytes - nbytes) << 3));
+    WriteMemoryBytes(ma_low);
+    if (ma_low.mAddress == ADDR_ALIGN(address + nBytes - 1)) {  // the whole line resides in low address access
+      return;
+    }
+
+    MetaAccess ma_high(ADDR_ALIGN(address + nBytes - 1), 0, nBytes - ma_low.mSize,
+                                  value - (ma_low.mData << ((nBytes - ma_low.mSize) << 3)));
+    WriteMemoryBytes(ma_high);
+  }
+
+  void Memory::Write(uint64 address, cuint8* data, uint32 nBytes)
+  {
+    if (nBytes == 0) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    Unreserve(address, nBytes);
+
+    // handle crossing part
+    uint32 nSize = ADDR_ALIGN(address + MEM_BYTES - 1) - address;
+    if (nSize) {
+        auto value = ToBigEndian(data,  (nSize > nBytes) ? nBytes : nSize);
+        MetaAccess ma_first(ADDR_ALIGN(address), ADDR_OFFSET(address), (nSize > nBytes) ? nBytes : nSize, value);
+        WriteMemoryBytes(ma_first);
+    }
+    if (nSize >= nBytes) {
+      return;
+    }
+
+    // handle aligned parts
+    uint32 dword;
+    address += nSize;
+    data += nSize;
+    nBytes -= nSize;
+    for (dword = 0; dword < nBytes/8; dword ++) {
+      auto value = ToBigEndian(data + (dword << 3), 8);
+      MetaAccess ma_mid(address + (dword << 3), 0, 8, value);
+      WriteMemoryBytes(ma_mid);
+    }
+
+    // handle remaining part
+    nBytes = nBytes % 8;
+    if (nBytes) {
+      auto  value = ToBigEndian(data + (dword << 3), nBytes);
+      MetaAccess ma_last(address + (dword << 3), 0, nBytes, value);
+      WriteMemoryBytes(ma_last);
+    }
+
+  }
+
+  void Memory::Reserve(uint64 address, uint32 nBytes)
+  {
+    Unreserve(address, nBytes);
+
+    // Insert reserved Section in sorted position
+    Section section(address, nBytes, EMemDataType::Both);
+    auto itr = upper_bound(mReservedRanges.begin(), mReservedRanges.end(), section);
+    mReservedRanges.insert(itr, section);
+  }
+
+  void Memory::Unreserve(uint64 address, uint32 nBytes)
+  {
+    // Remove all reserved Sections that intersect the input Section; the first Section that could
+    // intersect is the one immediately preceding the input Seciton's upper bound
+    Section section(address, nBytes, EMemDataType::Both);
+    auto itr = upper_bound(mReservedRanges.begin(), mReservedRanges.end(), section);
+    if (itr != mReservedRanges.begin()) {
+      --itr;
+    }
+
+    mReservedRanges.erase(remove_if(itr, mReservedRanges.end(),
+      [&section](const Section& rSection) { return rSection.Intersects(section); }),
+      mReservedRanges.end());
+  }
+
+  bool Memory::IsReserved(uint64 address, uint32 nBytes)
+  {
+    // Return true if a reserved Section contains the input Section; the first Section that could
+    // contain the input Section is the one immediately preceding the input Section's upper bound
+    Section section(address, nBytes, EMemDataType::Both);
+    auto itr = upper_bound(mReservedRanges.begin(), mReservedRanges.end(), section);
+    if (itr != mReservedRanges.begin()) {
+      --itr;
+    }
+
+    bool contained = any_of(itr, mReservedRanges.end(),
+      [&section](const Section& rSection) { return rSection.Contains(section); });
+
+    return contained;
+  }
+
+  uint64 Memory::ReadInitialValue(uint64 address, uint32 nBytes)
+  {
+    uint32 mem_bytes = 8;
+
+    if (nBytes == 0 || nBytes > mem_bytes) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    EnsureInitialization(address, nBytes);
+
+    uint32 nbytes = (ADDR_OFFSET(address) + nBytes <= mem_bytes) ?
+                    nBytes : mem_bytes - ADDR_OFFSET(address);
+    MetaAccess ma_low(ADDR_ALIGN(address), ADDR_OFFSET(address), nbytes, 0);
+    ReadInitialValue(ma_low);
+    if (ma_low.mAddress == ADDR_ALIGN(address + nBytes - 1)) {  // the whole line resides in low address access
+      return ma_low.mData;
+    }
+
+    MetaAccess ma_high(ADDR_ALIGN(address + nBytes - 1), 0, nBytes - ma_low.mSize, 0);
+    ReadInitialValue(ma_high);
+    return (ma_low.mData << (ma_high.mSize << 3)) | ma_high.mData;
+
+  }
+
+  void Memory::DumpTitle(ostream& out_str) const
+  {
+    out_str << setw(18) << setfill(' ') << "Address" <<" : "
+            << setw(23) << setfill(' ') << "Data in Big Endian"  << "  "
+            << setw(24) << setfill(' ') << "Attribute(Init: 0x01; Inst: 0x02; Data: 0x04)"<< endl;
+  }
+
+  void Memory::Dump(ostream& out_str) const
+  {
+    DumpTitle(out_str);
+    for (auto const& map_item : mContent) {
+      out_str << "0x" << fmtx0(map_item.first, 16) << " : ";
+      map_item.second->Dump(out_str);
+    }
+  }
+
+  void Memory::Dump(std::ostream& out_str, uint64 address, uint64 nBytes) const
+  {
+    if (address != ADDR_ALIGN(address)) {
+      LOG(fail) << "{Memory::Dump} Unaligned address: 0x" << hex << address << endl;
+      FAIL("fail-dump-unalgined address");
+    }
+    if (nBytes % MEM_BYTES) {
+      LOG(fail) << "{Memory::Dump} Unaligned memory bytes:0x" << hex << nBytes << endl;
+      FAIL("fail-dump-unaligned memory bytes");
+    }
+
+    DumpTitle(out_str);
+
+    for (uint64 addr = address; addr < address + nBytes; addr += MEM_BYTES) {
+      auto it = mContent.find(addr);
+      if (it != mContent.end()) {
+        out_str << "0x" << fmtx0(it->first, 16) << " : ";
+        it->second->Dump(out_str);
+      }
+    }
+
+  }
+
+  void Memory::InitializeMemoryBytes(const MetaAccess& rMetaAccess, EMemDataType type)
+  {
+    auto it = mContent.find(rMetaAccess.mAddress);
+    if (it == mContent.end()) {
+      MemoryBytes *mb = new MemoryBytes(rMetaAccess.mAddress);
+      mb->Initialize(rMetaAccess.mOffset, rMetaAccess.mData, rMetaAccess.mAttrs, rMetaAccess.mSize, type);
+      mContent[rMetaAccess.mAddress] = mb;
+    }
+    else {
+      it->second->Initialize(rMetaAccess.mOffset, rMetaAccess.mData, rMetaAccess.mAttrs, rMetaAccess.mSize, type);
+    }
+  }
+
+  bool Memory::IsInitializedMemoryBytes(const MetaAccess& rMetaAccess) const
+  {
+    auto it = mContent.find(ADDR_ALIGN(rMetaAccess.mAddress));
+    if (it == mContent.end() || !it->second->IsInitialized(rMetaAccess.mOffset, rMetaAccess.mSize)) {
+      return false;
+    }
+
+    return true;
+  }
+
+  void Memory::EnsureInitialization(uint64 address, uint32 nBytes)
+  {
+    if (!IsInitialized(address, nBytes)) {
+      if (mAutoInit) {
+        AutoInitialize(address, nBytes);
+      }
+      else {
+        LOG(fail) << "read uninitialized memory range (address, size) = (0x"
+                  << fmtx0(address) << ", " << nBytes << ")" << endl;
+        FAIL("read-un-initialized-memory");
+      }
+    }
+  }
+
+  void Memory::ReadMemoryBytes(MetaAccess& rMetaAccess) const
+  {
+    auto it = mContent.find(rMetaAccess.mAddress);
+    if (it == mContent.end()) {
+      LOG(fail) << "Failed to read memory 0x" << hex << rMetaAccess.mAddress << "." << "No matched memory bytes object, please initialize first" << endl;
+      FAIL("no-matched-memory-bytes");
+    }
+    rMetaAccess.mData = it->second->Read(rMetaAccess.mOffset, rMetaAccess.mSize);
+  }
+
+  void Memory::WriteMemoryBytes(const MetaAccess& rMetaAccess)
+  {
+    auto it = mContent.find(rMetaAccess.mAddress);
+    if (it == mContent.end()) {
+      LOG(fail) << "Failed to write memory 0x" << hex << rMetaAccess.mAddress << ". " << "No matched memory bytes object, please initialize first" << endl;
+      FAIL("no-matched-memory-bytes");
+    }
+    it->second->Write(rMetaAccess.mOffset, rMetaAccess.mData, rMetaAccess.mSize);
+  }
+
+  void Memory::ReadInitialValue(MetaAccess& rMetaAccess) const
+  {
+    auto it = mContent.find(rMetaAccess.mAddress);
+    if (it == mContent.end()) {
+      LOG(fail) << "Failed to init memory 0x" << hex << rMetaAccess.mAddress << ". " << "No matched memory bytes object, please initialize first" << endl;
+      FAIL("no-matched-memory-bytes");
+    }
+    rMetaAccess.mData = it->second->ReadInitialValue(rMetaAccess.mOffset, rMetaAccess.mSize);
+
+  }
+
+  void Memory::GetMemoryAttributes(cuint64 address, cuint32 nBytes, uint8* memAttrs) const
+  {
+    uint32 attrs_read = 0;
+    uint64 current_base_address = ADDR_ALIGN(address);
+    auto it = mContent.find(current_base_address);
+    uint64 offset = ADDR_OFFSET(address);
+    while (attrs_read < nBytes) {
+      uint32 length = MEM_BYTES - offset;
+
+      // If this is the last block to read, reduce the length accordingly
+      if (length > (nBytes - attrs_read)) {
+        length = nBytes - attrs_read;
+      }
+
+      if (it != mContent.end()) {
+        for (uint32 i = 0; i < length; i++) {
+          memAttrs[attrs_read] = it->second->GetMemoryAttributes(offset + i);
+          attrs_read++;
+        }
+      }
+      else {
+        for (uint32 i = 0; i < length; i++) {
+          memAttrs[attrs_read] = 0x0;
+          attrs_read++;
+        }
+      }
+
+      // The next entry in the map may not be contiguous, so we can't just increment the iterator here
+      current_base_address += 8;
+      it = mContent.find(current_base_address);
+
+      offset = 0;
+    }
+  }
+
+  uint8 Memory::GetByteMemoryAttributes(cuint64 address) const
+  {
+    uint64 aligned_addr = ADDR_ALIGN(address);
+    auto it = mContent.find(aligned_addr);
+    if (it == mContent.end()) {
+      return 0;
+    }
+    return it->second->GetMemoryAttributes(ADDR_OFFSET(address));
+  }
+
+  //!< the data stream is byte ordering, data[0] responds to the lowerest address.
+  void Memory::ReadInitialWithPattern(uint64 address, uint32 nBytes, uint8* data) const
+  {
+    if (address != ADDR_ALIGN(address)) {
+      FAIL("un-aligned address");
+    }
+    if (nBytes % MEM_BYTES != 0) {
+      FAIL("unsupported-number-of-bytes");
+    }
+
+    auto it = mContent.find(address);
+    if (it == mContent.end()) {
+      LOG(fail) << "Failed to read memory 0x" << hex << address << "." << "No matched memory bytes object, please initialize first" << endl;
+      FAIL("no-matched-memory-bytes");
+    }
+
+    for (auto i = 0u; i< nBytes; i += MEM_BYTES) {
+      auto initialValue = it->second->ReadInitialWithPattern(Memory::msRandomPattern, Memory::msValuePattern);  // in big-endian format
+      for (int j = 0; j < MEM_BYTES; j ++) {
+        data[j] = (initialValue >> ((MEM_BYTES - 1 - j) << 3)) & 0xffu;
+      }
+
+      data += MEM_BYTES;
+      it ++;
+    }
+
+  }
+
+  void Memory::ReadPartiallyInitialized(cuint64 address, cuint32 nBytes, uint8* data) const
+  {
+    uint32 bytes_read = 0;
+    uint64 current_base_address = ADDR_ALIGN(address);
+    auto it = mContent.find(current_base_address);
+    uint64 offset = ADDR_OFFSET(address);
+    while (bytes_read < nBytes) {
+      uint32 length = MEM_BYTES - offset;
+
+      // If this is the last block to read, reduce the length accordingly
+      if (length > (nBytes - bytes_read)) {
+        length = nBytes - bytes_read;
+      }
+
+      uint64 value = 0x0;
+      if (it != mContent.end()) {
+        value = it->second->ReadWithPattern(offset, length, false, 0x0);
+      }
+
+      value_to_data_array_big_endian(value, length, data + bytes_read);
+      bytes_read += length;
+
+      // The next entry in the map may not be contiguous, so we can't just increment the iterator here
+      current_base_address += 8;
+      it = mContent.find(current_base_address);
+
+      offset = 0;
+    }
+  }
+
+  void Memory::GetSections(std::vector<Section>& rSections) const
+  {
+    if (mContent.empty()) {
+      LOG(warn) << "{Memory::GetSections} memory contents empty." << endl;
+      return;
+    }
+    map<uint64, MemoryBytes *>::const_iterator mem_iter = mContent.begin();
+    uint64 address = mem_iter->first;
+    EMemDataType type = mem_iter->second->GetUniformedType();
+    uint32 size = MEM_BYTES;
+    uint64 next_addr = address + MEM_BYTES;
+    ++ mem_iter;
+
+    for (; mem_iter != mContent.end(); ++ mem_iter) {
+      // LOG(debug) << "{GetSections} item address: 0x" << hex << mem_iter->first << " section start: 0x" << address << " data type: " << EMemDataType_to_string(type) << endl;
+      auto dataType = mem_iter->second->GetUniformedType();
+      if ((dataType == type) && (mem_iter->first == next_addr)) {
+        size += MEM_BYTES;
+        next_addr += MEM_BYTES;
+      }
+      else  {
+        Section section(address, size, type);
+        rSections.push_back(section);
+        address = mem_iter->first;
+        size = MEM_BYTES;
+        next_addr = address + MEM_BYTES;
+        type = dataType;
+      }
+    }
+    // push the last one
+    Section section(address, size, type);
+    rSections.push_back(section);
+  }
+
+//#ifndef UNIT_TEST
+//  void Memory::InitializeFillPattern()
+//  {
+//    bool exists;
+//    auto value_pattern = Config::Instance()->GlobalStateValue(EGlobalStateType::MemoryFillPattern, exists);
+//    if (exists) {
+//      Memory::msValuePattern = ToBigEndian((uint8*)&value_pattern, sizeof(value_pattern));
+//      Memory::msRandomPattern = false;
+//      return;
+//    }
+//
+//    auto fill_pattern = Config::Instance()->GlobalStateString(EGlobalStateType::MemoryFillPattern, exists);
+//    if (!exists) {
+//      return;
+//    }
+//    if (fill_pattern == "Random" || fill_pattern == "random") {
+//      Memory::msRandomPattern = true;
+//    }
+//    else {
+//      LOG(fail) << "Illegal memory fill pattern : \"" << fill_pattern << "\"" << ", valid option is \"Random\" or hexadecimal value" << endl;
+//      FAIL("illegal-memory-fill-pattern");
+//    }
+//
+//  }
+//#endif
+
+}
diff --git a/force_mod/Force_Memory.h b/force_mod/Force_Memory.h
new file mode 100644
index 00000000..213c2ace
--- /dev/null
+++ b/force_mod/Force_Memory.h
@@ -0,0 +1,102 @@
+//
+// Copyright (C) [2020] Futurewei Technologies, Inc.
+//
+// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
+// FIT FOR A PARTICULAR PURPOSE.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#ifndef Force_Memory_H
+#define Force_Memory_H
+
+#include <list>
+#include <map>
+#include <iosfwd>
+#include <vector>
+
+#include "Force_Defines.h"
+#include "Force_Enums.h"
+
+namespace Force {
+
+  class MemoryBytes;
+  struct MetaAccess;
+
+  /*!
+    \class Section
+    \brief a continous address range with the same type
+  */
+  struct Section {
+    public:
+      Section(uint64 address, uint32 size, EMemDataType type) : mAddress(address), mSize(size), mType(type) { }
+      bool Intersects(const Section& rOther) const; //!< Return true if the memory range of the other Section overlaps the memory range of this Section.
+      bool Contains(const Section& rOther) const; //!< Return true if the memory range of the other Section is entirely contained within the memory range of this Section.
+      bool operator<(const Section& rOther) const; //!< Return true if this Section has a smaller base address than the other Section.
+    public:
+      uint64 mAddress;  //!< base address on memorybytes.
+      uint32 mSize;     //!< range size in bytes.
+      EMemDataType mType;
+    private:
+      uint64 GetEndAddress() const; //!< Return the last address of the memory range.
+  };
+
+  /*!
+    \class Memory
+    \brief A memory model to record memory data and states.
+  */
+  class Memory {
+  public:
+    void AutoInitialize(uint64 address, uint32 nBytes); //!< Initialize any uninitialized memory in the specified range. Previously initialized memory is unchanged. This is useful when it doesn't matter whether the memory has been initialized previously and the initial value is unimportant.
+    void Initialize(uint64 address, uint64 value, uint32 nBytes, EMemDataType type);  //!< Initialize memory.
+    void Initialize(uint64 address, cuint8* data, cuint8* attrs, uint32 nBytes, EMemDataType type);  //!< Initialize memory.
+    bool IsInitialized(uint64 address, uint32 nBytes) const; //!< check whether address is initialized or not
+    uint64 Read(uint64 address, uint32 nBytes);        //!< read data in big-endian
+    void Write(uint64 address, uint64 value, uint32 nBytes); //!< write data in big-endian
+    void Write(uint64 address, cuint8* data, uint32 nBytes);  //!< write data in the buffer
+    uint64 ReadInitialValue(uint64 address, uint32 nBytes);  //!< read initial value in big-endian, failed if some byte not initialized
+    void Reserve(uint64 address, uint32 nBytes); //!< Reserve a memory range. Unreserve any overlapping reserved ranges. Any write to any part of the reserved range causes the range to become unreserved.
+    void Unreserve(uint64 address, uint32 nBytes); //!< Unreserve all reserved memory ranges that overlap with the specified memory range.
+    bool IsReserved(uint64 address, uint32 nBytes); //!< Return true if the specified memory range lies entirely within a reserved memory range.
+    void GetMemoryAttributes(cuint64 address, cuint32 nBytes, uint8* memAttrs) const; //!< Get memory attributes for the specified number of bytes starting at the specified address.
+    uint8 GetByteMemoryAttributes(cuint64 address) const; //!< Get memory attributes of the byte at the specified address.
+
+    void ReadPartiallyInitialized(cuint64 address, cuint32 nBytes, uint8* data) const; //!< Read data in byte ordering, i.e. data[0] is byte with lowest address, that may not be fully initialized; unitialized bytes will be set to 0.
+    void ReadInitialWithPattern(uint64 address, uint32 nBytes, uint8* data) const; //!< read initial value , random value if some byte not initialized
+    void Dump(std::ostream& out_str) const;                  //!< dump memory model for debug
+    void Dump (std::ostream& out_str, uint64 address, uint64 nBytes) const; //!< dump memory range
+    void GetSections(std::vector<Section>& rSections) const;    //!< Get sections the memory object contained, by address ascending order
+
+    Memory(EMemBankType bankType, bool autoInit) : mBankType(bankType), mContent(), mAutoInit(autoInit) { }  //!< Constructor.
+    ~Memory(); //!< Destructor.
+    EMemBankType MemoryBankType() const { return mBankType; } //!< Return memory bank type.
+    bool IsEmpty() const { return mContent.empty(); } //!< Return if the memory module is empty.
+//#ifndef UNIT_TEST
+//    static void InitializeFillPattern(); //!< initialize fill pattern
+//#endif
+  private:
+    void InitializeMemoryBytes(const MetaAccess& rMetaAccess, EMemDataType type); //!< initialize the memory bytes on meta access
+    bool IsInitializedMemoryBytes(const MetaAccess& rMetaAccess) const; //!< check memory bytes are initialized or not
+    void EnsureInitialization(uint64 address, uint32 nBytes); //!< Verify the specified memory range is initialized. If mAutoInit is true, uninitialized memory is initialized; otherwise, uninitialize memory triggers a failure.
+    void ReadMemoryBytes(MetaAccess& rMetaAccess) const;                //!< read memory bytes on meta access
+    void WriteMemoryBytes(const MetaAccess& rMetaAccess);         //!< write memory bytes on meta access
+    void ReadInitialValue(MetaAccess& rMetaAccess) const;         //!< read initial value on meta access
+    void DumpTitle(std::ostream& out_str) const; //!< dump title
+  private:
+    EMemBankType mBankType;
+    std::map<uint64, MemoryBytes *> mContent;  //!< map containing all memory content, increasing order by the key
+    std::list<Section> mReservedRanges; //!< List of reserved memory ranges sorted by start address
+    bool mAutoInit; //!< Flag indicating memory should be automatically initialized on access if not already initialized
+    static bool msRandomPattern; //!< memory fill rondom pattern
+    static uint64 msValuePattern;  //!< memory fill value pattern in big endian
+ };
+}
+
+#endif
diff --git a/force_mod/fmt.h b/force_mod/fmt.h
new file mode 100644
index 00000000..c6f2b42f
--- /dev/null
+++ b/force_mod/fmt.h
@@ -0,0 +1,515 @@
+//
+// Copyright 2013 Michael J. Haertel
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject
+// to the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+// ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+#ifndef FMT_H
+#define FMT_H
+#ifdef __GNUC__
+#pragma GCC diagnostic push 
+#pragma GCC diagnostic ignored "-Weffc++"
+#endif
+
+#include <iostream>
+
+//
+// Helper class to make iostreams formatted I/O more printf/scanf-like.
+// Using Fmt objects, the equivalent to:
+//    printf("%08X\n", x);
+// is:
+//    std::cout << fmtX(x, 8).fill(0) << '\n';
+// Fmt objects also work with input streams in a scanf like fashion,
+// for example:
+//    char s[10];
+//    std::cin >> fmt(s, sizeof s);
+// Supported formats include:
+//    fmt    iostreams default formatting for operand type
+//    fmti    base determined by leading 0 or 0x of input
+//    fmtd    decimal
+//    fmtd0    decimal with fill '0'
+//    fmto    octal
+//    fmto0    octal with fill '0'
+//    fmtx    hex
+//    fmtx0    hex with fill '0'
+//    fmtX    hex upper case
+//    fmtX0    hex upper case with fill 0
+// FUTURE WORK: consider adding equivalents to remaining printf/scanf formats:
+//    a, A:    C99 hex floating point
+//    d, i    signed decimal (for scanf, %i detects base different?)
+//    e, E    floating point with lower or uppercase E notation
+//    f, F    floating point with lower or uppercase "inf" "nan" etc
+//    g, G    auto-choose between [eE] and [fF]
+//    m    useful glibc extension: strerror(errno)
+//    n    store # of characters emitted/consumed since beginning of format
+//    o    unsigned octal
+//    p    void *
+//    u    unsigned decimal
+//    x, X    unsigned hex
+//    [    incredibly useful scanf feature
+// In all cases the arguments to fmt*() are operand, width, precision.
+// If width and precision are not provided they default to 0 and 6
+// respectively (following the normal iostream defaults).
+//
+// The << and >> operators for Fmt objects save and restore the iostream's
+// prior to formatting the referenced object, and restore it afterards.
+// So, for example, after executing:
+//    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);
+//    std::cout << fmto(123);
+// the output base for std::cout will still be hex.
+//
+// In order to make "cin >> fmt(x)" work, Fmt objects contain references
+// rather than values.  But in order to make "cout << fmtx(123)" work,
+// the reference may be to an implicit temporary created by the compiler;
+// such a temporary object lives only until the end of evaluation of the
+// full expression in which the temporary was created.  The user should
+// never directly declare objects of type Fmt.  Due to a C++ 1998/2003
+// language bug and lack of imagination for how to work around it, this
+// library does not fully enforce that constraint.
+//
+
+// FUTURE WORK: maybe should parameterize on charT and traits like the
+// basic_ios template.  And then maybe the istream/ostream operators 
+// should attach to more abstract istream/ostream types.
+template <class TYPE>
+class Fmt {
+public:
+    //
+    // Although it might seem odd to put "friend" declarations first,
+    // these (non-member) functions are the primary interface to Fmt.
+    //
+
+    // iostream << and >>
+    template <class T> friend std::istream& operator>>(std::istream&,
+                               const Fmt<T>&);
+    template <class T> friend std::ostream& operator<<(std::ostream&,
+                               const Fmt<T>&);
+
+    // fmt
+    template <class T> friend Fmt<const T*> fmt(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmt(const T&, int, int);
+    template <class T> friend Fmt<T&> fmt(T&, int, int);
+
+    // fmti
+    template <class T> friend Fmt<const T*> fmti(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmti(const T&, int, int);
+    template <class T> friend Fmt<T&> fmti(T&, int, int);
+
+    // fmtd
+    template <class T> friend Fmt<const T*> fmtd(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmtd(const T&, int, int);
+    template <class T> friend Fmt<T&> fmtd(T&, int, int);
+
+    // fmtd0
+    template <class T> friend Fmt<const T*> fmtd0(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmtd0(const T&, int, int);
+    template <class T> friend Fmt<T&> fmtd0(T&, int, int);
+
+    // fmto
+    template <class T> friend Fmt<const T*> fmto(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmto(const T&, int, int);
+    template <class T> friend Fmt<T&> fmto(T&, int, int);
+
+    // fmto0
+    template <class T> friend Fmt<const T*> fmto0(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmto0(const T&, int, int);
+    template <class T> friend Fmt<T&> fmto0(T&, int, int);
+
+    // fmtx
+    template <class T> friend Fmt<const T*> fmtx(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmtx(const T&, int, int);
+    template <class T> friend Fmt<T&> fmtx(T&, int, int);
+
+    // fmtx0
+    template <class T> friend Fmt<const T*> fmtx0(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmtx0(const T&, int, int);
+    template <class T> friend Fmt<T&> fmtx0(T&, int, int);
+
+    // fmtX
+    template <class T> friend Fmt<const T*> fmtX(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmtX(const T&, int, int);
+    template <class T> friend Fmt<T&> fmtX(T&, int, int);
+
+    // fmtX0
+    template <class T> friend Fmt<const T*> fmtX0(const T*, int, int);
+    template <class T> friend Fmt<const T&> fmtX0(const T&, int, int);
+    template <class T> friend Fmt<T&> fmtX0(T&, int, int);
+
+    //
+    // The following member functions allow additional tweaks to the
+    // default formatting done the fmt*() pseudo-constructors above.
+    //
+    Fmt& fill(std::ostream::char_type fc) {
+        c = fc;
+        return *this;
+    }
+    Fmt& internal() {
+        f = (f & ~std::ios_base::adjustfield) | std::ios_base::internal;
+        return *this;
+    }
+    Fmt& left() {
+        f = (f & ~std::ios_base::adjustfield) | std::ios_base::left;
+        return *this;
+    }
+    Fmt& right() {
+        f = (f & ~std::ios_base::adjustfield) | std::ios_base::right;
+        return *this;
+    }
+    Fmt& any() {
+        f &= ~std::ios_base::basefield;
+        return *this;
+    }
+    Fmt& dec() {
+        f = (f & ~std::ios_base::basefield) | std::ios_base::dec;
+        return *this;
+    }
+    Fmt& hex() {
+        f = (f & ~std::ios_base::basefield) | std::ios_base::hex;
+        return *this;
+    }
+    Fmt& oct() {
+        f = (f & ~std::ios_base::basefield) | std::ios_base::oct;
+        return *this;
+    }
+    Fmt& fixed() {
+        f = (f & ~std::ios_base::floatfield) | std::ios_base::fixed;
+        return *this;
+    }
+    Fmt& scientific() {
+        f = (f & ~std::ios_base::floatfield) | std::ios_base::scientific;
+        return *this;
+    }
+    Fmt& boolalpha(bool b = true) {
+        if (b)
+            f |= std::ios_base::boolalpha;
+        else
+            f &= ~std::ios_base::boolalpha;
+        return *this;
+    }
+    Fmt& showbase(bool b = true) {
+        if (b)
+            f |= std::ios_base::showbase;
+        else
+            f &= ~std::ios_base::showbase;
+        return *this;
+    }
+    Fmt& showpoint(bool b = true) {
+        if (b)
+            f |= std::ios_base::showpoint;
+        else
+            f &= ~std::ios_base::showpoint;
+        return *this;
+    }
+    Fmt& showpos(bool b = true) {
+        if (b)
+            f |= std::ios_base::showpos;
+        else
+            f &= ~std::ios_base::showpos;
+        return *this;
+    }
+    Fmt& skipws(bool b = true) {
+        if (b)
+            f |= std::ios_base::skipws;
+        else
+            f &= ~std::ios_base::skipws;
+        return *this;
+    }
+    Fmt& unitbuf(bool b = true) {
+        if (b)
+            f |= std::ios_base::unitbuf;
+        else
+            f &= ~std::ios_base::unitbuf;
+        return *this;
+    }
+    Fmt& uppercase(bool b = true) {
+        if (b)
+            f |= std::ios_base::uppercase;
+        else
+            f &= ~std::ios_base::uppercase;
+        return *this;
+    }
+
+    // FIXME: Unfortunately C++ 1998 and 2003 require this constructor to
+    // be public order to pass arguments of const Fmt&.  This means the
+    // user can make copies of Fmt<const T&> objects that outlive a
+    // referenced temporary.  Find some way to prevent this.  This language
+    // bug was fixed in C++ 2011, so we could in principle insert an #ifdef
+    // to make this copy constructor private under C++ 2011 or later.
+    Fmt(const Fmt& f): v(f.v), c(f.c), f(f.f), p(f.p), w(f.w) {}
+
+private:
+    Fmt(TYPE v, int w, int p): v(v), c(' '),
+        f(std::ios_base::dec | std::ios_base::skipws), p(p), w(w) {}
+    Fmt& operator=(const Fmt&);
+    TYPE v;
+    std::ostream::char_type c;
+    std::ios_base::fmtflags f;
+    std::streamsize p;
+    std::streamsize w;
+};
+
+template <class TYPE>
+inline
+std::istream&
+operator>>(std::istream& is, const Fmt<TYPE>& fmt)
+{
+    std::ostream::char_type c = is.fill(fmt.c);
+    std::ios_base::fmtflags f = is.flags(fmt.f);
+    std::streamsize p = is.precision(fmt.p);
+    std::streamsize w = is.width(fmt.w);
+    is >> fmt.v;
+    is.fill(c);
+    is.flags(f);
+    is.width(w);
+    is.precision(p);
+    return is;
+}
+
+template <class TYPE>
+inline
+std::ostream&
+operator<<(std::ostream& os, const Fmt<TYPE>& fmt)
+{
+    std::ostream::char_type c = os.fill(fmt.c);
+    std::ios_base::fmtflags f = os.flags(fmt.f);
+    std::streamsize p = os.precision(fmt.p);
+    std::streamsize w = os.width(fmt.w);
+    os << fmt.v;
+    os.fill(c);
+    os.flags(f);
+    os.width(w);
+    os.precision(p);
+    return os;
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmt(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p);
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmt(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p);
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmt(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p);
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmtd(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).dec();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmtd(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).dec();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmtd(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).dec();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmtd0(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).fill('0').dec();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmtd0(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).fill('0').dec();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmtd0(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).fill('0').dec();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmti(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).any();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmti(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).any();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmti(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).any();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmto(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).oct();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmto(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).oct();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmto(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).oct();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmto0(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).fill('0').oct();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmto0(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).fill('0').oct();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmto0(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).fill('0').oct();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmtx(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).hex();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmtx(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).hex();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmtx(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).hex();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmtx0(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).fill('0').hex();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmtx0(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).fill('0').hex();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmtx0(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).fill('0').hex();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmtX(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).hex().uppercase();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmtX(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).hex().uppercase();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmtX(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).hex().uppercase();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE*>
+fmtX0(const ATYPE* v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE*>(v, w, p).fill('0').hex().uppercase();
+}
+
+template <class ATYPE>
+Fmt<const ATYPE&>
+fmtX0(const ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<const ATYPE&>(v, w, p).fill('0').hex().uppercase();
+}
+
+template <class ATYPE>
+Fmt<ATYPE&>
+fmtX0(ATYPE& v, int w = 0, int p = 6)
+{
+    return Fmt<ATYPE&>(v, w, p).fill('0').hex().uppercase();
+}
+#ifdef __GNUC__
+#pragma GCC diagnostic pop 
+#endif
+
+#endif // FMT_H
diff --git a/riscv/CMakeLists.txt b/riscv/CMakeLists.txt
new file mode 100644
index 00000000..e2ab4883
--- /dev/null
+++ b/riscv/CMakeLists.txt
@@ -0,0 +1,39 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.8.0)
+project(riscv VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+aux_source_directory(${PROJECT_SOURCE_DIR} RISCV_SRCS)
+
+list(REMOVE_ITEM RISCV_SRCS
+${PROJECT_SOURCE_DIR}/clint.cc
+${PROJECT_SOURCE_DIR}/debug_module.cc
+${PROJECT_SOURCE_DIR}/devices.cc
+${PROJECT_SOURCE_DIR}/dts.cc
+${PROJECT_SOURCE_DIR}/insn_template.cc
+${PROJECT_SOURCE_DIR}/interactive.cc
+${PROJECT_SOURCE_DIR}/jtag_dtm.cc
+${PROJECT_SOURCE_DIR}/rom.cc
+)
+message("RISCV=${RISCV_SRCS}")
+#--------------------------------------
+
+add_library(${PROJECT_NAME} INTERFACE)
+target_sources(${PROJECT_NAME} INTERFACE ${RISCV_SRCS})
+target_include_directories(${PROJECT_NAME} INTERFACE ${CMAKE_CURRENT_BINARY_DIR})
+target_link_libraries(${PROJECT_NAME} INTERFACE force_mod)
\ No newline at end of file
diff --git a/riscv/csrs.cc b/riscv/csrs.cc
index 92ec1141..13d469b6 100644
--- a/riscv/csrs.cc
+++ b/riscv/csrs.cc
@@ -182,6 +182,16 @@ bool pmpaddr_csr_t::access_ok(access_type type, reg_t mode) const noexcept {
 }
 
 
+reg_t pmpaddr_csr_t::get_tor_paddr() const noexcept {
+  return tor_paddr();
+}
+
+
+uint8_t pmpaddr_csr_t::get_cfg() const noexcept {
+  return cfg;
+}
+
+
 // implement class pmpcfg_csr_t
 pmpcfg_csr_t::pmpcfg_csr_t(processor_t* const proc, const reg_t addr):
   csr_t(proc, addr) {
diff --git a/riscv/csrs.h b/riscv/csrs.h
index e143c669..ff48db2a 100644
--- a/riscv/csrs.h
+++ b/riscv/csrs.h
@@ -77,6 +77,12 @@ class pmpaddr_csr_t: public csr_t {
   // Is the specified access allowed given the pmpcfg privileges?
   bool access_ok(access_type type, reg_t mode) const noexcept;
 
+  // Public wrapper for tor_paddr().
+  reg_t get_tor_paddr() const noexcept;
+
+  // Return the associated pmp_cfg value.
+  uint8_t get_cfg() const noexcept;
+
  protected:
   virtual bool unlogged_write(const reg_t val) noexcept override;
  private:
diff --git a/riscv/decode.h b/riscv/decode.h
index a54f1f09..d5bbb744 100644
--- a/riscv/decode.h
+++ b/riscv/decode.h
@@ -18,6 +18,9 @@
 #include "specialize.h"
 #include <cinttypes>
 
+//DEBUG
+#include <iostream>
+
 typedef int64_t sreg_t;
 typedef uint64_t reg_t;
 
@@ -146,16 +149,58 @@ private:
   uint64_t imm_sign() { return xs(63, 1); }
 };
 
+#include <typeinfo>
+extern const char* xpr_arch_name[];
+extern const char* fpr_arch_name[];
+extern "C" {
+  // update_generator_register function: for the given cpuid, this callback function is called by the simulator to notify the user that a register has been accessed.
+  //
+  //  inputs: 
+  //      uint32_t cpuid -- refers to the processor ID
+  //      const char* pRegisterName -- the name of the register (programmer's name)
+  //      uint64_t value -- the data stored in the register after update
+  //      uint64_t mask -- 1's indicate relevant bits
+  //      const char* pAccessType -- indicates if the access was a read or write.
+  //
+  void update_generator_register(uint32_t cpuid, const char* pRegisterName, uint64_t value, uint64_t mask, const char* pAccessType);  //!< update generator register information when step an instruction
+}
+
 template <class T, size_t N, bool zero_reg>
 class regfile_t
 {
 public:
+  regfile_t(size_t id): pid(id) {};
+  void set_pid(size_t id) {pid = id;};
+  void do_callback(size_t i, T value, const char access_type[]) const
+  {
+    uint64_t mask = 0xffffffffffffffffull;
+    uint64_t buffer = 0;
+
+    memcpy(&buffer, &value, sizeof(uint64_t) < sizeof(T) ? sizeof(uint64_t) : sizeof(T));
+
+    if(typeid(T) == typeid(float128_t))
+        update_generator_register(pid, fpr_arch_name[i], buffer, mask, access_type); 
+    else
+        update_generator_register(pid, xpr_arch_name[i], buffer, mask, access_type);
+  }
   void write(size_t i, T value)
+  {
+    if (!zero_reg || i != 0)
+      data[i] = value;
+
+    do_callback(i, value, "write");
+  }
+  void writeNoCallback(size_t i, T value)
   {
     if (!zero_reg || i != 0)
       data[i] = value;
   }
   const T& operator [] (size_t i) const
+  {
+    do_callback(i, data[i], "read");
+    return data[i];
+  }
+  const T& readNoCallback(size_t i) const
   {
     return data[i];
   }
@@ -168,6 +213,7 @@ public:
     memset(data, 0, sizeof(data));
   }
 private:
+  size_t pid;
   T data[N];
 };
 
@@ -224,9 +270,9 @@ private:
 #define FRS1 READ_FREG(insn.rs1())
 #define FRS2 READ_FREG(insn.rs2())
 #define FRS3 READ_FREG(insn.rs3())
-#define dirty_fp_state  STATE.sstatus->dirty(SSTATUS_FS)
-#define dirty_ext_state STATE.sstatus->dirty(SSTATUS_XS)
-#define dirty_vs_state  STATE.sstatus->dirty(SSTATUS_VS)
+#define dirty_fp_state  (STATE.sstatus->dirty(SSTATUS_FS), update_generator_register(STATE.pid, "mstatus", STATE.mstatus->read(), 0xffffffffffffffffull, "write"))
+#define dirty_ext_state (STATE.sstatus->dirty(SSTATUS_XS), update_generator_register(STATE.pid, "mstatus", STATE.mstatus->read(), 0xffffffffffffffffull, "write"))
+#define dirty_vs_state  (STATE.sstatus->dirty(SSTATUS_VS), update_generator_register(STATE.pid, "mstatus", STATE.mstatus->read(), 0xffffffffffffffffull, "write"))
 #define DO_WRITE_FREG(reg, value) (STATE.FPR.write(reg, value), dirty_fp_state)
 #define WRITE_FRD(value) WRITE_FREG(insn.rd(), value)
  
@@ -257,6 +303,7 @@ private:
     require_vector_vs; \
     require_extension('V'); \
     require(!P.VU.vill); \
+    assert(P.VU.vl <= P.VU.vlmax); \
     if (alu && !P.VU.vstart_alu) \
       require(P.VU.vstart == 0); \
     WRITE_VSTATUS; \
@@ -282,6 +329,8 @@ private:
 #define set_fp_exceptions ({ if (softfloat_exceptionFlags) { \
                                dirty_fp_state; \
                                STATE.fflags |= softfloat_exceptionFlags; \
+			       /*std::cout << "IN set_fp_exceptions, exceptions code is nonzero: " << softfloat_exceptionFlags << std::endl;*/\
+                               update_generator_register(STATE.pid, "fcsr", P.get_csr_api(CSR_FCSR), 0xffffffffffffffffull, "write"); \
                              } \
                              softfloat_exceptionFlags = 0; })
 
@@ -423,9 +472,9 @@ inline long double to_f(float128_t f){long double r; memcpy(&r, &f, sizeof(r));
   VI_MASK_VARS \
   if (insn.v_vm() == 0) { \
     BODY; \
-    bool skip = ((P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1) == 0; \
+    bool skip = ((P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1) == 0; \
     if (skip) {\
-        continue; \
+      continue; \
     }\
   }
 
@@ -594,11 +643,14 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
     require_align(insn.rs1(), P.VU.vflmul); \
 
 #define VI_CHECK_REDUCTION(is_wide) \
+  /*std::cout << "IN VI_CHECK_REDUCTION, is the is_wide test satisfied (vsew * 2 <= ELEN)?" << bool(P.VU.vsew * 2 <= P.VU.ELEN) << std::endl;*/ \
   require_vector(true);\
   if (is_wide) {\
     require(P.VU.vsew * 2 <= P.VU.ELEN); \
   } \
+  /* std::cout << "IN VI_CHECK_REDUCTION, is the alignment correct?" << bool(is_aligned(insn.rs2(), P.VU.vflmul)) << std::endl;*/ \
   require_align(insn.rs2(), P.VU.vflmul); \
+  /*std::cout << "IN VI_CHECK_REDUCTION, is vstart zero?" << bool(P.VU.vstart == 0) << std::endl;*/ \
   require(P.VU.vstart == 0); \
 
 #define VI_CHECK_SLIDE(is_over) \
@@ -648,7 +700,7 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
   for (reg_t i=P.VU.vstart; i<vl; ++i){ \
     VI_LOOP_ELEMENT_SKIP(); \
     uint64_t mmask = UINT64_C(1) << mpos; \
-    uint64_t &vdi = P.VU.elt<uint64_t>(insn.rd(), midx, true); \
+    uint64_t &vdi = P.VU.elt_ref<uint64_t>(insn.rd(), midx, true); \
     uint64_t res = 0;
 
 #define VI_LOOP_CMP_END \
@@ -664,9 +716,9 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
     int midx = i / 64; \
     int mpos = i % 64; \
     uint64_t mmask = UINT64_C(1) << mpos; \
-    uint64_t vs2 = P.VU.elt<uint64_t>(insn.rs2(), midx); \
-    uint64_t vs1 = P.VU.elt<uint64_t>(insn.rs1(), midx); \
-    uint64_t &res = P.VU.elt<uint64_t>(insn.rd(), midx, true); \
+    uint64_t vs2 = P.VU.elt_val<uint64_t>(insn.rs2(), midx); \
+    uint64_t vs1 = P.VU.elt_val<uint64_t>(insn.rs1(), midx); \
+    uint64_t &res = P.VU.elt_ref<uint64_t>(insn.rd(), midx, true); \
     res = (res & ~mmask) | ((op) & (1ULL << mpos)); \
   } \
   P.VU.vstart = 0;
@@ -705,116 +757,116 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
 // vector: integer and masking operand access helper
 //
 #define VXI_PARAMS(x) \
-  type_sew_t<x>::type &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
-  type_sew_t<x>::type vs1 = P.VU.elt<type_sew_t<x>::type>(rs1_num, i); \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i); \
+  type_sew_t<x>::type &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
+  type_sew_t<x>::type vs1 = P.VU.elt_val<type_sew_t<x>::type>(rs1_num, i); \
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i); \
   type_sew_t<x>::type rs1 = (type_sew_t<x>::type)RS1; \
   type_sew_t<x>::type simm5 = (type_sew_t<x>::type)insn.v_simm5();
 
 #define VV_U_PARAMS(x) \
-  type_usew_t<x>::type &vd = P.VU.elt<type_usew_t<x>::type>(rd_num, i, true); \
-  type_usew_t<x>::type vs1 = P.VU.elt<type_usew_t<x>::type>(rs1_num, i); \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+  type_usew_t<x>::type &vd = P.VU.elt_ref<type_usew_t<x>::type>(rd_num, i, true); \
+  type_usew_t<x>::type vs1 = P.VU.elt_val<type_usew_t<x>::type>(rs1_num, i); \
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define VX_U_PARAMS(x) \
-  type_usew_t<x>::type &vd = P.VU.elt<type_usew_t<x>::type>(rd_num, i, true); \
+  type_usew_t<x>::type &vd = P.VU.elt_ref<type_usew_t<x>::type>(rd_num, i, true); \
   type_usew_t<x>::type rs1 = (type_usew_t<x>::type)RS1; \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define VI_U_PARAMS(x) \
-  type_usew_t<x>::type &vd = P.VU.elt<type_usew_t<x>::type>(rd_num, i, true); \
+  type_usew_t<x>::type &vd = P.VU.elt_ref<type_usew_t<x>::type>(rd_num, i, true); \
   type_usew_t<x>::type zimm5 = (type_usew_t<x>::type)insn.v_zimm5(); \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define VV_PARAMS(x) \
-  type_sew_t<x>::type &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
-  type_sew_t<x>::type vs1 = P.VU.elt<type_sew_t<x>::type>(rs1_num, i); \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i);
+  type_sew_t<x>::type &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
+  type_sew_t<x>::type vs1 = P.VU.elt_val<type_sew_t<x>::type>(rs1_num, i); \
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i);
 
 #define VX_PARAMS(x) \
-  type_sew_t<x>::type &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
+  type_sew_t<x>::type &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
   type_sew_t<x>::type rs1 = (type_sew_t<x>::type)RS1; \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i);
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i);
 
 #define VI_PARAMS(x) \
-  type_sew_t<x>::type &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
+  type_sew_t<x>::type &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
   type_sew_t<x>::type simm5 = (type_sew_t<x>::type)insn.v_simm5(); \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i);
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i);
 
 #define XV_PARAMS(x) \
-  type_sew_t<x>::type &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, RS1);
+  type_sew_t<x>::type &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, RS1);
 
 #define VV_UCMP_PARAMS(x) \
-  type_usew_t<x>::type vs1 = P.VU.elt<type_usew_t<x>::type>(rs1_num, i); \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+  type_usew_t<x>::type vs1 = P.VU.elt_val<type_usew_t<x>::type>(rs1_num, i); \
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define VX_UCMP_PARAMS(x) \
   type_usew_t<x>::type rs1 = (type_usew_t<x>::type)RS1; \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define VI_UCMP_PARAMS(x) \
-  type_usew_t<x>::type vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+  type_usew_t<x>::type vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define VV_CMP_PARAMS(x) \
-  type_sew_t<x>::type vs1 = P.VU.elt<type_sew_t<x>::type>(rs1_num, i); \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i);
+  type_sew_t<x>::type vs1 = P.VU.elt_val<type_sew_t<x>::type>(rs1_num, i); \
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i);
 
 #define VX_CMP_PARAMS(x) \
   type_sew_t<x>::type rs1 = (type_sew_t<x>::type)RS1; \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i);
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i);
 
 #define VI_CMP_PARAMS(x) \
   type_sew_t<x>::type simm5 = (type_sew_t<x>::type)insn.v_simm5(); \
-  type_sew_t<x>::type vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i);
+  type_sew_t<x>::type vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i);
 
 #define VI_XI_SLIDEDOWN_PARAMS(x, off) \
-  auto &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
-  auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i + off);
+  auto &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
+  auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i + off);
 
 #define VI_XI_SLIDEUP_PARAMS(x, offset) \
-  auto &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true); \
-  auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i - offset);
+  auto &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true); \
+  auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i - offset);
 
 #define VI_NSHIFT_PARAMS(sew1, sew2) \
-  auto &vd = P.VU.elt<type_usew_t<sew1>::type>(rd_num, i, true); \
-  auto vs2_u = P.VU.elt<type_usew_t<sew2>::type>(rs2_num, i); \
-  auto vs2 = P.VU.elt<type_sew_t<sew2>::type>(rs2_num, i); \
+  auto &vd = P.VU.elt_ref<type_usew_t<sew1>::type>(rd_num, i, true); \
+  auto vs2_u = P.VU.elt_val<type_usew_t<sew2>::type>(rs2_num, i); \
+  auto vs2 = P.VU.elt_val<type_sew_t<sew2>::type>(rs2_num, i); \
   auto zimm5 = (type_usew_t<sew1>::type)insn.v_zimm5();
 
 #define VX_NSHIFT_PARAMS(sew1, sew2) \
-  auto &vd = P.VU.elt<type_usew_t<sew1>::type>(rd_num, i, true); \
-  auto vs2_u = P.VU.elt<type_usew_t<sew2>::type>(rs2_num, i); \
-  auto vs2 = P.VU.elt<type_sew_t<sew2>::type>(rs2_num, i); \
+  auto &vd = P.VU.elt_ref<type_usew_t<sew1>::type>(rd_num, i, true); \
+  auto vs2_u = P.VU.elt_val<type_usew_t<sew2>::type>(rs2_num, i); \
+  auto vs2 = P.VU.elt_val<type_sew_t<sew2>::type>(rs2_num, i); \
   auto rs1 = (type_sew_t<sew1>::type)RS1;
 
 #define VV_NSHIFT_PARAMS(sew1, sew2) \
-  auto &vd = P.VU.elt<type_usew_t<sew1>::type>(rd_num, i, true); \
-  auto vs2_u = P.VU.elt<type_usew_t<sew2>::type>(rs2_num, i); \
-  auto vs2 = P.VU.elt<type_sew_t<sew2>::type>(rs2_num, i); \
-  auto vs1 = P.VU.elt<type_sew_t<sew1>::type>(rs1_num, i);
+  auto &vd = P.VU.elt_ref<type_usew_t<sew1>::type>(rd_num, i, true); \
+  auto vs2_u = P.VU.elt_val<type_usew_t<sew2>::type>(rs2_num, i); \
+  auto vs2 = P.VU.elt_val<type_sew_t<sew2>::type>(rs2_num, i); \
+  auto vs1 = P.VU.elt_val<type_sew_t<sew1>::type>(rs1_num, i);
 
 #define XI_CARRY_PARAMS(x) \
-  auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i); \
+  auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i); \
   auto rs1 = (type_sew_t<x>::type)RS1; \
   auto simm5 = (type_sew_t<x>::type)insn.v_simm5(); \
-  auto &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
+  auto &vd = P.VU.elt_ref<uint64_t>(rd_num, midx, true);
 
 #define VV_CARRY_PARAMS(x) \
-  auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i); \
-  auto vs1 = P.VU.elt<type_sew_t<x>::type>(rs1_num, i); \
-  auto &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
+  auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i); \
+  auto vs1 = P.VU.elt_val<type_sew_t<x>::type>(rs1_num, i); \
+  auto &vd = P.VU.elt_ref<uint64_t>(rd_num, midx, true);
 
 #define XI_WITH_CARRY_PARAMS(x) \
-  auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i); \
+  auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i); \
   auto rs1 = (type_sew_t<x>::type)RS1; \
   auto simm5 = (type_sew_t<x>::type)insn.v_simm5(); \
-  auto &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true);
+  auto &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true);
 
 #define VV_WITH_CARRY_PARAMS(x) \
-  auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i); \
-  auto vs1 = P.VU.elt<type_sew_t<x>::type>(rs1_num, i); \
-  auto &vd = P.VU.elt<type_sew_t<x>::type>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i); \
+  auto vs1 = P.VU.elt_val<type_sew_t<x>::type>(rs1_num, i); \
+  auto &vd = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, i, true);
 
 //
 // vector: integer and masking operation loop
@@ -876,7 +928,9 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
   VI_LOOP_CMP_END
 
 #define VI_VV_ULOOP_CMP(BODY) \
+  /*std::cout << "IN VI_VV_ULOOP_CMP start." << std::endl;*/\
   VI_CHECK_MSS(true); \
+  /*std::cout << "IN VI_VV_ULOOP_CMP passed the VI_CHECK_MSS, sew is: " << std::hex << P.VU.vsew << std::endl;*/\
   VI_LOOP_CMP_BASE \
   if (sew == e8){ \
     VV_UCMP_PARAMS(e8); \
@@ -891,6 +945,7 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
     VV_UCMP_PARAMS(e64); \
     BODY; \
   } \
+  /*std::cout << "IN VI_VV_ULOOP_CMP passed VV_UCMP_PARAMS " << std::endl;*/\
   VI_LOOP_CMP_END
 
 #define VI_VX_ULOOP_CMP(BODY) \
@@ -954,11 +1009,11 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
   reg_t rd_num = insn.rd(); \
   reg_t rs1_num = insn.rs1(); \
   reg_t rs2_num = insn.rs2(); \
-  auto &vd_0_des = P.VU.elt<type_sew_t<x>::type>(rd_num, 0, true); \
-  auto vd_0_res = P.VU.elt<type_sew_t<x>::type>(rs1_num, 0); \
+  auto &vd_0_des = P.VU.elt_ref<type_sew_t<x>::type>(rd_num, 0, true); \
+  auto vd_0_res = P.VU.elt_val<type_sew_t<x>::type>(rs1_num, 0); \
   for (reg_t i=P.VU.vstart; i<vl; ++i){ \
     VI_LOOP_ELEMENT_SKIP(); \
-    auto vs2 = P.VU.elt<type_sew_t<x>::type>(rs2_num, i); \
+    auto vs2 = P.VU.elt_val<type_sew_t<x>::type>(rs2_num, i); \
 
 #define REDUCTION_LOOP(x, BODY) \
   VI_LOOP_REDUCTION_BASE(x) \
@@ -985,11 +1040,11 @@ static inline bool is_aligned(const unsigned val, const unsigned pos)
   reg_t rd_num = insn.rd(); \
   reg_t rs1_num = insn.rs1(); \
   reg_t rs2_num = insn.rs2(); \
-  auto &vd_0_des = P.VU.elt<type_usew_t<x>::type>(rd_num, 0, true); \
-  auto vd_0_res = P.VU.elt<type_usew_t<x>::type>(rs1_num, 0); \
+  auto &vd_0_des = P.VU.elt_ref<type_usew_t<x>::type>(rd_num, 0, true); \
+  auto vd_0_res = P.VU.elt_val<type_usew_t<x>::type>(rs1_num, 0); \
   for (reg_t i=P.VU.vstart; i<vl; ++i){ \
     VI_LOOP_ELEMENT_SKIP(); \
-    auto vs2 = P.VU.elt<type_usew_t<x>::type>(rs2_num, i);
+    auto vs2 = P.VU.elt_val<type_usew_t<x>::type>(rs2_num, i);
 
 #define REDUCTION_ULOOP(x, BODY) \
   VI_ULOOP_REDUCTION_BASE(x) \
@@ -1136,11 +1191,11 @@ if (sew == e8){ \
 VI_LOOP_END 
 
 #define VI_NARROW_SHIFT(sew1, sew2) \
-  type_usew_t<sew1>::type &vd = P.VU.elt<type_usew_t<sew1>::type>(rd_num, i, true); \
-  type_usew_t<sew2>::type vs2_u = P.VU.elt<type_usew_t<sew2>::type>(rs2_num, i); \
+  type_usew_t<sew1>::type &vd = P.VU.elt_ref<type_usew_t<sew1>::type>(rd_num, i, true); \
+  type_usew_t<sew2>::type vs2_u = P.VU.elt_val<type_usew_t<sew2>::type>(rs2_num, i); \
   type_usew_t<sew1>::type zimm5 = (type_usew_t<sew1>::type)insn.v_zimm5(); \
-  type_sew_t<sew2>::type vs2 = P.VU.elt<type_sew_t<sew2>::type>(rs2_num, i); \
-  type_sew_t<sew1>::type vs1 = P.VU.elt<type_sew_t<sew1>::type>(rs1_num, i); \
+  type_sew_t<sew2>::type vs2 = P.VU.elt_val<type_sew_t<sew2>::type>(rs2_num, i); \
+  type_sew_t<sew1>::type vs1 = P.VU.elt_val<type_sew_t<sew1>::type>(rs1_num, i); \
   type_sew_t<sew1>::type rs1 = (type_sew_t<sew1>::type)RS1; 
 
 #define VI_VVXI_LOOP_NARROW(BODY, is_vs1) \
@@ -1235,20 +1290,20 @@ VI_LOOP_END
 #define VI_WIDE_OP_AND_ASSIGN(var0, var1, var2, op0, op1, sign) \
   switch(P.VU.vsew) { \
   case e8: { \
-    sign##16_t vd_w = P.VU.elt<sign##16_t>(rd_num, i); \
-    P.VU.elt<uint16_t>(rd_num, i, true) = \
+    sign##16_t vd_w = P.VU.elt_val<sign##16_t>(rd_num, i); \
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = \
       op1((sign##16_t)(sign##8_t)var0 op0 (sign##16_t)(sign##8_t)var1) + var2; \
     } \
     break; \
   case e16: { \
-    sign##32_t vd_w = P.VU.elt<sign##32_t>(rd_num, i); \
-    P.VU.elt<uint32_t>(rd_num, i, true) = \
+    sign##32_t vd_w = P.VU.elt_val<sign##32_t>(rd_num, i); \
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = \
       op1((sign##32_t)(sign##16_t)var0 op0 (sign##32_t)(sign##16_t)var1) + var2; \
     } \
     break; \
   default: { \
-    sign##64_t vd_w = P.VU.elt<sign##64_t>(rd_num, i); \
-    P.VU.elt<uint64_t>(rd_num, i, true) = \
+    sign##64_t vd_w = P.VU.elt_val<sign##64_t>(rd_num, i); \
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = \
       op1((sign##64_t)(sign##32_t)var0 op0 (sign##64_t)(sign##32_t)var1) + var2; \
     } \
     break; \
@@ -1257,20 +1312,20 @@ VI_LOOP_END
 #define VI_WIDE_OP_AND_ASSIGN_MIX(var0, var1, var2, op0, op1, sign_d, sign_1, sign_2) \
   switch(P.VU.vsew) { \
   case e8: { \
-    sign_d##16_t vd_w = P.VU.elt<sign_d##16_t>(rd_num, i); \
-    P.VU.elt<uint16_t>(rd_num, i, true) = \
+    sign_d##16_t vd_w = P.VU.elt_val<sign_d##16_t>(rd_num, i); \
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = \
       op1((sign_1##16_t)(sign_1##8_t)var0 op0 (sign_2##16_t)(sign_2##8_t)var1) + var2; \
     } \
     break; \
   case e16: { \
-    sign_d##32_t vd_w = P.VU.elt<sign_d##32_t>(rd_num, i); \
-    P.VU.elt<uint32_t>(rd_num, i, true) = \
+    sign_d##32_t vd_w = P.VU.elt_val<sign_d##32_t>(rd_num, i); \
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = \
       op1((sign_1##32_t)(sign_1##16_t)var0 op0 (sign_2##32_t)(sign_2##16_t)var1) + var2; \
     } \
     break; \
   default: { \
-    sign_d##64_t vd_w = P.VU.elt<sign_d##64_t>(rd_num, i); \
-    P.VU.elt<uint64_t>(rd_num, i, true) = \
+    sign_d##64_t vd_w = P.VU.elt_val<sign_d##64_t>(rd_num, i); \
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = \
       op1((sign_1##64_t)(sign_1##32_t)var0 op0 (sign_2##64_t)(sign_2##32_t)var1) + var2; \
     } \
     break; \
@@ -1279,20 +1334,20 @@ VI_LOOP_END
 #define VI_WIDE_WVX_OP(var0, op0, sign) \
   switch(P.VU.vsew) { \
   case e8: { \
-    sign##16_t &vd_w = P.VU.elt<sign##16_t>(rd_num, i, true); \
-    sign##16_t vs2_w = P.VU.elt<sign##16_t>(rs2_num, i); \
+    sign##16_t &vd_w = P.VU.elt_ref<sign##16_t>(rd_num, i, true); \
+    sign##16_t vs2_w = P.VU.elt_val<sign##16_t>(rs2_num, i); \
     vd_w = vs2_w op0 (sign##16_t)(sign##8_t)var0; \
     } \
     break; \
   case e16: { \
-    sign##32_t &vd_w = P.VU.elt<sign##32_t>(rd_num, i, true); \
-    sign##32_t vs2_w = P.VU.elt<sign##32_t>(rs2_num, i); \
+    sign##32_t &vd_w = P.VU.elt_ref<sign##32_t>(rd_num, i, true); \
+    sign##32_t vs2_w = P.VU.elt_val<sign##32_t>(rs2_num, i); \
     vd_w = vs2_w op0 (sign##32_t)(sign##16_t)var0; \
     } \
     break; \
   default: { \
-    sign##64_t &vd_w = P.VU.elt<sign##64_t>(rd_num, i, true); \
-    sign##64_t vs2_w = P.VU.elt<sign##64_t>(rs2_num, i); \
+    sign##64_t &vd_w = P.VU.elt_ref<sign##64_t>(rd_num, i, true); \
+    sign##64_t vs2_w = P.VU.elt_val<sign##64_t>(rs2_num, i); \
     vd_w = vs2_w op0 (sign##64_t)(sign##32_t)var0; \
     } \
     break; \
@@ -1304,11 +1359,11 @@ VI_LOOP_END
   reg_t rd_num = insn.rd(); \
   reg_t rs1_num = insn.rs1(); \
   reg_t rs2_num = insn.rs2(); \
-  auto &vd_0_des = P.VU.elt<type_sew_t<sew2>::type>(rd_num, 0, true); \
-  auto vd_0_res = P.VU.elt<type_sew_t<sew2>::type>(rs1_num, 0); \
+  auto &vd_0_des = P.VU.elt_ref<type_sew_t<sew2>::type>(rd_num, 0, true); \
+  auto vd_0_res = P.VU.elt_val<type_sew_t<sew2>::type>(rs1_num, 0); \
   for (reg_t i=P.VU.vstart; i<vl; ++i){ \
     VI_LOOP_ELEMENT_SKIP(); \
-    auto vs2 = P.VU.elt<type_sew_t<sew1>::type>(rs2_num, i);
+    auto vs2 = P.VU.elt_val<type_sew_t<sew1>::type>(rs2_num, i);
 
 #define WIDE_REDUCTION_LOOP(sew1, sew2, BODY) \
   VI_LOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
@@ -1332,11 +1387,11 @@ VI_LOOP_END
   reg_t rd_num = insn.rd(); \
   reg_t rs1_num = insn.rs1(); \
   reg_t rs2_num = insn.rs2(); \
-  auto &vd_0_des = P.VU.elt<type_usew_t<sew2>::type>(rd_num, 0, true); \
-  auto vd_0_res = P.VU.elt<type_usew_t<sew2>::type>(rs1_num, 0); \
+  auto &vd_0_des = P.VU.elt_ref<type_usew_t<sew2>::type>(rd_num, 0, true); \
+  auto vd_0_res = P.VU.elt_val<type_usew_t<sew2>::type>(rs1_num, 0); \
   for (reg_t i=P.VU.vstart; i<vl; ++i) { \
     VI_LOOP_ELEMENT_SKIP(); \
-    auto vs2 = P.VU.elt<type_usew_t<sew1>::type>(rs2_num, i);
+    auto vs2 = P.VU.elt_val<type_usew_t<sew1>::type>(rs2_num, i);
 
 #define WIDE_REDUCTION_ULOOP(sew1, sew2, BODY) \
   VI_ULOOP_WIDE_REDUCTION_BASE(sew1, sew2) \
@@ -1525,16 +1580,16 @@ reg_t index[P.VU.vlmax]; \
 for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   switch(idx_sew) { \
     case e8: \
-      index[i] = P.VU.elt<uint8_t>(reg_num, i); \
+      index[i] = P.VU.elt_val<uint8_t>(reg_num, i); \
       break; \
     case e16: \
-      index[i] = P.VU.elt<uint16_t>(reg_num, i); \
+      index[i] = P.VU.elt_val<uint16_t>(reg_num, i); \
       break; \
     case e32: \
-      index[i] = P.VU.elt<uint32_t>(reg_num, i); \
+      index[i] = P.VU.elt_val<uint32_t>(reg_num, i); \
       break; \
     case e64: \
-      index[i] = P.VU.elt<uint64_t>(reg_num, i); \
+      index[i] = P.VU.elt_val<uint64_t>(reg_num, i); \
       break; \
   } \
 }
@@ -1552,7 +1607,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
     for (reg_t fn = 0; fn < nf; ++fn) { \
       elt_width##_t val = MMU.load_##elt_width( \
         baseAddr + (stride) + (offset) * sizeof(elt_width##_t)); \
-      P.VU.elt<elt_width##_t>(vd + fn * emul, vreg_inx, true) = val; \
+      P.VU.elt_ref<elt_width##_t>(vd + fn * emul, vreg_inx, true) = val; \
     } \
   } \
   P.VU.vstart = 0;
@@ -1573,19 +1628,19 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
     for (reg_t fn = 0; fn < nf; ++fn) { \
       switch(P.VU.vsew){ \
         case e8: \
-          P.VU.elt<uint8_t>(vd + fn * flmul, vreg_inx, true) = \
+          P.VU.elt_ref<uint8_t>(vd + fn * flmul, vreg_inx, true) = \
             MMU.load_uint8(baseAddr + index[i] + fn * 1); \
           break; \
         case e16: \
-          P.VU.elt<uint16_t>(vd + fn * flmul, vreg_inx, true) = \
+          P.VU.elt_ref<uint16_t>(vd + fn * flmul, vreg_inx, true) = \
             MMU.load_uint16(baseAddr + index[i] + fn * 2); \
           break; \
         case e32: \
-          P.VU.elt<uint32_t>(vd + fn * flmul, vreg_inx, true) = \
+          P.VU.elt_ref<uint32_t>(vd + fn * flmul, vreg_inx, true) = \
             MMU.load_uint32(baseAddr + index[i] + fn * 4); \
           break; \
         default: \
-          P.VU.elt<uint64_t>(vd + fn * flmul, vreg_inx, true) = \
+          P.VU.elt_ref<uint64_t>(vd + fn * flmul, vreg_inx, true) = \
             MMU.load_uint64(baseAddr + index[i] + fn * 8); \
           break; \
       } \
@@ -1604,7 +1659,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
     VI_ELEMENT_SKIP(i); \
     P.VU.vstart = i; \
     for (reg_t fn = 0; fn < nf; ++fn) { \
-      elt_width##_t val = P.VU.elt<elt_width##_t>(vs3 + fn * emul, vreg_inx); \
+      elt_width##_t val = P.VU.elt_val<elt_width##_t>(vs3 + fn * emul, vreg_inx); \
       MMU.store_##elt_width( \
         baseAddr + (stride) + (offset) * sizeof(elt_width##_t), val); \
     } \
@@ -1628,19 +1683,19 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
       switch (P.VU.vsew) { \
       case e8: \
         MMU.store_uint8(baseAddr + index[i] + fn * 1, \
-          P.VU.elt<uint8_t>(vs3 + fn * flmul, vreg_inx)); \
+          P.VU.elt_val<uint8_t>(vs3 + fn * flmul, vreg_inx)); \
         break; \
       case e16: \
         MMU.store_uint16(baseAddr + index[i] + fn * 2, \
-          P.VU.elt<uint16_t>(vs3 + fn * flmul, vreg_inx)); \
+          P.VU.elt_val<uint16_t>(vs3 + fn * flmul, vreg_inx)); \
         break; \
       case e32: \
         MMU.store_uint32(baseAddr + index[i] + fn * 4, \
-          P.VU.elt<uint32_t>(vs3 + fn * flmul, vreg_inx)); \
+          P.VU.elt_val<uint32_t>(vs3 + fn * flmul, vreg_inx)); \
         break; \
       default: \
         MMU.store_uint64(baseAddr + index[i] + fn * 8, \
-          P.VU.elt<uint64_t>(vs3 + fn * flmul, vreg_inx)); \
+          P.VU.elt_val<uint64_t>(vs3 + fn * flmul, vreg_inx)); \
         break; \
       } \
     } \
@@ -1672,7 +1727,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
         P.VU.vl = i; \
         break; \
       } \
-      p->VU.elt<elt_width##_t>(rd_num + fn * emul, vreg_inx, true) = val; \
+      p->VU.elt_ref<elt_width##_t>(rd_num + fn * emul, vreg_inx, true) = val; \
     } \
     \
     if (early_stop) { \
@@ -1696,7 +1751,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
       for (reg_t pos = off; pos < elt_per_reg; ++pos) { \
         auto val = MMU.load_## elt_width(baseAddr + \
           P.VU.vstart * sizeof(elt_width ## _t)); \
-        P.VU.elt<elt_width ## _t>(vd + i, pos, true) = val; \
+        P.VU.elt_ref<elt_width ## _t>(vd + i, pos, true) = val; \
         P.VU.vstart++; \
       } \
       ++i; \
@@ -1705,7 +1760,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
       for (reg_t pos = 0; pos < elt_per_reg; ++pos) { \
         auto val = MMU.load_## elt_width(baseAddr + \
           P.VU.vstart * sizeof(elt_width ## _t)); \
-        P.VU.elt<elt_width ## _t>(vd + i, pos, true) = val; \
+        P.VU.elt_ref<elt_width ## _t>(vd + i, pos, true) = val; \
         P.VU.vstart++; \
       } \
     } \
@@ -1725,7 +1780,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
     reg_t off = P.VU.vstart % P.VU.vlenb; \
     if (off) { \
       for (reg_t pos = off; pos < P.VU.vlenb; ++pos) { \
-        auto val = P.VU.elt<uint8_t>(vs3 + i, pos); \
+        auto val = P.VU.elt_val<uint8_t>(vs3 + i, pos); \
         MMU.store_uint8(baseAddr + P.VU.vstart, val); \
         P.VU.vstart++; \
       } \
@@ -1733,7 +1788,7 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
     } \
     for (; i < len; ++i) { \
       for (reg_t pos = 0; pos < P.VU.vlenb; ++pos) { \
-        auto val = P.VU.elt<uint8_t>(vs3 + i, pos); \
+        auto val = P.VU.elt_val<uint8_t>(vs3 + i, pos); \
         MMU.store_uint8(baseAddr + P.VU.vstart, val); \
         P.VU.vstart++; \
       } \
@@ -1775,17 +1830,17 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
     P.VU.vstart = i; \
     switch (P.VU.vsew) { \
     case e32: {\
-      auto vs3 = P.VU.elt< type ## 32_t>(vd, vreg_inx); \
+      auto vs3 = P.VU.elt_val< type ## 32_t>(vd, vreg_inx); \
       auto val = MMU.amo_uint32(baseAddr + index[i], [&]( type ## 32_t lhs) { op }); \
       if (insn.v_wd()) \
-        P.VU.elt< type ## 32_t>(vd, vreg_inx, true) = val; \
+        P.VU.elt_ref< type ## 32_t>(vd, vreg_inx, true) = val; \
       } \
       break; \
     case e64: {\
-      auto vs3 = P.VU.elt< type ## 64_t>(vd, vreg_inx); \
+      auto vs3 = P.VU.elt_val< type ## 64_t>(vd, vreg_inx); \
       auto val = MMU.amo_uint64(baseAddr + index[i], [&]( type ## 64_t lhs) { op }); \
       if (insn.v_wd()) \
-        P.VU.elt< type ## 64_t>(vd, vreg_inx, true) = val; \
+        P.VU.elt_ref< type ## 64_t>(vd, vreg_inx, true) = val; \
       } \
       break; \
     default: \
@@ -1814,25 +1869,25 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_LOOP_ELEMENT_SKIP(); \
     switch (pat) { \
       case 0x21: \
-        P.VU.elt<type##16_t>(rd_num, i, true) = P.VU.elt<type##8_t>(rs2_num, i); \
+        P.VU.elt_ref<type##16_t>(rd_num, i, true) = P.VU.elt_val<type##8_t>(rs2_num, i); \
         break; \
       case 0x41: \
-        P.VU.elt<type##32_t>(rd_num, i, true) = P.VU.elt<type##8_t>(rs2_num, i); \
+        P.VU.elt_ref<type##32_t>(rd_num, i, true) = P.VU.elt_val<type##8_t>(rs2_num, i); \
         break; \
       case 0x81: \
-        P.VU.elt<type##64_t>(rd_num, i, true) = P.VU.elt<type##8_t>(rs2_num, i); \
+        P.VU.elt_ref<type##64_t>(rd_num, i, true) = P.VU.elt_val<type##8_t>(rs2_num, i); \
         break; \
       case 0x42: \
-        P.VU.elt<type##32_t>(rd_num, i, true) = P.VU.elt<type##16_t>(rs2_num, i); \
+        P.VU.elt_ref<type##32_t>(rd_num, i, true) = P.VU.elt_val<type##16_t>(rs2_num, i); \
         break; \
       case 0x82: \
-        P.VU.elt<type##64_t>(rd_num, i, true) = P.VU.elt<type##16_t>(rs2_num, i); \
+        P.VU.elt_ref<type##64_t>(rd_num, i, true) = P.VU.elt_val<type##16_t>(rs2_num, i); \
         break; \
       case 0x84: \
-        P.VU.elt<type##64_t>(rd_num, i, true) = P.VU.elt<type##32_t>(rs2_num, i); \
+        P.VU.elt_ref<type##64_t>(rd_num, i, true) = P.VU.elt_val<type##32_t>(rs2_num, i); \
         break; \
       case 0x88: \
-        P.VU.elt<type##64_t>(rd_num, i, true) = P.VU.elt<type##32_t>(rs2_num, i); \
+        P.VU.elt_ref<type##64_t>(rd_num, i, true) = P.VU.elt_val<type##32_t>(rs2_num, i); \
         break; \
       default: \
         break; \
@@ -1843,11 +1898,14 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
 // vector: vfp helper
 //
 #define VI_VFP_COMMON \
+  /*std::cout << "IN VI_VFP_COMMON about to check for fp and if vsew is 16 bits if EXT_ZFH is supported" << std::endl;*/\
   require_fp; \
   require((P.VU.vsew == e16 && p->extension_enabled(EXT_ZFH)) || \
           (P.VU.vsew == e32 && p->extension_enabled('F')) || \
           (P.VU.vsew == e64 && p->extension_enabled('D'))); \
+  /*std::cout << "IN VI_VFP_COMMON passed vsew and fp checks" << std::endl;*/\
   require_vector(true);\
+  /*std::cout << "IN VI_VFP_COMMON passed vector check" << std::endl;*/\
   require(STATE.frm < 0x5);\
   reg_t vl = P.VU.vl; \
   reg_t rd_num = insn.rd(); \
@@ -1865,22 +1923,22 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   for (reg_t i = P.VU.vstart; i < vl; ++i) { \
     VI_LOOP_ELEMENT_SKIP(); \
     uint64_t mmask = UINT64_C(1) << mpos; \
-    uint64_t &vdi = P.VU.elt<uint64_t>(rd_num, midx, true); \
+    uint64_t &vdi = P.VU.elt_ref<uint64_t>(rd_num, midx, true); \
     uint64_t res = 0;
 
 #define VI_VFP_LOOP_REDUCTION_BASE(width) \
-  float##width##_t vd_0 = P.VU.elt<float##width##_t>(rd_num, 0); \
-  float##width##_t vs1_0 = P.VU.elt<float##width##_t>(rs1_num, 0); \
+  float##width##_t vd_0 = P.VU.elt_val<float##width##_t>(rd_num, 0); \
+  float##width##_t vs1_0 = P.VU.elt_val<float##width##_t>(rs1_num, 0); \
   vd_0 = vs1_0; \
   bool is_active = false; \
   for (reg_t i=P.VU.vstart; i<vl; ++i){ \
     VI_LOOP_ELEMENT_SKIP(); \
-    float##width##_t vs2 = P.VU.elt<float##width##_t>(rs2_num, i); \
+    float##width##_t vs2 = P.VU.elt_val<float##width##_t>(rs2_num, i); \
     is_active = true; \
 
 #define VI_VFP_LOOP_WIDE_REDUCTION_BASE \
   VI_VFP_COMMON \
-  float64_t vd_0 = f64(P.VU.elt<float64_t>(rs1_num, 0).v); \
+  float64_t vd_0 = f64(P.VU.elt_val<float64_t>(rs1_num, 0).v); \
   for (reg_t i=P.VU.vstart; i<vl; ++i) { \
     VI_LOOP_ELEMENT_SKIP();
 
@@ -1901,9 +1959,9 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
                 softfloat_exceptionFlags |= softfloat_flag_invalid; \
                 set_fp_exceptions; \
               } \
-              P.VU.elt<uint16_t>(rd_num, 0, true) = defaultNaNF16UI; \
+              P.VU.elt_ref<uint16_t>(rd_num, 0, true) = defaultNaNF16UI; \
             } else { \
-              P.VU.elt<uint16_t>(rd_num, 0, true) = vd_0.v; \
+              P.VU.elt_ref<uint16_t>(rd_num, 0, true) = vd_0.v; \
             } \
           } \
           break; \
@@ -1914,9 +1972,9 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
                 softfloat_exceptionFlags |= softfloat_flag_invalid; \
                 set_fp_exceptions; \
               } \
-              P.VU.elt<uint32_t>(rd_num, 0, true) = defaultNaNF32UI; \
+              P.VU.elt_ref<uint32_t>(rd_num, 0, true) = defaultNaNF32UI; \
             } else { \
-              P.VU.elt<uint32_t>(rd_num, 0, true) = vd_0.v; \
+              P.VU.elt_ref<uint32_t>(rd_num, 0, true) = vd_0.v; \
             } \
           } \
           break; \
@@ -1927,15 +1985,15 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
                 softfloat_exceptionFlags |= softfloat_flag_invalid; \
                 set_fp_exceptions; \
               } \
-              P.VU.elt<uint64_t>(rd_num, 0, true) = defaultNaNF64UI; \
+              P.VU.elt_ref<uint64_t>(rd_num, 0, true) = defaultNaNF64UI; \
             } else { \
-              P.VU.elt<uint64_t>(rd_num, 0, true) = vd_0.v; \
+              P.VU.elt_ref<uint64_t>(rd_num, 0, true) = vd_0.v; \
             } \
           } \
           break; \
       } \
     } else { \
-      P.VU.elt<type_sew_t<x>::type>(rd_num, 0, true) = vd_0.v; \
+      P.VU.elt_ref<type_sew_t<x>::type>(rd_num, 0, true) = vd_0.v; \
     } \
   }
 
@@ -1959,25 +2017,25 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float16_t &vd = P.VU.elt<float16_t>(rd_num, i, true); \
-      float16_t vs1 = P.VU.elt<float16_t>(rs1_num, i); \
-      float16_t vs2 = P.VU.elt<float16_t>(rs2_num, i); \
+      float16_t &vd = P.VU.elt_ref<float16_t>(rd_num, i, true); \
+      float16_t vs1 = P.VU.elt_val<float16_t>(rs1_num, i); \
+      float16_t vs2 = P.VU.elt_val<float16_t>(rs2_num, i); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     }\
     case e32: {\
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
-      float32_t vs1 = P.VU.elt<float32_t>(rs1_num, i); \
-      float32_t vs2 = P.VU.elt<float32_t>(rs2_num, i); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
+      float32_t vs1 = P.VU.elt_val<float32_t>(rs1_num, i); \
+      float32_t vs2 = P.VU.elt_val<float32_t>(rs2_num, i); \
       BODY32; \
       set_fp_exceptions; \
       break; \
     }\
     case e64: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
-      float64_t vs1 = P.VU.elt<float64_t>(rs1_num, i); \
-      float64_t vs2 = P.VU.elt<float64_t>(rs2_num, i); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
+      float64_t vs1 = P.VU.elt_val<float64_t>(rs1_num, i); \
+      float64_t vs2 = P.VU.elt_val<float64_t>(rs2_num, i); \
       BODY64; \
       set_fp_exceptions; \
       break; \
@@ -1994,20 +2052,20 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float16_t &vd = P.VU.elt<float16_t>(rd_num, i, true); \
-      float16_t vs2 = P.VU.elt<float16_t>(rs2_num, i); \
+      float16_t &vd = P.VU.elt_ref<float16_t>(rd_num, i, true); \
+      float16_t vs2 = P.VU.elt_val<float16_t>(rs2_num, i); \
       BODY16; \
       break; \
     }\
     case e32: {\
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
-      float32_t vs2 = P.VU.elt<float32_t>(rs2_num, i); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
+      float32_t vs2 = P.VU.elt_val<float32_t>(rs2_num, i); \
       BODY32; \
       break; \
     }\
     case e64: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
-      float64_t vs2 = P.VU.elt<float64_t>(rs2_num, i); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
+      float64_t vs2 = P.VU.elt_val<float64_t>(rs2_num, i); \
       BODY64; \
       break; \
     }\
@@ -2049,35 +2107,45 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   }; \
 
 #define VI_VFP_VV_LOOP_WIDE_REDUCTION(BODY16, BODY32) \
+  /*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION and P.VU.vsew is:" << std::hex << P.VU.vsew  << std::endl;*/\
+  /*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION and p supports F?:" << p->supports_extension('F')  << std::endl;*/\
+  /*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION and p supports D?:" << p->supports_extension('D')  << std::endl;*/\
   VI_CHECK_REDUCTION(true) \
+  /*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION going to call common." << std::endl;*/\
   VI_VFP_COMMON \
   require((P.VU.vsew == e16 && p->extension_enabled('F')) || \
           (P.VU.vsew == e32 && p->extension_enabled('D'))); \
   bool is_active = false; \
+  /*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION passed the checks." << std::endl;*/\
   switch(P.VU.vsew) { \
     case e16: {\
-      float32_t vd_0 = P.VU.elt<float32_t>(rs1_num, 0); \
+      float32_t vd_0 = P.VU.elt_val<float32_t>(rs1_num, 0); \
       for (reg_t i=P.VU.vstart; i<vl; ++i) { \
         VI_LOOP_ELEMENT_SKIP(); \
         is_active = true; \
-        float32_t vs2 = f16_to_f32(P.VU.elt<float16_t>(rs2_num, i)); \
+        float32_t vs2 = f16_to_f32(P.VU.elt_val<float16_t>(rs2_num, i)); \
         BODY16; \
+  	/*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION gonna check fp exceptions." << std::endl;*/\
         set_fp_exceptions; \
+  	/*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION passed fp exceptions check." << std::endl;*/\
       VI_VFP_LOOP_REDUCTION_END(e32) \
       break; \
     }\
     case e32: {\
-      float64_t vd_0 = P.VU.elt<float64_t>(rs1_num, 0); \
+      float64_t vd_0 = P.VU.elt_val<float64_t>(rs1_num, 0); \
       for (reg_t i=P.VU.vstart; i<vl; ++i) { \
         VI_LOOP_ELEMENT_SKIP(); \
         is_active = true; \
-        float64_t vs2 = f32_to_f64(P.VU.elt<float32_t>(rs2_num, i)); \
+        float64_t vs2 = f32_to_f64(P.VU.elt_val<float32_t>(rs2_num, i)); \
         BODY32; \
+  	/*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION gonna check fp exceptions." << std::endl;*/\
         set_fp_exceptions; \
+  	/*std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION passed fp exceptions check." << std::endl;*/\
       VI_VFP_LOOP_REDUCTION_END(e64) \
       break; \
     }\
     default: \
+      /* std::cout << "IN VI_VFP_VV_LOOP_WIDE_REDUCTION and P.VU.vsew doesn't match an active case. it is instead:" << std::hex << P.VU.vsew  << std::endl;*/\
       require(0); \
       break; \
   }; \
@@ -2087,25 +2155,25 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float16_t &vd = P.VU.elt<float16_t>(rd_num, i, true); \
+      float16_t &vd = P.VU.elt_ref<float16_t>(rd_num, i, true); \
       float16_t rs1 = f16(READ_FREG(rs1_num)); \
-      float16_t vs2 = P.VU.elt<float16_t>(rs2_num, i); \
+      float16_t vs2 = P.VU.elt_val<float16_t>(rs2_num, i); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     }\
     case e32: {\
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
       float32_t rs1 = f32(READ_FREG(rs1_num)); \
-      float32_t vs2 = P.VU.elt<float32_t>(rs2_num, i); \
+      float32_t vs2 = P.VU.elt_val<float32_t>(rs2_num, i); \
       BODY32; \
       set_fp_exceptions; \
       break; \
     }\
     case e64: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
       float64_t rs1 = f64(READ_FREG(rs1_num)); \
-      float64_t vs2 = P.VU.elt<float64_t>(rs2_num, i); \
+      float64_t vs2 = P.VU.elt_val<float64_t>(rs2_num, i); \
       BODY64; \
       set_fp_exceptions; \
       break; \
@@ -2122,24 +2190,24 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_CMP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float16_t vs2 = P.VU.elt<float16_t>(rs2_num, i); \
-      float16_t vs1 = P.VU.elt<float16_t>(rs1_num, i); \
+      float16_t vs2 = P.VU.elt_val<float16_t>(rs2_num, i); \
+      float16_t vs1 = P.VU.elt_val<float16_t>(rs1_num, i); \
       float16_t rs1 = f16(READ_FREG(rs1_num)); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     }\
     case e32: {\
-      float32_t vs2 = P.VU.elt<float32_t>(rs2_num, i); \
-      float32_t vs1 = P.VU.elt<float32_t>(rs1_num, i); \
+      float32_t vs2 = P.VU.elt_val<float32_t>(rs2_num, i); \
+      float32_t vs1 = P.VU.elt_val<float32_t>(rs1_num, i); \
       float32_t rs1 = f32(READ_FREG(rs1_num)); \
       BODY32; \
       set_fp_exceptions; \
       break; \
     }\
     case e64: {\
-      float64_t vs2 = P.VU.elt<float64_t>(rs2_num, i); \
-      float64_t vs1 = P.VU.elt<float64_t>(rs1_num, i); \
+      float64_t vs2 = P.VU.elt_val<float64_t>(rs2_num, i); \
+      float64_t vs1 = P.VU.elt_val<float64_t>(rs1_num, i); \
       float64_t rs1 = f64(READ_FREG(rs1_num)); \
       BODY64; \
       set_fp_exceptions; \
@@ -2156,16 +2224,16 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: { \
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
-      float32_t vs2 = f16_to_f32(P.VU.elt<float16_t>(rs2_num, i)); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
+      float32_t vs2 = f16_to_f32(P.VU.elt_val<float16_t>(rs2_num, i)); \
       float32_t rs1 = f16_to_f32(f16(READ_FREG(rs1_num))); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     } \
     case e32: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
-      float64_t vs2 = f32_to_f64(P.VU.elt<float32_t>(rs2_num, i)); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
+      float64_t vs2 = f32_to_f64(P.VU.elt_val<float32_t>(rs2_num, i)); \
       float64_t rs1 = f32_to_f64(f32(READ_FREG(rs1_num))); \
       BODY32; \
       set_fp_exceptions; \
@@ -2184,17 +2252,17 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
-      float32_t vs2 = f16_to_f32(P.VU.elt<float16_t>(rs2_num, i)); \
-      float32_t vs1 = f16_to_f32(P.VU.elt<float16_t>(rs1_num, i)); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
+      float32_t vs2 = f16_to_f32(P.VU.elt_val<float16_t>(rs2_num, i)); \
+      float32_t vs1 = f16_to_f32(P.VU.elt_val<float16_t>(rs1_num, i)); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     }\
     case e32: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
-      float64_t vs2 = f32_to_f64(P.VU.elt<float32_t>(rs2_num, i)); \
-      float64_t vs1 = f32_to_f64(P.VU.elt<float32_t>(rs1_num, i)); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
+      float64_t vs2 = f32_to_f64(P.VU.elt_val<float32_t>(rs2_num, i)); \
+      float64_t vs1 = f32_to_f64(P.VU.elt_val<float32_t>(rs1_num, i)); \
       BODY32; \
       set_fp_exceptions; \
       break; \
@@ -2211,16 +2279,16 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
-      float32_t vs2 = P.VU.elt<float32_t>(rs2_num, i); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
+      float32_t vs2 = P.VU.elt_val<float32_t>(rs2_num, i); \
       float32_t rs1 = f16_to_f32(f16(READ_FREG(rs1_num))); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     }\
     case e32: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
-      float64_t vs2 = P.VU.elt<float64_t>(rs2_num, i); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
+      float64_t vs2 = P.VU.elt_val<float64_t>(rs2_num, i); \
       float64_t rs1 = f32_to_f64(f32(READ_FREG(rs1_num))); \
       BODY32; \
       set_fp_exceptions; \
@@ -2237,17 +2305,17 @@ for (reg_t i = 0; i < P.VU.vlmax && P.VU.vl != 0; ++i) { \
   VI_VFP_LOOP_BASE \
   switch(P.VU.vsew) { \
     case e16: {\
-      float32_t &vd = P.VU.elt<float32_t>(rd_num, i, true); \
-      float32_t vs2 = P.VU.elt<float32_t>(rs2_num, i); \
-      float32_t vs1 = f16_to_f32(P.VU.elt<float16_t>(rs1_num, i)); \
+      float32_t &vd = P.VU.elt_ref<float32_t>(rd_num, i, true); \
+      float32_t vs2 = P.VU.elt_val<float32_t>(rs2_num, i); \
+      float32_t vs1 = f16_to_f32(P.VU.elt_val<float16_t>(rs1_num, i)); \
       BODY16; \
       set_fp_exceptions; \
       break; \
     }\
     case e32: {\
-      float64_t &vd = P.VU.elt<float64_t>(rd_num, i, true); \
-      float64_t vs2 = P.VU.elt<float64_t>(rs2_num, i); \
-      float64_t vs1 = f32_to_f64(P.VU.elt<float32_t>(rs1_num, i)); \
+      float64_t &vd = P.VU.elt_ref<float64_t>(rd_num, i, true); \
+      float64_t vs2 = P.VU.elt_val<float64_t>(rs2_num, i); \
+      float64_t vs1 = f32_to_f64(P.VU.elt_val<float32_t>(rs1_num, i)); \
       BODY32; \
       set_fp_exceptions; \
       break; \
diff --git a/riscv/disasm.h b/riscv/disasm.h
index 8e600316..b7f68bfc 100644
--- a/riscv/disasm.h
+++ b/riscv/disasm.h
@@ -8,8 +8,8 @@
 #include <sstream>
 #include <vector>
 
-extern const char* xpr_name[NXPR];
-extern const char* fpr_name[NFPR];
+extern const char* xpr_arch_name[NXPR];
+extern const char* fpr_arch_name[NFPR];
 extern const char* vr_name[NVPR];
 extern const char* csr_name(int which);
 
diff --git a/riscv/dts.cc b/riscv/dts.cc
index 46000d8f..431af029 100644
--- a/riscv/dts.cc
+++ b/riscv/dts.cc
@@ -136,17 +136,17 @@ std::string dts_compile(const std::string& dts)
   }
 
   // Child process to output dtb
-  if (dtb_pid == 0) {
-    dup2(dts_pipe[0], 0);
-    dup2(dtb_pipe[1], 1);
-    close(dts_pipe[0]);
-    close(dts_pipe[1]);
-    close(dtb_pipe[0]);
-    close(dtb_pipe[1]);
-    execlp(DTC, DTC, "-O", "dtb", 0);
-    std::cerr << "Failed to run " DTC ": " << strerror(errno) << std::endl;
-    exit(1);
-  }
+//   if (dtb_pid == 0) {
+//     dup2(dts_pipe[0], 0);
+//     dup2(dtb_pipe[1], 1);
+//     close(dts_pipe[0]);
+//     close(dts_pipe[1]);
+//     close(dtb_pipe[0]);
+//     close(dtb_pipe[1]);
+//     execlp(DTC, DTC, "-O", "dtb", 0);
+//     std::cerr << "Failed to run " DTC ": " << strerror(errno) << std::endl;
+//     exit(1);
+//   }
 
   close(dts_pipe[1]);
   close(dts_pipe[0]);
@@ -168,16 +168,16 @@ std::string dts_compile(const std::string& dts)
 
   // Reap children
   int status;
-  waitpid(dts_pid, &status, 0);
-  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
-    std::cerr << "Child dts process failed" << std::endl;
-    exit(1);
-  }
-  waitpid(dtb_pid, &status, 0);
-  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
-    std::cerr << "Child dtb process failed" << std::endl;
-    exit(1);
-  }
+//   waitpid(dts_pid, &status, 0);
+//   if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
+//     std::cerr << "Child dts process failed" << std::endl;
+//     exit(1);
+//   }
+//   waitpid(dtb_pid, &status, 0);
+//   if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
+//     std::cerr << "Child dtb process failed" << std::endl;
+//     exit(1);
+//   }
 
   return dtb.str();
 }
diff --git a/riscv/execute.cc b/riscv/execute.cc
index 53f956c5..8a933d3c 100644
--- a/riscv/execute.cc
+++ b/riscv/execute.cc
@@ -27,26 +27,26 @@ static void commit_log_print_value(FILE *log_file, int width, const void *data)
 
   switch (width) {
     case 8:
-      fprintf(log_file, "0x%01" PRIx8, *(const uint8_t *)data);
+      //fprintf(log_file, "0x%01" PRIx8, *(const uint8_t *)data);
       break;
     case 16:
-      fprintf(log_file, "0x%04" PRIx16, *(const uint16_t *)data);
+      //fprintf(log_file, "0x%04" PRIx16, *(const uint16_t *)data);
       break;
     case 32:
-      fprintf(log_file, "0x%08" PRIx32, *(const uint32_t *)data);
+      //fprintf(log_file, "0x%08" PRIx32, *(const uint32_t *)data);
       break;
     case 64:
-      fprintf(log_file, "0x%016" PRIx64, *(const uint64_t *)data);
+      //fprintf(log_file, "0x%016" PRIx64, *(const uint64_t *)data);
       break;
     default:
       // max lengh of vector
       if (((width - 1) & width) == 0) {
         const uint64_t *arr = (const uint64_t *)data;
 
-        fprintf(log_file, "0x");
-        for (int idx = width / 64 - 1; idx >= 0; --idx) {
-          fprintf(log_file, "%016" PRIx64, arr[idx]);
-        }
+        //fprintf(log_file, "0x");
+        //for (int idx = width / 64 - 1; idx >= 0; --idx) {
+        //  fprintf(log_file, "%016" PRIx64, arr[idx]);
+        //}
       } else {
         abort();
       }
@@ -76,13 +76,13 @@ static void commit_log_print_insn(processor_t *p, reg_t pc, insn_t insn)
   int flen = p->get_state()->last_inst_flen;
 
   // print core id on all lines so it is easy to grep
-  fprintf(log_file, "core%4" PRId32 ": ", p->get_id());
+  //fprintf(log_file, "core%4" PRId32 ": ", p->get_id());
 
-  fprintf(log_file, "%1d ", priv);
+  //fprintf(log_file, "%1d ", priv);
   commit_log_print_value(log_file, xlen, pc);
-  fprintf(log_file, " (");
+  //fprintf(log_file, " (");
   commit_log_print_value(log_file, insn.length() * 8, insn.bits());
-  fprintf(log_file, ")");
+  //fprintf(log_file, ")");
   bool show_vec = false;
 
   for (auto item : reg) {
@@ -121,19 +121,19 @@ static void commit_log_print_insn(processor_t *p, reg_t pc, insn_t insn)
     }
 
     if (!show_vec && (is_vreg || is_vec)) {
-        fprintf(log_file, " e%ld %s%ld l%ld",
-                p->VU.vsew,
-                p->VU.vflmul < 1 ? "mf" : "m",
-                p->VU.vflmul < 1 ? (reg_t)(1 / p->VU.vflmul) : (reg_t)p->VU.vflmul,
-                p->VU.vl);
+        //fprintf(log_file, " e%ld %s%ld l%ld",
+        //        p->VU.vsew,
+        //        p->VU.vflmul < 1 ? "mf" : "m",
+        //        p->VU.vflmul < 1 ? (reg_t)(1 / p->VU.vflmul) : (reg_t)p->VU.vflmul,
+        //        p->VU.vl);
         show_vec = true;
     }
 
     if (!is_vec) {
       if (prefix == 'c')
-        fprintf(log_file, " c%d_%s ", rd, csr_name(rd));
+        //fprintf(log_file, " c%d_%s ", rd, csr_name(rd));
       else
-        fprintf(log_file, " %c%2d ", prefix, rd);
+        //fprintf(log_file, " %c%2d ", prefix, rd);
       if (is_vreg)
         commit_log_print_value(log_file, size, &p->VU.elt<uint8_t>(rd, 0));
       else
@@ -142,17 +142,17 @@ static void commit_log_print_insn(processor_t *p, reg_t pc, insn_t insn)
   }
 
   for (auto item : load) {
-    fprintf(log_file, " mem ");
+    //fprintf(log_file, " mem ");
     commit_log_print_value(log_file, xlen, std::get<0>(item));
   }
 
   for (auto item : store) {
-    fprintf(log_file, " mem ");
+    //fprintf(log_file, " mem ");
     commit_log_print_value(log_file, xlen, std::get<0>(item));
-    fprintf(log_file, " ");
+    //fprintf(log_file, " ");
     commit_log_print_value(log_file, std::get<2>(item) << 3, std::get<1>(item));
   }
-  fprintf(log_file, "\n");
+  //fprintf(log_file, "\n");
 }
 #else
 static void commit_log_reset(processor_t* p) {}
@@ -256,7 +256,7 @@ void processor_t::step(size_t n)
     {
       take_pending_interrupt();
 
-      if (unlikely(slow_path()))
+      if (true || unlikely(slow_path()))
       {
         // Main simulation loop, slow path.
         while (instret < n)
@@ -275,8 +275,8 @@ void processor_t::step(size_t n)
           }
 
           insn_fetch_t fetch = mmu->load_insn(pc);
-          if (debug && !state.serialized)
-            disasm(fetch.insn);
+          //if (debug && !state.serialized)
+          //  disasm(fetch.insn);
           pc = execute_insn(this, pc, fetch);
           advance_pc();
         }
diff --git a/riscv/insns/mret.h b/riscv/insns/mret.h
index 44a6aa92..29d93b0d 100644
--- a/riscv/insns/mret.h
+++ b/riscv/insns/mret.h
@@ -1,6 +1,8 @@
 require_privilege(PRV_M);
 set_pc_and_serialize(p->get_state()->mepc->read());
 reg_t s = STATE.mstatus->read();
+SimException exit_m(0x4e, 0, "exit_mret", p->get_state()->mepc->read());
+update_exception_event(&exit_m); 
 reg_t prev_prv = get_field(s, MSTATUS_MPP);
 reg_t prev_virt = get_field(s, MSTATUS_MPV);
 if (prev_prv != PRV_M)
diff --git a/riscv/insns/sret.h b/riscv/insns/sret.h
index 72b44ef3..31ea8f7a 100644
--- a/riscv/insns/sret.h
+++ b/riscv/insns/sret.h
@@ -8,13 +8,15 @@ if (STATE.v) {
 reg_t next_pc = p->get_state()->sepc->read();
 set_pc_and_serialize(next_pc);
 reg_t s = STATE.sstatus->read();
+SimException exit_s(0x4e, 0, "exit_sret", next_pc);
+update_exception_event(&exit_s);
 reg_t prev_prv = get_field(s, MSTATUS_SPP);
 if (prev_prv != PRV_M)
   s = set_field(s, MSTATUS_MPRV, 0);
 s = set_field(s, MSTATUS_SIE, get_field(s, MSTATUS_SPIE));
 s = set_field(s, MSTATUS_SPIE, 1);
 s = set_field(s, MSTATUS_SPP, PRV_U);
-STATE.sstatus->write(s);
+p->set_csr(CSR_SSTATUS, s);
 p->set_privilege(prev_prv);
 if (!STATE.v) {
   reg_t prev_virt = get_field(STATE.hstatus->read(), HSTATUS_SPV);
diff --git a/riscv/insns/vadc_vim.h b/riscv/insns/vadc_vim.h
index 824fac97..deb06314 100644
--- a/riscv/insns/vadc_vim.h
+++ b/riscv/insns/vadc_vim.h
@@ -1,7 +1,7 @@
 // vadc.vim vd, vs2, simm5, v0
 VI_XI_LOOP_WITH_CARRY
 ({
-  auto &v0 = P.VU.elt<uint64_t>(0, midx);
+  auto &v0 = P.VU.elt_ref<uint64_t>(0, midx);
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = (v0 >> mpos) & 0x1;
 
diff --git a/riscv/insns/vadc_vvm.h b/riscv/insns/vadc_vvm.h
index 2d6803a8..df1c488c 100644
--- a/riscv/insns/vadc_vvm.h
+++ b/riscv/insns/vadc_vvm.h
@@ -1,7 +1,7 @@
 // vadc.vvm vd, vs2, rs1, v0
 VI_VV_LOOP_WITH_CARRY
 ({
-  auto &v0 = P.VU.elt<uint64_t>(0, midx);
+  auto &v0 = P.VU.elt_ref<uint64_t>(0, midx);
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = (v0 >> mpos) & 0x1;
 
diff --git a/riscv/insns/vadc_vxm.h b/riscv/insns/vadc_vxm.h
index 0d2d052c..5c410c1a 100644
--- a/riscv/insns/vadc_vxm.h
+++ b/riscv/insns/vadc_vxm.h
@@ -1,7 +1,7 @@
 // vadc.vxm vd, vs2, rs1, v0
 VI_XI_LOOP_WITH_CARRY
 ({
-  auto &v0 = P.VU.elt<uint64_t>(0, midx);
+  auto &v0 = P.VU.elt_ref<uint64_t>(0, midx);
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = (v0 >> mpos) & 0x1;
 
diff --git a/riscv/insns/vcompress_vm.h b/riscv/insns/vcompress_vm.h
index 325e40ad..335584d3 100644
--- a/riscv/insns/vcompress_vm.h
+++ b/riscv/insns/vcompress_vm.h
@@ -11,20 +11,20 @@ VI_GENERAL_LOOP_BASE
   const int midx = i / 64;
   const int mpos = i % 64;
 
-  bool do_mask = (P.VU.elt<uint64_t>(rs1_num, midx) >> mpos) & 0x1;
+  bool do_mask = (P.VU.elt_val<uint64_t>(rs1_num, midx) >> mpos) & 0x1;
   if (do_mask) {
     switch (sew) {
     case e8:
-      P.VU.elt<uint8_t>(rd_num, pos, true) = P.VU.elt<uint8_t>(rs2_num, i);
+      P.VU.elt_ref<uint8_t>(rd_num, pos, true) = P.VU.elt_val<uint8_t>(rs2_num, i);
       break;
     case e16:
-      P.VU.elt<uint16_t>(rd_num, pos, true) = P.VU.elt<uint16_t>(rs2_num, i);
+      P.VU.elt_ref<uint16_t>(rd_num, pos, true) = P.VU.elt_val<uint16_t>(rs2_num, i);
       break;
     case e32:
-      P.VU.elt<uint32_t>(rd_num, pos, true) = P.VU.elt<uint32_t>(rs2_num, i);
+      P.VU.elt_ref<uint32_t>(rd_num, pos, true) = P.VU.elt_val<uint32_t>(rs2_num, i);
       break;
     default:
-      P.VU.elt<uint64_t>(rd_num, pos, true) = P.VU.elt<uint64_t>(rs2_num, i);
+      P.VU.elt_ref<uint64_t>(rd_num, pos, true) = P.VU.elt_val<uint64_t>(rs2_num, i);
       break;
     }
 
diff --git a/riscv/insns/vcpop_m.h b/riscv/insns/vcpop_m.h
index c204b2c0..1d0cb9d0 100644
--- a/riscv/insns/vcpop_m.h
+++ b/riscv/insns/vcpop_m.h
@@ -11,11 +11,11 @@ for (reg_t i=P.VU.vstart; i<vl; ++i) {
   const int midx = i / 32;
   const int mpos = i % 32;
 
-  bool vs2_lsb = ((P.VU.elt<uint32_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
+  bool vs2_lsb = ((P.VU.elt_val<uint32_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
   if (insn.v_vm() == 1) {
     popcount += vs2_lsb;
   } else {
-    bool do_mask = (P.VU.elt<uint32_t>(0, midx) >> mpos) & 0x1;
+    bool do_mask = (P.VU.elt_val<uint32_t>(0, midx) >> mpos) & 0x1;
     popcount += (vs2_lsb && do_mask);
   }
 }
diff --git a/riscv/insns/vfcvt_f_x_v.h b/riscv/insns/vfcvt_f_x_v.h
index c53b0e1f..36049e81 100644
--- a/riscv/insns/vfcvt_f_x_v.h
+++ b/riscv/insns/vfcvt_f_x_v.h
@@ -1,14 +1,14 @@
 // vfcvt.f.x.v vd, vd2, vm
 VI_VFP_VF_LOOP
 ({
-  auto vs2_i = P.VU.elt<int16_t>(rs2_num, i);
+  auto vs2_i = P.VU.elt_val<int16_t>(rs2_num, i);
   vd = i32_to_f16(vs2_i);
 },
 {
-  auto vs2_i = P.VU.elt<int32_t>(rs2_num, i);
+  auto vs2_i = P.VU.elt_val<int32_t>(rs2_num, i);
   vd = i32_to_f32(vs2_i);
 },
 {
-  auto vs2_i = P.VU.elt<int64_t>(rs2_num, i);
+  auto vs2_i = P.VU.elt_val<int64_t>(rs2_num, i);
   vd = i64_to_f64(vs2_i);
 })
diff --git a/riscv/insns/vfcvt_f_xu_v.h b/riscv/insns/vfcvt_f_xu_v.h
index bd03768d..13b0b6dc 100644
--- a/riscv/insns/vfcvt_f_xu_v.h
+++ b/riscv/insns/vfcvt_f_xu_v.h
@@ -1,14 +1,14 @@
 // vfcvt.f.xu.v vd, vd2, vm
 VI_VFP_VF_LOOP
 ({
-  auto vs2_u = P.VU.elt<uint16_t>(rs2_num, i);
+  auto vs2_u = P.VU.elt_val<uint16_t>(rs2_num, i);
   vd = ui32_to_f16(vs2_u);
 },
 {
-  auto vs2_u = P.VU.elt<uint32_t>(rs2_num, i);
+  auto vs2_u = P.VU.elt_val<uint32_t>(rs2_num, i);
   vd = ui32_to_f32(vs2_u);
 },
 {
-  auto vs2_u = P.VU.elt<uint64_t>(rs2_num, i);
+  auto vs2_u = P.VU.elt_val<uint64_t>(rs2_num, i);
   vd = ui64_to_f64(vs2_u);
 })
diff --git a/riscv/insns/vfcvt_rtz_x_f_v.h b/riscv/insns/vfcvt_rtz_x_f_v.h
index e7241bd0..88901195 100644
--- a/riscv/insns/vfcvt_rtz_x_f_v.h
+++ b/riscv/insns/vfcvt_rtz_x_f_v.h
@@ -1,11 +1,11 @@
 // vfcvt.rtz.x.f.v vd, vd2, vm
 VI_VFP_VF_LOOP
 ({
-  P.VU.elt<int16_t>(rd_num, i) = f16_to_i16(vs2, softfloat_round_minMag, true);
+  P.VU.elt_ref<int16_t>(rd_num, i) = f16_to_i16(vs2, softfloat_round_minMag, true);
 },
 {
-  P.VU.elt<int32_t>(rd_num, i) = f32_to_i32(vs2, softfloat_round_minMag, true);
+  P.VU.elt_ref<int32_t>(rd_num, i) = f32_to_i32(vs2, softfloat_round_minMag, true);
 },
 {
-  P.VU.elt<int64_t>(rd_num, i) = f64_to_i64(vs2, softfloat_round_minMag, true);
+  P.VU.elt_ref<int64_t>(rd_num, i) = f64_to_i64(vs2, softfloat_round_minMag, true);
 })
diff --git a/riscv/insns/vfcvt_rtz_xu_f_v.h b/riscv/insns/vfcvt_rtz_xu_f_v.h
index d3d266d0..27e2948a 100644
--- a/riscv/insns/vfcvt_rtz_xu_f_v.h
+++ b/riscv/insns/vfcvt_rtz_xu_f_v.h
@@ -1,11 +1,11 @@
 // vfcvt.rtz.xu.f.v vd, vd2, vm
 VI_VFP_VF_LOOP
 ({
-  P.VU.elt<uint16_t>(rd_num, i) = f16_to_ui16(vs2, softfloat_round_minMag, true);
+  P.VU.elt_ref<uint16_t>(rd_num, i) = f16_to_ui16(vs2, softfloat_round_minMag, true);
 },
 {
-  P.VU.elt<uint32_t>(rd_num, i) = f32_to_ui32(vs2, softfloat_round_minMag, true);
+  P.VU.elt_ref<uint32_t>(rd_num, i) = f32_to_ui32(vs2, softfloat_round_minMag, true);
 },
 {
-  P.VU.elt<uint64_t>(rd_num, i) = f64_to_ui64(vs2, softfloat_round_minMag, true);
+  P.VU.elt_ref<uint64_t>(rd_num, i) = f64_to_ui64(vs2, softfloat_round_minMag, true);
 })
diff --git a/riscv/insns/vfcvt_x_f_v.h b/riscv/insns/vfcvt_x_f_v.h
index 01e5ca17..b2a21dd4 100644
--- a/riscv/insns/vfcvt_x_f_v.h
+++ b/riscv/insns/vfcvt_x_f_v.h
@@ -1,11 +1,11 @@
 // vfcvt.x.f.v vd, vd2, vm
 VI_VFP_VF_LOOP
 ({
-  P.VU.elt<int16_t>(rd_num, i) = f16_to_i16(vs2, STATE.frm, true);
+  P.VU.elt_ref<int16_t>(rd_num, i) = f16_to_i16(vs2, STATE.frm, true);
 },
 {
-  P.VU.elt<int32_t>(rd_num, i) = f32_to_i32(vs2, STATE.frm, true);
+  P.VU.elt_ref<int32_t>(rd_num, i) = f32_to_i32(vs2, STATE.frm, true);
 },
 {
-  P.VU.elt<int64_t>(rd_num, i) = f64_to_i64(vs2, STATE.frm, true);
+  P.VU.elt_ref<int64_t>(rd_num, i) = f64_to_i64(vs2, STATE.frm, true);
 })
diff --git a/riscv/insns/vfcvt_xu_f_v.h b/riscv/insns/vfcvt_xu_f_v.h
index 725cbda2..0ad527fa 100644
--- a/riscv/insns/vfcvt_xu_f_v.h
+++ b/riscv/insns/vfcvt_xu_f_v.h
@@ -1,11 +1,11 @@
 // vfcvt.xu.f.v vd, vd2, vm
 VI_VFP_VV_LOOP
 ({
-  P.VU.elt<uint16_t>(rd_num, i) = f16_to_ui16(vs2, STATE.frm, true);
+  P.VU.elt_ref<uint16_t>(rd_num, i) = f16_to_ui16(vs2, STATE.frm, true);
 },
 {
-  P.VU.elt<uint32_t>(rd_num, i) = f32_to_ui32(vs2, STATE.frm, true);
+  P.VU.elt_ref<uint32_t>(rd_num, i) = f32_to_ui32(vs2, STATE.frm, true);
 },
 {
-  P.VU.elt<uint64_t>(rd_num, i) = f64_to_ui64(vs2, STATE.frm, true);
+  P.VU.elt_ref<uint64_t>(rd_num, i) = f64_to_ui64(vs2, STATE.frm, true);
 })
diff --git a/riscv/insns/vfirst_m.h b/riscv/insns/vfirst_m.h
index 30957237..9de7631d 100644
--- a/riscv/insns/vfirst_m.h
+++ b/riscv/insns/vfirst_m.h
@@ -10,7 +10,7 @@ reg_t pos = -1;
 for (reg_t i=P.VU.vstart; i < vl; ++i) {
   VI_LOOP_ELEMENT_SKIP()
 
-  bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
+  bool vs2_lsb = ((P.VU.elt_val<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
   if (vs2_lsb) {
     pos = i;
     break;
diff --git a/riscv/insns/vfmerge_vfm.h b/riscv/insns/vfmerge_vfm.h
index c9b39fe0..1cdd608d 100644
--- a/riscv/insns/vfmerge_vfm.h
+++ b/riscv/insns/vfmerge_vfm.h
@@ -5,39 +5,39 @@ VI_VFP_COMMON;
 switch(P.VU.vsew) {
   case e16:
     for (reg_t i=P.VU.vstart; i<vl; ++i) {
-      auto &vd = P.VU.elt<float16_t>(rd_num, i, true);
+      auto &vd = P.VU.elt_ref<float16_t>(rd_num, i, true);
       auto rs1 = f16(READ_FREG(rs1_num));
-      auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
+      auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
 
       int midx = i / 64;
       int mpos = i % 64;
-      bool use_first = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+      bool use_first = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
       vd = use_first ? rs1 : vs2;
     }
     break;
   case e32:
     for (reg_t i=P.VU.vstart; i<vl; ++i) {
-      auto &vd = P.VU.elt<float32_t>(rd_num, i, true);
+      auto &vd = P.VU.elt_ref<float32_t>(rd_num, i, true);
       auto rs1 = f32(READ_FREG(rs1_num));
-      auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
+      auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
 
       int midx = i / 64;
       int mpos = i % 64;
-      bool use_first = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+      bool use_first = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
       vd = use_first ? rs1 : vs2;
     }
     break;
   case e64:
     for (reg_t i=P.VU.vstart; i<vl; ++i) {
-      auto &vd = P.VU.elt<float64_t>(rd_num, i, true);
+      auto &vd = P.VU.elt_ref<float64_t>(rd_num, i, true);
       auto rs1 = f64(READ_FREG(rs1_num));
-      auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
+      auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
 
       int midx = i / 64;
       int mpos = i % 64;
-      bool use_first = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+      bool use_first = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
       vd = use_first ? rs1 : vs2;
     }
diff --git a/riscv/insns/vfmv_f_s.h b/riscv/insns/vfmv_f_s.h
index 3309e471..77bdf67a 100644
--- a/riscv/insns/vfmv_f_s.h
+++ b/riscv/insns/vfmv_f_s.h
@@ -11,13 +11,13 @@ uint64_t vs2_0 = 0;
 const reg_t sew = P.VU.vsew;
 switch(sew) {
   case e16:
-    vs2_0 = P.VU.elt<uint16_t>(rs2_num, 0);
+    vs2_0 = P.VU.elt_val<uint16_t>(rs2_num, 0);
     break;
   case e32:
-    vs2_0 = P.VU.elt<uint32_t>(rs2_num, 0);
+    vs2_0 = P.VU.elt_val<uint32_t>(rs2_num, 0);
     break;
   case e64:
-    vs2_0 = P.VU.elt<uint64_t>(rs2_num, 0);
+    vs2_0 = P.VU.elt_val<uint64_t>(rs2_num, 0);
     break;
   default:
     require(0);
diff --git a/riscv/insns/vfmv_s_f.h b/riscv/insns/vfmv_s_f.h
index d12fd916..d4f78122 100644
--- a/riscv/insns/vfmv_s_f.h
+++ b/riscv/insns/vfmv_s_f.h
@@ -13,16 +13,16 @@ if (vl > 0 && P.VU.vstart < vl) {
 
   switch(P.VU.vsew) {
     case e16:
-      P.VU.elt<uint16_t>(rd_num, 0, true) = f16(FRS1).v;
+      P.VU.elt_ref<uint16_t>(rd_num, 0, true) = f16(FRS1).v;
       break;
     case e32:
-      P.VU.elt<uint32_t>(rd_num, 0, true) = f32(FRS1).v;
+      P.VU.elt_ref<uint32_t>(rd_num, 0, true) = f32(FRS1).v;
       break;
     case e64:
       if (FLEN == 64)
-        P.VU.elt<uint64_t>(rd_num, 0, true) = f64(FRS1).v;
+        P.VU.elt_ref<uint64_t>(rd_num, 0, true) = f64(FRS1).v;
       else
-        P.VU.elt<uint64_t>(rd_num, 0, true) = f32(FRS1).v;
+        P.VU.elt_ref<uint64_t>(rd_num, 0, true) = f32(FRS1).v;
       break;
   }
 }
diff --git a/riscv/insns/vfmv_v_f.h b/riscv/insns/vfmv_v_f.h
index fb9c7882..e2b9b7d5 100644
--- a/riscv/insns/vfmv_v_f.h
+++ b/riscv/insns/vfmv_v_f.h
@@ -4,7 +4,7 @@ VI_VFP_COMMON
 switch(P.VU.vsew) {
   case e16:
     for (reg_t i=P.VU.vstart; i<vl; ++i) {
-      auto &vd = P.VU.elt<float16_t>(rd_num, i, true);
+      auto &vd = P.VU.elt_ref<float16_t>(rd_num, i, true);
       auto rs1 = f16(READ_FREG(rs1_num));
 
       vd = rs1;
@@ -12,7 +12,7 @@ switch(P.VU.vsew) {
     break;
   case e32:
     for (reg_t i=P.VU.vstart; i<vl; ++i) {
-      auto &vd = P.VU.elt<float32_t>(rd_num, i, true);
+      auto &vd = P.VU.elt_ref<float32_t>(rd_num, i, true);
       auto rs1 = f32(READ_FREG(rs1_num));
 
       vd = rs1;
@@ -20,7 +20,7 @@ switch(P.VU.vsew) {
     break;
   case e64:
     for (reg_t i=P.VU.vstart; i<vl; ++i) {
-      auto &vd = P.VU.elt<float64_t>(rd_num, i, true);
+      auto &vd = P.VU.elt_ref<float64_t>(rd_num, i, true);
       auto rs1 = f64(READ_FREG(rs1_num));
 
       vd = rs1;
diff --git a/riscv/insns/vfncvt_f_f_w.h b/riscv/insns/vfncvt_f_f_w.h
index 5448eb5e..4c891788 100644
--- a/riscv/insns/vfncvt_f_f_w.h
+++ b/riscv/insns/vfncvt_f_f_w.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<float16_t>(rd_num, i, true) = f32_to_f16(vs2);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<float16_t>(rd_num, i, true) = f32_to_f16(vs2);
 },
 {
-  auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = f64_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = f64_to_f32(vs2);
 },
 {
   ;
diff --git a/riscv/insns/vfncvt_f_x_w.h b/riscv/insns/vfncvt_f_x_w.h
index 10a6f7b1..5cafcb22 100644
--- a/riscv/insns/vfncvt_f_x_w.h
+++ b/riscv/insns/vfncvt_f_x_w.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<int32_t>(rs2_num, i);
-  P.VU.elt<float16_t>(rd_num, i, true) = i32_to_f16(vs2);
+  auto vs2 = P.VU.elt_val<int32_t>(rs2_num, i);
+  P.VU.elt_ref<float16_t>(rd_num, i, true) = i32_to_f16(vs2);
 },
 {
-  auto vs2 = P.VU.elt<int64_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = i64_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<int64_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = i64_to_f32(vs2);
 },
 {
   ;
diff --git a/riscv/insns/vfncvt_f_xu_w.h b/riscv/insns/vfncvt_f_xu_w.h
index 32b4b026..52985b13 100644
--- a/riscv/insns/vfncvt_f_xu_w.h
+++ b/riscv/insns/vfncvt_f_xu_w.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<uint32_t>(rs2_num, i);
-  P.VU.elt<float16_t>(rd_num, i, true) = ui32_to_f16(vs2);
+  auto vs2 = P.VU.elt_val<uint32_t>(rs2_num, i);
+  P.VU.elt_ref<float16_t>(rd_num, i, true) = ui32_to_f16(vs2);
 },
 {
-  auto vs2 = P.VU.elt<uint64_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = ui64_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<uint64_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = ui64_to_f32(vs2);
 },
 {
   ;
diff --git a/riscv/insns/vfncvt_rod_f_f_w.h b/riscv/insns/vfncvt_rod_f_f_w.h
index 20a14c90..dd9161da 100644
--- a/riscv/insns/vfncvt_rod_f_f_w.h
+++ b/riscv/insns/vfncvt_rod_f_f_w.h
@@ -5,13 +5,13 @@ VI_VFP_CVT_SCALE
 },
 {
   softfloat_roundingMode = softfloat_round_odd;
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<float16_t>(rd_num, i, true) = f32_to_f16(vs2);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<float16_t>(rd_num, i, true) = f32_to_f16(vs2);
 },
 {
   softfloat_roundingMode = softfloat_round_odd;
-  auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = f64_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = f64_to_f32(vs2);
 },
 {
   ;
diff --git a/riscv/insns/vfncvt_rtz_x_f_w.h b/riscv/insns/vfncvt_rtz_x_f_w.h
index 0629b8d9..a23161a9 100644
--- a/riscv/insns/vfncvt_rtz_x_f_w.h
+++ b/riscv/insns/vfncvt_rtz_x_f_w.h
@@ -1,16 +1,16 @@
 // vfncvt.rtz.x.f.w vd, vs2, vm
 VI_VFP_CVT_SCALE
 ({
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<int8_t>(rd_num, i, true) = f16_to_i8(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<int8_t>(rd_num, i, true) = f16_to_i8(vs2, softfloat_round_minMag, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<int16_t>(rd_num, i, true) = f32_to_i16(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<int16_t>(rd_num, i, true) = f32_to_i16(vs2, softfloat_round_minMag, true);
 },
 {
-  auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
-  P.VU.elt<int32_t>(rd_num, i, true) = f64_to_i32(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
+  P.VU.elt_ref<int32_t>(rd_num, i, true) = f64_to_i32(vs2, softfloat_round_minMag, true);
 },
 {
   require(p->extension_enabled(EXT_ZFH));
diff --git a/riscv/insns/vfncvt_rtz_xu_f_w.h b/riscv/insns/vfncvt_rtz_xu_f_w.h
index 82aa63e8..93d94ca6 100644
--- a/riscv/insns/vfncvt_rtz_xu_f_w.h
+++ b/riscv/insns/vfncvt_rtz_xu_f_w.h
@@ -1,16 +1,16 @@
 // vfncvt.rtz.xu.f.w vd, vs2, vm
 VI_VFP_CVT_SCALE
 ({
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<uint8_t>(rd_num, i, true) = f16_to_ui8(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<uint8_t>(rd_num, i, true) = f16_to_ui8(vs2, softfloat_round_minMag, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<uint16_t>(rd_num, i, true) = f32_to_ui16(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<uint16_t>(rd_num, i, true) = f32_to_ui16(vs2, softfloat_round_minMag, true);
 },
 {
-  auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
-  P.VU.elt<uint32_t>(rd_num, i, true) = f64_to_ui32(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
+  P.VU.elt_ref<uint32_t>(rd_num, i, true) = f64_to_ui32(vs2, softfloat_round_minMag, true);
 },
 {
   require(p->extension_enabled(EXT_ZFH));
diff --git a/riscv/insns/vfncvt_x_f_w.h b/riscv/insns/vfncvt_x_f_w.h
index a342e3fd..8e8093d3 100644
--- a/riscv/insns/vfncvt_x_f_w.h
+++ b/riscv/insns/vfncvt_x_f_w.h
@@ -1,16 +1,16 @@
 // vfncvt.x.f.w vd, vs2, vm
 VI_VFP_CVT_SCALE
 ({
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<int8_t>(rd_num, i, true) = f16_to_i8(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<int8_t>(rd_num, i, true) = f16_to_i8(vs2, STATE.frm, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<int16_t>(rd_num, i, true) = f32_to_i16(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<int16_t>(rd_num, i, true) = f32_to_i16(vs2, STATE.frm, true);
 },
 {
-  auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
-  P.VU.elt<int32_t>(rd_num, i, true) = f64_to_i32(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
+  P.VU.elt_ref<int32_t>(rd_num, i, true) = f64_to_i32(vs2, STATE.frm, true);
 },
 {
   require(p->extension_enabled(EXT_ZFH));
diff --git a/riscv/insns/vfncvt_xu_f_w.h b/riscv/insns/vfncvt_xu_f_w.h
index 6fda694a..48206285 100644
--- a/riscv/insns/vfncvt_xu_f_w.h
+++ b/riscv/insns/vfncvt_xu_f_w.h
@@ -1,16 +1,16 @@
 // vfncvt.xu.f.w vd, vs2, vm
 VI_VFP_CVT_SCALE
 ({
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<uint8_t>(rd_num, i, true) = f16_to_ui8(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<uint8_t>(rd_num, i, true) = f16_to_ui8(vs2, STATE.frm, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<uint16_t>(rd_num, i, true) = f32_to_ui16(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<uint16_t>(rd_num, i, true) = f32_to_ui16(vs2, STATE.frm, true);
 },
 {
-  auto vs2 = P.VU.elt<float64_t>(rs2_num, i);
-  P.VU.elt<uint32_t>(rd_num, i, true) = f64_to_ui32(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float64_t>(rs2_num, i);
+  P.VU.elt_ref<uint32_t>(rd_num, i, true) = f64_to_ui32(vs2, STATE.frm, true);
 },
 {
   require(p->extension_enabled(EXT_ZFH));
diff --git a/riscv/insns/vfslide1down_vf.h b/riscv/insns/vfslide1down_vf.h
index 66eeaccb..d850feba 100644
--- a/riscv/insns/vfslide1down_vf.h
+++ b/riscv/insns/vfslide1down_vf.h
@@ -23,13 +23,13 @@ if (i != vl - 1) {
 } else {
   switch (P.VU.vsew) {
     case e16:
-      P.VU.elt<float16_t>(rd_num, vl - 1, true) = f16(FRS1);
+      P.VU.elt_ref<float16_t>(rd_num, vl - 1, true) = f16(FRS1);
       break;
     case e32:
-      P.VU.elt<float32_t>(rd_num, vl - 1, true) = f32(FRS1);
+      P.VU.elt_ref<float32_t>(rd_num, vl - 1, true) = f32(FRS1);
       break;
     case e64:
-      P.VU.elt<float64_t>(rd_num, vl - 1, true) = f64(FRS1);
+      P.VU.elt_ref<float64_t>(rd_num, vl - 1, true) = f64(FRS1);
       break;
   }
 }
diff --git a/riscv/insns/vfslide1up_vf.h b/riscv/insns/vfslide1up_vf.h
index b9c2817c..50188a14 100644
--- a/riscv/insns/vfslide1up_vf.h
+++ b/riscv/insns/vfslide1up_vf.h
@@ -23,13 +23,13 @@ if (i != 0) {
 } else {
   switch (P.VU.vsew) {
     case e16:
-      P.VU.elt<float16_t>(rd_num, 0, true) = f16(FRS1);
+      P.VU.elt_ref<float16_t>(rd_num, 0, true) = f16(FRS1);
       break;
     case e32:
-      P.VU.elt<float32_t>(rd_num, 0, true) = f32(FRS1);
+      P.VU.elt_ref<float32_t>(rd_num, 0, true) = f32(FRS1);
       break;
     case e64:
-      P.VU.elt<float64_t>(rd_num, 0, true) = f64(FRS1);
+      P.VU.elt_ref<float64_t>(rd_num, 0, true) = f64(FRS1);
       break;
   }
 }
diff --git a/riscv/insns/vfwcvt_f_f_v.h b/riscv/insns/vfwcvt_f_f_v.h
index fcaf65c8..56c7c8c9 100644
--- a/riscv/insns/vfwcvt_f_f_v.h
+++ b/riscv/insns/vfwcvt_f_f_v.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = f16_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = f16_to_f32(vs2);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<float64_t>(rd_num, i, true) = f32_to_f64(vs2);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<float64_t>(rd_num, i, true) = f32_to_f64(vs2);
 },
 {
   ;
diff --git a/riscv/insns/vfwcvt_f_x_v.h b/riscv/insns/vfwcvt_f_x_v.h
index 8d8283c9..8d620457 100644
--- a/riscv/insns/vfwcvt_f_x_v.h
+++ b/riscv/insns/vfwcvt_f_x_v.h
@@ -1,16 +1,16 @@
 // vfwcvt.f.x.v vd, vs2, vm
 VI_VFP_CVT_SCALE
 ({
-  auto vs2 = P.VU.elt<int8_t>(rs2_num, i);
-  P.VU.elt<float16_t>(rd_num, i, true) = i32_to_f16(vs2);
+  auto vs2 = P.VU.elt_val<int8_t>(rs2_num, i);
+  P.VU.elt_ref<float16_t>(rd_num, i, true) = i32_to_f16(vs2);
 },
 {
-  auto vs2 = P.VU.elt<int16_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = i32_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<int16_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = i32_to_f32(vs2);
 },
 {
-  auto vs2 = P.VU.elt<int32_t>(rs2_num, i);
-  P.VU.elt<float64_t>(rd_num, i, true) = i32_to_f64(vs2);
+  auto vs2 = P.VU.elt_val<int32_t>(rs2_num, i);
+  P.VU.elt_ref<float64_t>(rd_num, i, true) = i32_to_f64(vs2);
 },
 {
   require(p->extension_enabled(EXT_ZFH));
diff --git a/riscv/insns/vfwcvt_f_xu_v.h b/riscv/insns/vfwcvt_f_xu_v.h
index e8036ce5..36d4a51c 100644
--- a/riscv/insns/vfwcvt_f_xu_v.h
+++ b/riscv/insns/vfwcvt_f_xu_v.h
@@ -1,16 +1,16 @@
 // vfwcvt.f.xu.v vd, vs2, vm
 VI_VFP_CVT_SCALE
 ({
-  auto vs2 = P.VU.elt<uint8_t>(rs2_num, i);
-  P.VU.elt<float16_t>(rd_num, i, true) = ui32_to_f16(vs2);
+  auto vs2 = P.VU.elt_val<uint8_t>(rs2_num, i);
+  P.VU.elt_ref<float16_t>(rd_num, i, true) = ui32_to_f16(vs2);
 },
 {
-  auto vs2 = P.VU.elt<uint16_t>(rs2_num, i);
-  P.VU.elt<float32_t>(rd_num, i, true) = ui32_to_f32(vs2);
+  auto vs2 = P.VU.elt_val<uint16_t>(rs2_num, i);
+  P.VU.elt_ref<float32_t>(rd_num, i, true) = ui32_to_f32(vs2);
 },
 {
-  auto vs2 = P.VU.elt<uint32_t>(rs2_num, i);
-  P.VU.elt<float64_t>(rd_num, i, true) = ui32_to_f64(vs2);
+  auto vs2 = P.VU.elt_val<uint32_t>(rs2_num, i);
+  P.VU.elt_ref<float64_t>(rd_num, i, true) = ui32_to_f64(vs2);
 },
 {
   require(p->extension_enabled(EXT_ZFH));
diff --git a/riscv/insns/vfwcvt_rtz_x_f_v.h b/riscv/insns/vfwcvt_rtz_x_f_v.h
index 83fa7649..439f1a28 100644
--- a/riscv/insns/vfwcvt_rtz_x_f_v.h
+++ b/riscv/insns/vfwcvt_rtz_x_f_v.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<int32_t>(rd_num, i, true) = f16_to_i32(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<int32_t>(rd_num, i, true) = f16_to_i32(vs2, softfloat_round_minMag, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<int64_t>(rd_num, i, true) = f32_to_i64(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<int64_t>(rd_num, i, true) = f32_to_i64(vs2, softfloat_round_minMag, true);
 },
 {
   ;
diff --git a/riscv/insns/vfwcvt_rtz_xu_f_v.h b/riscv/insns/vfwcvt_rtz_xu_f_v.h
index 43d19794..4d389e7e 100644
--- a/riscv/insns/vfwcvt_rtz_xu_f_v.h
+++ b/riscv/insns/vfwcvt_rtz_xu_f_v.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<uint32_t>(rd_num, i, true) = f16_to_ui32(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<uint32_t>(rd_num, i, true) = f16_to_ui32(vs2, softfloat_round_minMag, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<uint64_t>(rd_num, i, true) = f32_to_ui64(vs2, softfloat_round_minMag, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<uint64_t>(rd_num, i, true) = f32_to_ui64(vs2, softfloat_round_minMag, true);
 },
 {
   ;
diff --git a/riscv/insns/vfwcvt_x_f_v.h b/riscv/insns/vfwcvt_x_f_v.h
index 60ebbcab..d382af58 100644
--- a/riscv/insns/vfwcvt_x_f_v.h
+++ b/riscv/insns/vfwcvt_x_f_v.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<int32_t>(rd_num, i, true) = f16_to_i32(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<int32_t>(rd_num, i, true) = f16_to_i32(vs2, STATE.frm, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<int64_t>(rd_num, i, true) = f32_to_i64(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<int64_t>(rd_num, i, true) = f32_to_i64(vs2, STATE.frm, true);
 },
 {
   ;
diff --git a/riscv/insns/vfwcvt_xu_f_v.h b/riscv/insns/vfwcvt_xu_f_v.h
index a6a05912..d61523f7 100644
--- a/riscv/insns/vfwcvt_xu_f_v.h
+++ b/riscv/insns/vfwcvt_xu_f_v.h
@@ -4,12 +4,12 @@ VI_VFP_CVT_SCALE
   ;
 },
 {
-  auto vs2 = P.VU.elt<float16_t>(rs2_num, i);
-  P.VU.elt<uint32_t>(rd_num, i, true) = f16_to_ui32(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float16_t>(rs2_num, i);
+  P.VU.elt_ref<uint32_t>(rd_num, i, true) = f16_to_ui32(vs2, STATE.frm, true);
 },
 {
-  auto vs2 = P.VU.elt<float32_t>(rs2_num, i);
-  P.VU.elt<uint64_t>(rd_num, i, true) = f32_to_ui64(vs2, STATE.frm, true);
+  auto vs2 = P.VU.elt_val<float32_t>(rs2_num, i);
+  P.VU.elt_ref<uint64_t>(rd_num, i, true) = f32_to_ui64(vs2, STATE.frm, true);
 },
 {
   ;
diff --git a/riscv/insns/vid_v.h b/riscv/insns/vid_v.h
index 012d124a..fa20f70b 100644
--- a/riscv/insns/vid_v.h
+++ b/riscv/insns/vid_v.h
@@ -14,16 +14,16 @@ for (reg_t i = P.VU.vstart ; i < P.VU.vl; ++i) {
 
   switch (sew) {
   case e8:
-    P.VU.elt<uint8_t>(rd_num, i, true) = i;
+    P.VU.elt_ref<uint8_t>(rd_num, i, true) = i;
     break;
   case e16:
-    P.VU.elt<uint16_t>(rd_num, i, true) = i;
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = i;
     break;
   case e32:
-    P.VU.elt<uint32_t>(rd_num, i, true) = i;
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = i;
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, i, true) = i;
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = i;
     break;
   }
 }
diff --git a/riscv/insns/viota_m.h b/riscv/insns/viota_m.h
index a4368254..24f00322 100644
--- a/riscv/insns/viota_m.h
+++ b/riscv/insns/viota_m.h
@@ -16,8 +16,8 @@ for (reg_t i = 0; i < vl; ++i) {
   const int midx = i / 64;
   const int mpos = i % 64;
 
-  bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx) >> mpos) & 0x1) == 1;
-  bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool vs2_lsb = ((P.VU.elt_val<uint64_t>(rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
   bool has_one = false;
   if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
@@ -29,20 +29,20 @@ for (reg_t i = 0; i < vl; ++i) {
   bool use_ori = (insn.v_vm() == 0) && !do_mask;
   switch (sew) {
   case e8:
-    P.VU.elt<uint8_t>(rd_num, i, true) = use_ori ?
-                                   P.VU.elt<uint8_t>(rd_num, i) : cnt;
+    P.VU.elt_ref<uint8_t>(rd_num, i, true) = use_ori ?
+                                   P.VU.elt_val<uint8_t>(rd_num, i) : cnt;
     break;
   case e16:
-    P.VU.elt<uint16_t>(rd_num, i, true) = use_ori ?
-                                    P.VU.elt<uint16_t>(rd_num, i) : cnt;
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = use_ori ?
+                                    P.VU.elt_val<uint16_t>(rd_num, i) : cnt;
     break;
   case e32:
-    P.VU.elt<uint32_t>(rd_num, i, true) = use_ori ?
-                                    P.VU.elt<uint32_t>(rd_num, i) : cnt;
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = use_ori ?
+                                    P.VU.elt_val<uint32_t>(rd_num, i) : cnt;
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, i, true) = use_ori ?
-                                    P.VU.elt<uint64_t>(rd_num, i) : cnt;
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = use_ori ?
+                                    P.VU.elt_val<uint64_t>(rd_num, i) : cnt;
     break;
   }
 
diff --git a/riscv/insns/vmadc_vim.h b/riscv/insns/vmadc_vim.h
index 9e15b742..4af2611f 100644
--- a/riscv/insns/vmadc_vim.h
+++ b/riscv/insns/vmadc_vim.h
@@ -1,7 +1,7 @@
 // vmadc.vim vd, vs2, simm5, v0
 VI_XI_LOOP_CARRY
 ({
-  auto v0 = P.VU.elt<uint64_t>(0, midx);
+  auto v0 = P.VU.elt_val<uint64_t>(0, midx);
   const uint64_t mmask = UINT64_C(1) << mpos; \
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = insn.v_vm() == 0 ? (v0 >> mpos) & 0x1 : 0;
diff --git a/riscv/insns/vmadc_vvm.h b/riscv/insns/vmadc_vvm.h
index 15528800..33231812 100644
--- a/riscv/insns/vmadc_vvm.h
+++ b/riscv/insns/vmadc_vvm.h
@@ -1,7 +1,7 @@
 // vmadc.vvm vd, vs2, rs1, v0
 VI_VV_LOOP_CARRY
 ({
-  auto v0 = P.VU.elt<uint64_t>(0, midx);
+  auto v0 = P.VU.elt_val<uint64_t>(0, midx);
   const uint64_t mmask = UINT64_C(1) << mpos; \
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = insn.v_vm() == 0 ? (v0 >> mpos) & 0x1 : 0;
diff --git a/riscv/insns/vmadc_vxm.h b/riscv/insns/vmadc_vxm.h
index 306f8015..3348c5e9 100644
--- a/riscv/insns/vmadc_vxm.h
+++ b/riscv/insns/vmadc_vxm.h
@@ -1,7 +1,7 @@
 // vadc.vx vd, vs2, rs1, v0
 VI_XI_LOOP_CARRY
 ({
-  auto v0 = P.VU.elt<uint64_t>(0, midx);
+  auto v0 = P.VU.elt_val<uint64_t>(0, midx);
   const uint64_t mmask = UINT64_C(1) << mpos; \
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = insn.v_vm() == 0 ? (v0 >> mpos) & 0x1 : 0;
diff --git a/riscv/insns/vmerge_vim.h b/riscv/insns/vmerge_vim.h
index fd6ae1cd..9ac440f0 100644
--- a/riscv/insns/vmerge_vim.h
+++ b/riscv/insns/vmerge_vim.h
@@ -5,7 +5,7 @@ VI_VVXI_MERGE_LOOP
 ({
   int midx = i / 64;
   int mpos = i % 64;
-  bool use_first = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool use_first = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
   vd = use_first ? simm5 : vs2;
 })
diff --git a/riscv/insns/vmerge_vvm.h b/riscv/insns/vmerge_vvm.h
index df416b2c..a3eaa254 100644
--- a/riscv/insns/vmerge_vvm.h
+++ b/riscv/insns/vmerge_vvm.h
@@ -5,7 +5,7 @@ VI_VVXI_MERGE_LOOP
 ({
   int midx = i / 64;
   int mpos = i % 64;
-  bool use_first = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool use_first = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
   vd = use_first ? vs1 : vs2;
 })
diff --git a/riscv/insns/vmerge_vxm.h b/riscv/insns/vmerge_vxm.h
index 122a7b73..1c52a983 100644
--- a/riscv/insns/vmerge_vxm.h
+++ b/riscv/insns/vmerge_vxm.h
@@ -5,7 +5,7 @@ VI_VVXI_MERGE_LOOP
 ({
   int midx = i / 64;
   int mpos = i % 64;
-  bool use_first = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool use_first = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
   vd = use_first ? rs1 : vs2;
 })
diff --git a/riscv/insns/vmsbc_vvm.h b/riscv/insns/vmsbc_vvm.h
index 5f91a1ec..a11ff7b1 100644
--- a/riscv/insns/vmsbc_vvm.h
+++ b/riscv/insns/vmsbc_vvm.h
@@ -1,7 +1,7 @@
 // vmsbc.vvm vd, vs2, rs1, v0
 VI_VV_LOOP_CARRY
 ({
-  auto v0 = P.VU.elt<uint64_t>(0, midx);
+  auto v0 = P.VU.elt_val<uint64_t>(0, midx);
   const uint64_t mmask = UINT64_C(1) << mpos;
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = insn.v_vm() == 0 ? (v0 >> mpos) & 0x1 : 0;
diff --git a/riscv/insns/vmsbc_vxm.h b/riscv/insns/vmsbc_vxm.h
index 9d6012ef..54ded151 100644
--- a/riscv/insns/vmsbc_vxm.h
+++ b/riscv/insns/vmsbc_vxm.h
@@ -1,7 +1,7 @@
 // vmsbc.vxm vd, vs2, rs1, v0
 VI_XI_LOOP_CARRY
 ({
-  auto &v0 = P.VU.elt<uint64_t>(0, midx);
+  auto &v0 = P.VU.elt_ref<uint64_t>(0, midx);
   const uint64_t mmask = UINT64_C(1) << mpos; \
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = insn.v_vm() == 0 ? (v0 >> mpos) & 0x1 : 0;
diff --git a/riscv/insns/vmsbf_m.h b/riscv/insns/vmsbf_m.h
index a4195cfd..bfeeb145 100644
--- a/riscv/insns/vmsbf_m.h
+++ b/riscv/insns/vmsbf_m.h
@@ -15,12 +15,12 @@ for (reg_t i = P.VU.vstart; i < vl; ++i) {
   const int mpos = i % 64;
   const uint64_t mmask = UINT64_C(1) << mpos; \
 
-  bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx) >> mpos) & 0x1) == 1;
-  bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool vs2_lsb = ((P.VU.elt_val<uint64_t>(rs2_num, midx) >> mpos) & 0x1) == 1;
+  bool do_mask = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
 
   if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
-    auto &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
+    auto &vd = P.VU.elt_ref<uint64_t>(rd_num, midx, true);
     uint64_t res = 0;
     if (!has_one && !vs2_lsb) {
       res = 1;
diff --git a/riscv/insns/vmsif_m.h b/riscv/insns/vmsif_m.h
index a16ef681..e8ba4ad3 100644
--- a/riscv/insns/vmsif_m.h
+++ b/riscv/insns/vmsif_m.h
@@ -15,11 +15,11 @@ for (reg_t i = P.VU.vstart ; i < vl; ++i) {
   const int mpos = i % 64;
   const uint64_t mmask = UINT64_C(1) << mpos; \
 
-  bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
-  bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool vs2_lsb = ((P.VU.elt_val<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
+  bool do_mask = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
   if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
-    auto &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
+    auto &vd = P.VU.elt_ref<uint64_t>(rd_num, midx, true);
     uint64_t res = 0;
     if (!has_one && !vs2_lsb) {
       res = 1;
diff --git a/riscv/insns/vmsof_m.h b/riscv/insns/vmsof_m.h
index 5ef0bfd4..b323ff98 100644
--- a/riscv/insns/vmsof_m.h
+++ b/riscv/insns/vmsof_m.h
@@ -15,11 +15,11 @@ for (reg_t i = P.VU.vstart ; i < vl; ++i) {
   const int mpos = i % 64;
   const uint64_t mmask = UINT64_C(1) << mpos; \
 
-  bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
-  bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
+  bool vs2_lsb = ((P.VU.elt_val<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
+  bool do_mask = (P.VU.elt_val<uint64_t>(0, midx) >> mpos) & 0x1;
 
   if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
-    uint64_t &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
+    uint64_t &vd = P.VU.elt_ref<uint64_t>(rd_num, midx, true);
     uint64_t res = 0;
     if(!has_one && vs2_lsb) {
       has_one = true;
diff --git a/riscv/insns/vmulhsu_vv.h b/riscv/insns/vmulhsu_vv.h
index f77a7d3f..f61c87eb 100644
--- a/riscv/insns/vmulhsu_vv.h
+++ b/riscv/insns/vmulhsu_vv.h
@@ -3,33 +3,33 @@ VI_CHECK_SSS(true);
 VI_LOOP_BASE
 switch(sew) {
 case e8: {
-  auto &vd = P.VU.elt<int8_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int8_t>(rs2_num, i);
-  auto vs1 = P.VU.elt<uint8_t>(rs1_num, i);
+  auto &vd = P.VU.elt_ref<int8_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int8_t>(rs2_num, i);
+  auto vs1 = P.VU.elt_val<uint8_t>(rs1_num, i);
 
   vd = ((int16_t)vs2 * (uint16_t)vs1) >> sew;
   break;
 }
 case e16: {
-  auto &vd = P.VU.elt<int16_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int16_t>(rs2_num, i);
-  auto vs1 = P.VU.elt<uint16_t>(rs1_num, i);
+  auto &vd = P.VU.elt_ref<int16_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int16_t>(rs2_num, i);
+  auto vs1 = P.VU.elt_val<uint16_t>(rs1_num, i);
 
   vd = ((int32_t)vs2 * (uint32_t)vs1) >> sew;
   break;
 }
 case e32: {
-  auto &vd = P.VU.elt<int32_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int32_t>(rs2_num, i);
-  auto vs1 = P.VU.elt<uint32_t>(rs1_num, i);
+  auto &vd = P.VU.elt_ref<int32_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int32_t>(rs2_num, i);
+  auto vs1 = P.VU.elt_val<uint32_t>(rs1_num, i);
 
   vd = ((int64_t)vs2 * (uint64_t)vs1) >> sew;
   break;
 }
 default: {
-  auto &vd = P.VU.elt<int64_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int64_t>(rs2_num, i);
-  auto vs1 = P.VU.elt<uint64_t>(rs1_num, i);
+  auto &vd = P.VU.elt_ref<int64_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int64_t>(rs2_num, i);
+  auto vs1 = P.VU.elt_val<uint64_t>(rs1_num, i);
 
   vd = ((int128_t)vs2 * (uint128_t)vs1) >> sew;
   break;
diff --git a/riscv/insns/vmulhsu_vx.h b/riscv/insns/vmulhsu_vx.h
index b0699f6f..2103f1b4 100644
--- a/riscv/insns/vmulhsu_vx.h
+++ b/riscv/insns/vmulhsu_vx.h
@@ -3,32 +3,32 @@ VI_CHECK_SSS(false);
 VI_LOOP_BASE
 switch(sew) {
 case e8: {
-  auto &vd = P.VU.elt<int8_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int8_t>(rs2_num, i);
+  auto &vd = P.VU.elt_ref<int8_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int8_t>(rs2_num, i);
   uint8_t rs1 = RS1;
 
   vd = ((int16_t)vs2 * (uint16_t)rs1) >> sew;
   break;
 }
 case e16: {
-  auto &vd = P.VU.elt<int16_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int16_t>(rs2_num, i);
+  auto &vd = P.VU.elt_ref<int16_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int16_t>(rs2_num, i);
   uint16_t rs1 = RS1;
 
   vd = ((int32_t)vs2 * (uint32_t)rs1) >> sew;
   break;
 }
 case e32: {
-  auto &vd = P.VU.elt<int32_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int32_t>(rs2_num, i);
+  auto &vd = P.VU.elt_ref<int32_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int32_t>(rs2_num, i);
   uint32_t rs1 = RS1;
 
   vd = ((int64_t)vs2 * (uint64_t)rs1) >> sew;
   break;
 }
 default: {
-  auto &vd = P.VU.elt<int64_t>(rd_num, i, true);
-  auto vs2 = P.VU.elt<int64_t>(rs2_num, i);
+  auto &vd = P.VU.elt_ref<int64_t>(rd_num, i, true);
+  auto vs2 = P.VU.elt_val<int64_t>(rs2_num, i);
   uint64_t rs1 = RS1;
 
   vd = ((int128_t)vs2 * (uint128_t)rs1) >> sew;
diff --git a/riscv/insns/vmv_s_x.h b/riscv/insns/vmv_s_x.h
index 0e6a13e5..89c2ecab 100644
--- a/riscv/insns/vmv_s_x.h
+++ b/riscv/insns/vmv_s_x.h
@@ -10,16 +10,16 @@ if (vl > 0 && P.VU.vstart < vl) {
 
   switch(sew) {
   case e8:
-    P.VU.elt<uint8_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint8_t>(rd_num, 0, true) = RS1;
     break;
   case e16:
-    P.VU.elt<uint16_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint16_t>(rd_num, 0, true) = RS1;
     break;
   case e32:
-    P.VU.elt<uint32_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint32_t>(rd_num, 0, true) = RS1;
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint64_t>(rd_num, 0, true) = RS1;
     break;
   }
 
diff --git a/riscv/insns/vmv_x_s.h b/riscv/insns/vmv_x_s.h
index 2c03e43e..e6ab369d 100644
--- a/riscv/insns/vmv_x_s.h
+++ b/riscv/insns/vmv_x_s.h
@@ -11,19 +11,19 @@ if (!(rs1 >= 0 && rs1 < (P.VU.get_vlen() / sew))) {
 } else {
   switch(sew) {
   case e8:
-    WRITE_RD(P.VU.elt<int8_t>(rs2_num, rs1));
+    WRITE_RD(P.VU.elt_val<int8_t>(rs2_num, rs1));
     break;
   case e16:
-    WRITE_RD(P.VU.elt<int16_t>(rs2_num, rs1));
+    WRITE_RD(P.VU.elt_val<int16_t>(rs2_num, rs1));
     break;
   case e32:
-    WRITE_RD(P.VU.elt<int32_t>(rs2_num, rs1));
+    WRITE_RD(P.VU.elt_val<int32_t>(rs2_num, rs1));
     break;
   case e64:
     if (P.get_max_xlen() <= sew)
-      WRITE_RD(P.VU.elt<uint64_t>(rs2_num, rs1) & xmask);
+      WRITE_RD(P.VU.elt_val<uint64_t>(rs2_num, rs1) & xmask);
     else
-      WRITE_RD(P.VU.elt<uint64_t>(rs2_num, rs1));
+      WRITE_RD(P.VU.elt_val<uint64_t>(rs2_num, rs1));
     break;
   }
 }
diff --git a/riscv/insns/vmvnfr_v.h b/riscv/insns/vmvnfr_v.h
index 96f0074c..44514187 100644
--- a/riscv/insns/vmvnfr_v.h
+++ b/riscv/insns/vmvnfr_v.h
@@ -12,15 +12,25 @@ const reg_t size = len * P.VU.vlenb;
 if (vd != vs2 && P.VU.vstart < size) {
   reg_t i = P.VU.vstart / P.VU.vlenb;
   reg_t off = P.VU.vstart % P.VU.vlenb;
+
+  // Commented out the original memcpy implementations. We need the instrumented elt() calls to
+  // trigger the vector state update callbacks.
   if (off) {
-    memcpy(&P.VU.elt<uint8_t>(vd + i, off, true),
-           &P.VU.elt<uint8_t>(vs2 + i, off), P.VU.vlenb - off);
+    //memcpy(&P.VU.elt<uint8_t>(vd + i, off, true),
+    //       &P.VU.elt<uint8_t>(vs2 + i, off), P.VU.vlenb - off);
+    for(reg_t _byte = off; _byte < (P.VU.vlenb - off); ++_byte) {
+      P.VU.elt_ref<uint8_t>(vd + i, _byte, true) = P.VU.elt_val<uint8_t>(vs2 + i, _byte);
+    }
+
     i++;
   }
 
   for (; i < len; ++i) {
-    memcpy(&P.VU.elt<uint8_t>(vd + i, 0, true),
-           &P.VU.elt<uint8_t>(vs2 + i, 0), P.VU.vlenb);
+    //memcpy(&P.VU.elt<uint8_t>(vd + i, 0, true),
+    //       &P.VU.elt<uint8_t>(vs2 + i, 0), P.VU.vlenb);
+    for(reg_t _byte = 0; _byte < P.VU.vlenb; ++_byte) {
+      P.VU.elt_ref<uint8_t>(vd + i, _byte, true) = P.VU.elt_val<uint8_t>(vs2 + i, _byte);
+    }
   }
 }
 
diff --git a/riscv/insns/vrgather_vi.h b/riscv/insns/vrgather_vi.h
index 385e9be9..b43a21f0 100644
--- a/riscv/insns/vrgather_vi.h
+++ b/riscv/insns/vrgather_vi.h
@@ -13,16 +13,16 @@ for (reg_t i = P.VU.vstart; i < vl; ++i) {
 
   switch (sew) {
   case e8:
-    P.VU.elt<uint8_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt<uint8_t>(rs2_num, zimm5);
+    P.VU.elt_ref<uint8_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint8_t>(rs2_num, zimm5);
     break;
   case e16:
-    P.VU.elt<uint16_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt<uint16_t>(rs2_num, zimm5);
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint16_t>(rs2_num, zimm5);
     break;
   case e32:
-    P.VU.elt<uint32_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt<uint32_t>(rs2_num, zimm5);
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint32_t>(rs2_num, zimm5);
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt<uint64_t>(rs2_num, zimm5);
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = zimm5 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint64_t>(rs2_num, zimm5);
     break;
   }
 }
diff --git a/riscv/insns/vrgather_vv.h b/riscv/insns/vrgather_vv.h
index a3a32f56..18b362a4 100644
--- a/riscv/insns/vrgather_vv.h
+++ b/riscv/insns/vrgather_vv.h
@@ -8,24 +8,24 @@ require_vm;
 VI_LOOP_BASE
   switch (sew) {
   case e8: {
-    auto vs1 = P.VU.elt<uint8_t>(rs1_num, i);
+    auto vs1 = P.VU.elt_val<uint8_t>(rs1_num, i);
     //if (i > 255) continue;
-    P.VU.elt<uint8_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint8_t>(rs2_num, vs1);
+    P.VU.elt_ref<uint8_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint8_t>(rs2_num, vs1);
     break;
   }
   case e16: {
-    auto vs1 = P.VU.elt<uint16_t>(rs1_num, i);
-    P.VU.elt<uint16_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint16_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint16_t>(rs1_num, i);
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint16_t>(rs2_num, vs1);
     break;
   }
   case e32: {
-    auto vs1 = P.VU.elt<uint32_t>(rs1_num, i);
-    P.VU.elt<uint32_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint32_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint32_t>(rs1_num, i);
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint32_t>(rs2_num, vs1);
     break;
   }
   default: {
-    auto vs1 = P.VU.elt<uint64_t>(rs1_num, i);
-    P.VU.elt<uint64_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint64_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint64_t>(rs1_num, i);
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint64_t>(rs2_num, vs1);
     break;
   }
   }
diff --git a/riscv/insns/vrgather_vx.h b/riscv/insns/vrgather_vx.h
index 058ffae1..b85e34d1 100644
--- a/riscv/insns/vrgather_vx.h
+++ b/riscv/insns/vrgather_vx.h
@@ -9,16 +9,16 @@ reg_t rs1 = RS1;
 VI_LOOP_BASE
   switch (sew) {
   case e8:
-    P.VU.elt<uint8_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint8_t>(rs2_num, rs1);
+    P.VU.elt_ref<uint8_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint8_t>(rs2_num, rs1);
     break;
   case e16:
-    P.VU.elt<uint16_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint16_t>(rs2_num, rs1);
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint16_t>(rs2_num, rs1);
     break;
   case e32:
-    P.VU.elt<uint32_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint32_t>(rs2_num, rs1);
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint32_t>(rs2_num, rs1);
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint64_t>(rs2_num, rs1);
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = rs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint64_t>(rs2_num, rs1);
     break;
   }
 VI_LOOP_END;
diff --git a/riscv/insns/vrgatherei16_vv.h b/riscv/insns/vrgatherei16_vv.h
index 3bb166a2..eee30bff 100644
--- a/riscv/insns/vrgatherei16_vv.h
+++ b/riscv/insns/vrgatherei16_vv.h
@@ -11,23 +11,23 @@ require_vm;
 VI_LOOP_BASE
   switch (sew) {
   case e8: {
-    auto vs1 = P.VU.elt<uint16_t>(rs1_num, i);
-    P.VU.elt<uint8_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint8_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint16_t>(rs1_num, i);
+    P.VU.elt_ref<uint8_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint8_t>(rs2_num, vs1);
     break;
   }
   case e16: {
-    auto vs1 = P.VU.elt<uint16_t>(rs1_num, i);
-    P.VU.elt<uint16_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint16_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint16_t>(rs1_num, i);
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint16_t>(rs2_num, vs1);
     break;
   }
   case e32: {
-    auto vs1 = P.VU.elt<uint16_t>(rs1_num, i);
-    P.VU.elt<uint32_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint32_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint16_t>(rs1_num, i);
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint32_t>(rs2_num, vs1);
     break;
   }
   default: {
-    auto vs1 = P.VU.elt<uint16_t>(rs1_num, i);
-    P.VU.elt<uint64_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt<uint64_t>(rs2_num, vs1);
+    auto vs1 = P.VU.elt_val<uint16_t>(rs1_num, i);
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = vs1 >= P.VU.vlmax ? 0 : P.VU.elt_val<uint64_t>(rs2_num, vs1);
     break;
   }
   }
diff --git a/riscv/insns/vsbc_vvm.h b/riscv/insns/vsbc_vvm.h
index 96b8bb80..1a2ce192 100644
--- a/riscv/insns/vsbc_vvm.h
+++ b/riscv/insns/vsbc_vvm.h
@@ -1,7 +1,7 @@
 // vsbc.vvm vd, vs2, rs1, v0
 VI_VV_LOOP_WITH_CARRY
 ({
-  auto &v0 = P.VU.elt<uint64_t>(0, midx);
+  auto &v0 = P.VU.elt_ref<uint64_t>(0, midx);
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = (v0 >> mpos) & 0x1;
 
diff --git a/riscv/insns/vsbc_vxm.h b/riscv/insns/vsbc_vxm.h
index c6f9ca82..3adb7ca4 100644
--- a/riscv/insns/vsbc_vxm.h
+++ b/riscv/insns/vsbc_vxm.h
@@ -1,7 +1,7 @@
 // vsbc.vxm vd, vs2, rs1, v0
 VI_XI_LOOP_WITH_CARRY
 ({
-  auto &v0 = P.VU.elt<uint64_t>(0, midx);
+  auto &v0 = P.VU.elt_ref<uint64_t>(0, midx);
   const uint128_t op_mask = (UINT64_MAX >> (64 - sew));
   uint64_t carry = (v0 >> mpos) & 0x1;
 
diff --git a/riscv/insns/vslide1down_vx.h b/riscv/insns/vslide1down_vx.h
index e867722f..48a05449 100644
--- a/riscv/insns/vslide1down_vx.h
+++ b/riscv/insns/vslide1down_vx.h
@@ -28,16 +28,16 @@ if (i != vl - 1) {
 } else {
   switch (sew) {
   case e8:
-    P.VU.elt<uint8_t>(rd_num, vl - 1, true) = RS1;
+    P.VU.elt_ref<uint8_t>(rd_num, vl - 1, true) = RS1;
     break;
   case e16:
-    P.VU.elt<uint16_t>(rd_num, vl - 1, true) = RS1;
+    P.VU.elt_ref<uint16_t>(rd_num, vl - 1, true) = RS1;
     break;
   case e32:
-    P.VU.elt<uint32_t>(rd_num, vl - 1, true) = RS1;
+    P.VU.elt_ref<uint32_t>(rd_num, vl - 1, true) = RS1;
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, vl - 1, true) = RS1;
+    P.VU.elt_ref<uint64_t>(rd_num, vl - 1, true) = RS1;
     break;
   }
 }
diff --git a/riscv/insns/vslide1up_vx.h b/riscv/insns/vslide1up_vx.h
index 33cb9ed6..53b45a7f 100644
--- a/riscv/insns/vslide1up_vx.h
+++ b/riscv/insns/vslide1up_vx.h
@@ -18,13 +18,13 @@ if (i != 0) {
   }
 } else {
   if (sew == e8) {
-    P.VU.elt<uint8_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint8_t>(rd_num, 0, true) = RS1;
   } else if(sew == e16) {
-    P.VU.elt<uint16_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint16_t>(rd_num, 0, true) = RS1;
   } else if(sew == e32) {
-    P.VU.elt<uint32_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint32_t>(rd_num, 0, true) = RS1;
   } else if(sew == e64) {
-    P.VU.elt<uint64_t>(rd_num, 0, true) = RS1;
+    P.VU.elt_ref<uint64_t>(rd_num, 0, true) = RS1;
   }
 }
 VI_LOOP_END
diff --git a/riscv/insns/vwmulsu_vv.h b/riscv/insns/vwmulsu_vv.h
index 5f84721f..4ddb64e9 100644
--- a/riscv/insns/vwmulsu_vv.h
+++ b/riscv/insns/vwmulsu_vv.h
@@ -4,13 +4,13 @@ VI_VV_LOOP_WIDEN
 ({
   switch(P.VU.vsew) {
   case e8:
-    P.VU.elt<uint16_t>(rd_num, i, true) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)vs1;
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)vs1;
     break;
   case e16:
-    P.VU.elt<uint32_t>(rd_num, i, true) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)vs1;
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)vs1;
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, i, true) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)vs1;
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)vs1;
     break;
   }
 })
diff --git a/riscv/insns/vwmulsu_vx.h b/riscv/insns/vwmulsu_vx.h
index 68d6d276..b468b48a 100644
--- a/riscv/insns/vwmulsu_vx.h
+++ b/riscv/insns/vwmulsu_vx.h
@@ -4,13 +4,13 @@ VI_VX_LOOP_WIDEN
 ({
   switch(P.VU.vsew) {
   case e8:
-    P.VU.elt<uint16_t>(rd_num, i, true) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)rs1;
+    P.VU.elt_ref<uint16_t>(rd_num, i, true) = (int16_t)(int8_t)vs2 * (int16_t)(uint8_t)rs1;
     break;
   case e16:
-    P.VU.elt<uint32_t>(rd_num, i, true) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)rs1;
+    P.VU.elt_ref<uint32_t>(rd_num, i, true) = (int32_t)(int16_t)vs2 * (int32_t)(uint16_t)rs1;
     break;
   default:
-    P.VU.elt<uint64_t>(rd_num, i, true) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)rs1;
+    P.VU.elt_ref<uint64_t>(rd_num, i, true) = (int64_t)(int32_t)vs2 * (int64_t)(uint32_t)rs1;
     break;
   }
 })
diff --git a/riscv/mmu.cc b/riscv/mmu.cc
index 8cedd447..2cbc4c96 100644
--- a/riscv/mmu.cc
+++ b/riscv/mmu.cc
@@ -5,6 +5,9 @@
 #include "simif.h"
 #include "processor.h"
 
+//DEBUG
+#include <iostream>
+
 mmu_t::mmu_t(simif_t* sim, processor_t* proc)
  : sim(sim), proc(proc),
 #ifdef RISCV_ENABLE_DUAL_ENDIAN
@@ -74,18 +77,54 @@ reg_t mmu_t::translate(reg_t addr, reg_t len, access_type type, uint32_t xlate_f
   return paddr;
 }
 
-tlb_entry_t mmu_t::fetch_slow_path(reg_t vaddr)
+int mmu_t::translate_api(reg_t addr, reg_t* paddr, uint64_t* pmp_info, reg_t len, access_type type, uint32_t xlate_flags)
 {
-  reg_t paddr = translate(vaddr, sizeof(fetch_temp), FETCH, 0);
+  int status = 0;
+  if (!proc){
+    status = 1;
+    return status;    
+  }
 
-  if (auto host_addr = sim->addr_to_mem(paddr)) {
-    return refill_tlb(vaddr, paddr, host_addr, FETCH);
-  } else {
-    if (!mmio_load(paddr, sizeof fetch_temp, (uint8_t*)&fetch_temp))
-      throw trap_instruction_access_fault(proc->state.v, vaddr, 0, 0);
-    tlb_entry_t entry = {(char*)&fetch_temp - vaddr, paddr - vaddr};
-    return entry;
+  bool virt = proc->state.v;
+  bool hlvx = xlate_flags & RISCV_XLATE_VIRT_HLVX;
+  reg_t mode = proc->state.prv;
+  if (type != FETCH) {
+    if (!proc->state.debug_mode && get_field(proc->state.mstatus->read(), MSTATUS_MPRV)) {
+      mode = get_field(proc->state.mstatus->read(), MSTATUS_MPP);
+      if (get_field(proc->state.mstatus->read(), MSTATUS_MPV) && mode != PRV_M)
+        virt = true;
+    }
+    if (xlate_flags & RISCV_XLATE_VIRT) {
+      virt = true;
+      mode = get_field(proc->state.hstatus->read(), HSTATUS_SPVP);
+    }
+  }
+
+  reg_t temp_paddr = 0ull;
+  status = walk_api(addr, &temp_paddr, type, mode, virt, hlvx);
+  temp_paddr |= (addr & (PGSIZE-1));
+
+  reg_t temp_pmpaddr = 0ull;
+  uint8_t temp_pmpcfg = 0;
+  if (status == 0 && !pmp_ok_api(temp_paddr, &temp_pmpaddr, &temp_pmpcfg, len, type, mode))
+  {
+    status = 1; // Failed pmp check, either there was no match or there was only a partial match of the PMP requriements for that physical address.
+  }
+
+  if(pmp_info != nullptr)
+  {
+    *pmp_info = (temp_pmpaddr << 6) | (uint64_t)temp_pmpcfg; // This implies a 56 bit address 
+    std::cerr << "In translate_api, temp_pmpaddr is: " << std::hex << temp_pmpaddr << " while temp_pmpcfg is: " << std::hex << (uint64_t)temp_pmpcfg << std::endl;
   }
+
+  *paddr = temp_paddr;
+  return status;
+}
+
+tlb_entry_t mmu_t::fetch_slow_path(reg_t vaddr)
+{
+  reg_t paddr = translate(vaddr, sizeof(fetch_temp), FETCH, 0);
+  return refill_tlb(vaddr, paddr, 0 /*host_addr*/, FETCH);
 }
 
 reg_t reg_from_bytes(size_t len, const uint8_t* bytes)
@@ -114,57 +153,92 @@ reg_t reg_from_bytes(size_t len, const uint8_t* bytes)
   abort();
 }
 
-bool mmu_t::mmio_ok(reg_t addr, access_type type)
+void mmu_t::load_slow_path_partially_initialized(reg_t addr, reg_t len, uint8_t* bytes, uint32_t xlate_flags)
 {
-  // Disallow access to debug region when not in debug mode
-  if (addr >= DEBUG_START && addr <= DEBUG_END && proc && !proc->state.debug_mode)
-    return false;
+  reg_t paddr = translate(addr, len, LOAD, xlate_flags);
+  sim->sparse_read_partially_initialized(paddr, len, bytes);
 
-  return true;
+  update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, len, reinterpret_cast<const char*>(bytes), "read");
+
+  if (tracer.interested_in_range(paddr, paddr + PGSIZE, LOAD))
+    tracer.trace(paddr, len, LOAD);
+  else
+    refill_tlb(addr, paddr, 0 /*host_addr*/, LOAD);
+  
+  if (!matched_trigger) {
+    reg_t data = reg_from_bytes(len, bytes);
+    matched_trigger = trigger_exception(OPERATION_LOAD, addr, data);
+    if (matched_trigger)
+      throw *matched_trigger;
+  }
 }
 
-bool mmu_t::mmio_load(reg_t addr, size_t len, uint8_t* bytes)
+void mmu_t::load_slow_path(reg_t addr, reg_t len, uint8_t* bytes, uint32_t xlate_flags)
 {
-  if (!mmio_ok(addr, LOAD))
-    return false;
+  reg_t paddr = translate(addr, len, LOAD, xlate_flags);
+  uint64_t buff = 0ull;
+
+  buff = sim->sparse_read(paddr, len);
+  for(size_t byte_idx = 0; byte_idx < len; ++ byte_idx)
+  {
+    size_t buff_idx = len - 1 - byte_idx;
+    if (target_big_endian) {
+      buff_idx = byte_idx;
+    }
 
-  return sim->mmio_load(addr, len, bytes);
-}
+    bytes[byte_idx] = reinterpret_cast<uint8_t*>(&buff)[buff_idx];
+  }
 
-bool mmu_t::mmio_store(reg_t addr, size_t len, const uint8_t* bytes)
-{
-  if (!mmio_ok(addr, STORE))
-    return false;
+  update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, len, reinterpret_cast<const char*>(bytes), "read");
 
-  return sim->mmio_store(addr, len, bytes);
+  if (tracer.interested_in_range(paddr, paddr + PGSIZE, LOAD))
+    tracer.trace(paddr, len, LOAD);
+  else
+    refill_tlb(addr, paddr, 0 /*host_addr*/, LOAD);
+
+  if (!matched_trigger) {
+    reg_t data = reg_from_bytes(len, bytes);
+    matched_trigger = trigger_exception(OPERATION_LOAD, addr, data);
+    if (matched_trigger)
+      throw *matched_trigger;
+  }
 }
 
-void mmu_t::load_slow_path(reg_t addr, reg_t len, uint8_t* bytes, uint32_t xlate_flags)
+void mmu_t::initialize_slow_path(reg_t addr, reg_t len, const uint8_t* bytes, uint32_t xlate_flags)
 {
-  reg_t paddr = translate(addr, len, LOAD, xlate_flags);
+  reg_t paddr = translate(addr, len, STORE, xlate_flags);
 
-  if (auto host_addr = sim->addr_to_mem(paddr)) {
-    memcpy(bytes, host_addr, len);
-    if (tracer.interested_in_range(paddr, paddr + PGSIZE, LOAD))
-      tracer.trace(paddr, len, LOAD);
-    else if (xlate_flags == 0)
-      refill_tlb(addr, paddr, host_addr, LOAD);
-  } else if (!mmio_load(paddr, len, bytes)) {
-    throw trap_load_access_fault((proc) ? proc->state.v : false, addr, 0, 0);
-  }
+  update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, len, reinterpret_cast<const char*>(bytes), "write");
 
   if (!matched_trigger) {
     reg_t data = reg_from_bytes(len, bytes);
-    matched_trigger = trigger_exception(OPERATION_LOAD, addr, data);
+    matched_trigger = trigger_exception(OPERATION_STORE, addr, data);
     if (matched_trigger)
       throw *matched_trigger;
   }
+
+  // Initialize the memory if necessary
+  if(! sim->sparse_is_pa_initialized(paddr, len))
+  {
+      uint64_t attrs = 0ull;
+      sim->sparse_initialize_pa(paddr, bytes, reinterpret_cast<const uint8_t*>(&attrs), len, Force::EMemDataType::Both);
+  }
+  else
+  {//perform the write
+      sim->sparse_write(paddr, bytes, len);
+  }
+  if (tracer.interested_in_range(paddr, paddr + PGSIZE, STORE))
+    tracer.trace(paddr, len, STORE);
+  else
+    refill_tlb(addr, paddr, 0 /*host_addr*/, STORE);
 }
 
 void mmu_t::store_slow_path(reg_t addr, reg_t len, const uint8_t* bytes, uint32_t xlate_flags)
 {
   reg_t paddr = translate(addr, len, STORE, xlate_flags);
 
+  update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, len, reinterpret_cast<const char*>(bytes), "write");
+
   if (!matched_trigger) {
     reg_t data = reg_from_bytes(len, bytes);
     matched_trigger = trigger_exception(OPERATION_STORE, addr, data);
@@ -172,15 +246,21 @@ void mmu_t::store_slow_path(reg_t addr, reg_t len, const uint8_t* bytes, uint32_
       throw *matched_trigger;
   }
 
-  if (auto host_addr = sim->addr_to_mem(paddr)) {
-    memcpy(host_addr, bytes, len);
-    if (tracer.interested_in_range(paddr, paddr + PGSIZE, STORE))
-      tracer.trace(paddr, len, STORE);
-    else if (xlate_flags == 0)
-      refill_tlb(addr, paddr, host_addr, STORE);
-  } else if (!mmio_store(paddr, len, bytes)) {
-    throw trap_store_access_fault((proc) ? proc->state.v : false, addr, 0, 0);
+  // Initialize the memory if necessary
+  if(unlikely(! sim->sparse_is_pa_initialized(paddr, len)))
+  {
+      uint64_t attrs = 0ull;
+      sim->sparse_initialize_pa(paddr, bytes, reinterpret_cast<const uint8_t*>(&attrs), len, Force::EMemDataType::Both);
   }
+  else
+  {//perform the write
+    sim->sparse_write(paddr, bytes, len);
+  }
+
+  if (tracer.interested_in_range(paddr, paddr + PGSIZE, STORE))
+    tracer.trace(paddr, len, STORE);
+  else
+    refill_tlb(addr, paddr, 0 /*host_addr*/, STORE);
 }
 
 tlb_entry_t mmu_t::refill_tlb(reg_t vaddr, reg_t paddr, char* host_addr, access_type type)
@@ -243,6 +323,39 @@ bool mmu_t::pmp_ok(reg_t addr, reg_t len, access_type type, reg_t mode)
   return mode == PRV_M;
 }
 
+bool mmu_t::pmp_ok_api(reg_t addr, reg_t* pmpaddr_ptr, uint8_t* pmpcfg_ptr, reg_t len, access_type type, reg_t mode)
+{
+  if (!proc || proc->n_pmp == 0)
+    return true;
+
+  for (size_t i = 0; i < proc->n_pmp; i++) {
+    if(pmpaddr_ptr != nullptr && pmpcfg_ptr != nullptr) {
+      *pmpaddr_ptr = proc->state.pmpaddr[i]->get_tor_paddr();
+      *pmpcfg_ptr = proc->state.pmpaddr[i]->get_cfg();
+    }
+
+    // Check each 4-byte sector of the access
+    bool any_match = false;
+    bool all_match = true;
+    for (reg_t offset = 0; offset < len; offset += 1 << PMP_SHIFT) {
+      reg_t cur_addr = addr + offset;
+      bool match = proc->state.pmpaddr[i]->match4(cur_addr);
+      any_match |= match;
+      all_match &= match;
+    }
+
+    if (any_match) {
+      // If the PMP matches only a strict subset of the access, fail it
+      if (!all_match)
+        return false;
+
+      return proc->state.pmpaddr[i]->access_ok(type, mode);
+    }
+  }
+
+  return mode == PRV_M;
+}
+
 reg_t mmu_t::pmp_homogeneous(reg_t addr, reg_t len)
 {
   if ((addr | len) & (len - 1))
@@ -277,12 +390,19 @@ reg_t mmu_t::s2xlate(reg_t gva, reg_t gpa, access_type type, access_type trap_ty
 
     // check that physical address of PTE is legal
     auto pte_paddr = base + idx * vm.ptesize;
-    auto ppte = sim->addr_to_mem(pte_paddr);
-    if (!ppte || !pmp_ok(pte_paddr, vm.ptesize, LOAD, PRV_S)) {
+    bool pte_init = sim->sparse_is_pa_initialized(pte_paddr, vm.ptesize);
+    if (!pte_init || !pmp_ok(pte_paddr, vm.ptesize, LOAD, PRV_S)) {
       throw_access_exception(virt, gva, trap_type);
     }
 
-    reg_t pte = vm.ptesize == 4 ? from_target(*(target_endian<uint32_t>*)ppte) : from_target(*(target_endian<uint64_t>*)ppte);
+    uint64_t ppte_val = 0ull;
+    if (vm.ptesize == 4) {
+       ppte_val = sim->sparse_read(pte_paddr, sizeof(uint32_t));
+    } else {
+       ppte_val = sim->sparse_read(pte_paddr, sizeof(uint64_t));
+    }
+
+    reg_t pte = vm.ptesize == 4 ? from_target(*(target_endian<uint32_t>*)(&ppte_val)) : from_target(*(target_endian<uint64_t>*)(&ppte_val));
     reg_t ppn = (pte & ~reg_t(PTE_ATTR)) >> PTE_PPN_SHIFT;
 
     if (pte & PTE_RSVD) {
@@ -339,12 +459,15 @@ reg_t mmu_t::s2xlate(reg_t gva, reg_t gpa, access_type type, access_type trap_ty
 
 reg_t mmu_t::walk(reg_t addr, access_type type, reg_t mode, bool virt, bool hlvx)
 {
+  //std::cout << "mmu_t::walk addr=0x" << std::hex << addr << " mode=0x" << mode << std::endl;
   reg_t page_mask = (reg_t(1) << PGSHIFT) - 1;
   reg_t satp = proc->get_state()->satp->readvirt(virt);
   vm_info vm = decode_vm_info(proc->get_const_xlen(), false, mode, satp);
   if (vm.levels == 0)
     return s2xlate(addr, addr & ((reg_t(2) << (proc->xlen-1))-1), type, type, virt, hlvx) & ~page_mask; // zero-extend from xlen
 
+  //std::cout << "mmu_t::walk vm.ptbase=0x" << std::hex << vm.ptbase << " levels=0x" << vm.levels << std::endl;
+
   bool s_mode = mode == PRV_S;
   bool sum = proc->state.sstatus->readvirt(virt) & MSTATUS_SUM;
   bool mxr = (proc->state.sstatus->readvirt(false) | proc->state.sstatus->readvirt(virt)) & MSTATUS_MXR;
@@ -356,35 +479,94 @@ reg_t mmu_t::walk(reg_t addr, access_type type, reg_t mode, bool virt, bool hlvx
   if (masked_msbs != 0 && masked_msbs != mask)
     vm.levels = 0;
 
+  //std::cout << "mmu_t::walk va_bits=0x" << std::hex << va_bits << " xlen=0x" << proc->xlen << " mask=0x" << mask << " masked_msbs=0x" << masked_msbs << " levels=0x" << vm.levels << std::endl;
+
   reg_t base = vm.ptbase;
   for (int i = vm.levels - 1; i >= 0; i--) {
     int ptshift = i * vm.idxbits;
+    //std::cout << "mmu_t::walk i=0x" << std::hex << i << " ptshift=0x" << ptshift << " levels=0x" << vm.levels << std::endl;
     reg_t idx = (addr >> (PGSHIFT + ptshift)) & ((1 << vm.idxbits) - 1);
-
+    //std::cout << "mmu_t::walk idx=0x" << std::hex << idx << std::endl;
     // check that physical address of PTE is legal
     auto pte_paddr = s2xlate(addr, base + idx * vm.ptesize, LOAD, type, virt, false);
-    auto ppte = sim->addr_to_mem(pte_paddr);
+    //std::cout << "mmu_t::walk pte_paddr=0x" << std::hex << pte_paddr << std::endl;
+    //auto ppte = sim->addr_to_mem(pte_paddr);
+    bool ppte = sim->sparse_is_pa_initialized(pte_paddr, vm.ptesize);
     if (!ppte || !pmp_ok(pte_paddr, vm.ptesize, LOAD, PRV_S))
       throw_access_exception(virt, addr, type);
 
-    reg_t pte = vm.ptesize == 4 ? from_target(*(target_endian<uint32_t>*)ppte) : from_target(*(target_endian<uint64_t>*)ppte);
+    uint64_t ppte_val = 0ull;
+
+    if (vm.ptesize == 4) {
+       // Sv32...
+       uint32_t tbuf = sim->sparse_read(pte_paddr, sizeof(uint32_t));
+       uint32_t ppte_reversed_val = 0ull;
+       uint8_t* val = (uint8_t*)&tbuf;
+       uint8_t* rev = (uint8_t*)&ppte_reversed_val;
+       for (size_t i = 0; i < sizeof(uint32_t); i++) {
+          rev[i] = val[sizeof(uint32_t)-1-i];
+       }
+       //std::cout << "mmut_t::walk ppte_reversed_val=0x" << std::hex << ppte_reversed_val << std::endl;
+       ppte_val = ppte_reversed_val;
+    } else { 
+       //sim->sparse_read_partially_initialized(pte_paddr, sizeof(uint64_t), reinterpret_cast<uint8_t*>(ppte_val)); 
+       //uint64_t buff = 0ull;
+       //std::cerr << "length: " << len << " paddr: " << std::hex << paddr <<  std::endl;
+       ppte_val = sim->sparse_read(pte_paddr, sizeof(uint64_t)); // In testing of the api version of this,
+                                                                // it was noticed that reading in the commented out way was
+                                                                // byte reversing the expected values.
+       //std::cout << "mmu_t::walk ppte_val=0x" << std::hex << ppte_val << std::endl;
+       uint64_t ppte_reversed_val = 0ull;
+       uint8_t* val = (uint8_t*)&ppte_val;
+       uint8_t* rev = (uint8_t*)&ppte_reversed_val;
+       for (size_t i = 0; i < sizeof(uint64_t); i++)
+       {
+         rev[i] = val[sizeof(uint64_t)-1-i];
+       }
+       //std::cout << "mmut_t::walk ppte_reversed_val=0x" << std::hex << ppte_reversed_val << std::endl;
+       ppte_val = ppte_reversed_val;
+    }
+
+    //sim->sparse_read_partially_initialized(paddr, len, bytes);
+    //bool same_data_was_loaded = true;
+    //for(size_t byte_idx = 0; byte_idx < sizeof(uint64_t); ++ byte_idx)
+    //{
+    //    //same_data_was_loaded &= (reinterpret_cast<uint8_t*>(&buff)[len - 1 -byte_idx] == bytes[byte_idx]);
+    //    //assert(false && reinterpret_cast<uint8_t*>(&ppte_val)[byte_idx] == reinterpret_cast<uint8_t*>(&buff)[sizeof(uint64_t) -1 -byte_idx] && "Did not match ppte val load");
+    //    reinterpret_cast<uint8_t*>(&ppte_val)[byte_idx] = reinterpret_cast<uint8_t*>(&buff)[sizeof(uint64_t) -1 -byte_idx];
+    //}
+
+    //
+    //
+    // These endianness conversion functions are defined in the new version, do they work for our purposes or are they redundant with the above code?
+    //
+    //
+    reg_t pte = vm.ptesize == 4 ? from_target(*(target_endian<uint32_t>*)(&ppte_val)) : from_target(*(target_endian<uint64_t>*)(&ppte_val));
     reg_t ppn = (pte & ~reg_t(PTE_ATTR)) >> PTE_PPN_SHIFT;
 
+    //std::cout << "mmu_t::walk pte=0x" << std::hex << pte << " ppn=0x" << ppn << std::endl;
+
     if (pte & PTE_RSVD) {
       break;
     } else if (PTE_TABLE(pte)) { // next level of page table
       if (pte & (PTE_D | PTE_A | PTE_U | PTE_N | PTE_PBMT))
         break;
       base = ppn << PGSHIFT;
+      //std::cout << "mmu_t::walk next level table base=0x" << std::hex << base << std::endl;
     } else if ((pte & PTE_U) ? s_mode && (type == FETCH || !sum) : !s_mode) {
+      //std::cout << "mmu_t::walk u bit set causing page fault" << std::endl;
       break;
     } else if (!(pte & PTE_V) || (!(pte & PTE_R) && (pte & PTE_W))) {
+      //std::cout << "mmu_t::walk v bit not set, or R+W not set causing page fault" << std::endl;
       break;
     } else if (type == FETCH || hlvx ? !(pte & PTE_X) :
                type == LOAD          ? !(pte & PTE_R) && !(mxr && (pte & PTE_X)) :
                                        !((pte & PTE_R) && (pte & PTE_W))) {
+      //std::cout << "mmu_t::walk non-executable, or load not readable causing page fault" << std::endl;
       break;
     } else if ((ppn & ((reg_t(1) << ptshift) - 1)) != 0) {
+      reg_t test_val = ppn & ((reg_t(1) << ptshift) - 1);
+      //std::cout << "mmu_t::walk misaligned superpage val=0x" << std::hex << test_val << " causing page fault" << std::endl;
       break;
     } else {
       reg_t ad = PTE_A | ((type == STORE) * PTE_D);
@@ -393,12 +575,19 @@ reg_t mmu_t::walk(reg_t addr, access_type type, reg_t mode, bool virt, bool hlvx
       if ((pte & ad) != ad) {
         if (!pmp_ok(pte_paddr, vm.ptesize, STORE, PRV_S))
           throw_access_exception(virt, addr, type);
-        *(target_endian<uint32_t>*)ppte |= to_target((uint32_t)ad);
+        (target_endian<uint32_t>)ppte_val |= to_target((uint32_t)ad);
+        sim->sparse_write(pte_paddr, reinterpret_cast<uint8_t*>(&ppte_val), vm.ptesize); //NOTE this was written as a write from pte rather than ppte_val which doesnt match the reference code intent.
+        uint32_t debug_buff = 0;
+        sim->sparse_read_partially_initialized(pte_paddr, vm.ptesize, reinterpret_cast<uint8_t*>(&debug_buff));
+        assert(debug_buff == (uint32_t)ppte_val && "Failed to modify ppte_val correctly");
       }
 #else
       // take exception if access or possibly dirty bit is not set.
       if ((pte & ad) != ad)
+      {
+        //std::cout << "mmu_t::walk ad bits ad=0x" << std::hex << ad << " causing page fault" << std::endl;
         break;
+      }
 #endif
       // for superpage or Svnapot NAPOT mappings, make a fake leaf PTE for the TLB's benefit.
       reg_t vpn = addr >> PGSHIFT;
@@ -411,7 +600,15 @@ reg_t mmu_t::walk(reg_t addr, access_type type, reg_t mode, bool virt, bool hlvx
                         | (vpn & ((reg_t(1) << napot_bits) - 1))
                         | (vpn & ((reg_t(1) << ptshift) - 1))) << PGSHIFT;
       reg_t phys = page_base | (addr & page_mask);
-      return s2xlate(addr, phys, type, type, virt, hlvx) & ~page_mask;
+      reg_t value = s2xlate(addr, phys, type, type, virt, hlvx) & ~page_mask;
+
+      //report the translation via the callback mechanism
+      bool has_stage_two = (vm.levels > 1); 
+      MmuEvent mmu_event(addr, value, Memtype::Normal, has_stage_two, 0, 0, 0, 0);
+      update_mmu_event(&mmu_event);
+
+      //std::cout << "mmu_t::walk end value=0x" << std::hex << value << std::endl;
+      return value;
     }
   }
 
@@ -423,6 +620,150 @@ reg_t mmu_t::walk(reg_t addr, access_type type, reg_t mode, bool virt, bool hlvx
   }
 }
 
+int mmu_t::walk_api(reg_t addr, reg_t* paddr_ptr, access_type type, reg_t mode, bool virt, bool hlvx)
+{
+  reg_t page_mask = (reg_t(1) << PGSHIFT) - 1;
+  reg_t satp = proc->get_state()->satp->readvirt(virt);
+  vm_info vm = decode_vm_info(proc->get_const_xlen(), false, mode, satp);
+  if (vm.levels == 0) {
+    std::cerr << "vm.levels is zero" << std::endl; 
+    *paddr_ptr = s2xlate(addr, addr & ((reg_t(2) << (proc->xlen-1))-1), type, type, virt, hlvx) & ~page_mask; // zero-extend from xlen
+    return 0;
+  }
+
+  bool s_mode = mode == PRV_S;
+  bool sum = proc->state.sstatus->readvirt(virt) & MSTATUS_SUM;
+  bool mxr = (proc->state.sstatus->readvirt(false) | proc->state.sstatus->readvirt(virt)) & MSTATUS_MXR;
+
+  // verify bits xlen-1:va_bits-1 are all equal
+  int va_bits = PGSHIFT + vm.levels * vm.idxbits;
+  reg_t mask = (reg_t(1) << (proc->xlen - (va_bits-1))) - 1;
+  reg_t masked_msbs = (addr >> (va_bits-1)) & mask;
+  if (masked_msbs != 0 && masked_msbs != mask)
+  {
+      vm.levels = 0;
+      std::cerr << "Failed test that bits xlen-1:va_bits-1 are all equal" << std::endl;
+  }
+  else
+  {
+      std::cerr << "Passed test that bits xlen-1:va_bits-1 are all equal" << std::endl;
+  }
+  
+
+  reg_t base = vm.ptbase;
+  for (int i = vm.levels - 1; i >= 0; i--) {
+    int ptshift = i * vm.idxbits;
+    reg_t idx = (addr >> (PGSHIFT + ptshift)) & ((1 << vm.idxbits) - 1);
+
+    // check that physical address of PTE is legal
+    auto pte_paddr = s2xlate(addr, base + idx * vm.ptesize, LOAD, type, virt, false);
+
+    std::cerr << "\tpte_paddr: " << std::hex << pte_paddr << std::endl;
+
+    //auto ppte = sim->addr_to_mem(pte_paddr);
+    bool ppte = true;
+    if (!ppte || !pmp_ok(pte_paddr, vm.ptesize, LOAD, PRV_S))
+    {
+        return 2; //access_exception
+    }
+    //  throw_access_exception(virt, addr, type);
+
+    uint64_t ppte_val = 0ull;
+
+    //std::cerr << "length: " << len << " paddr: " << std::hex << paddr <<  std::endl;
+    ppte_val = sim->sparse_read(pte_paddr, sizeof(uint64_t));
+    //uint64_t ppte_reversed_val = 0ull;
+    //uint8_t* val = (uint8_t*)&ppte_val;
+    //uint8_t* rev = (uint8_t*)&ppte_reversed_val;
+    //for (int i = 0; i < sizeof(uint64_t); i++)
+    //{
+    //  rev[i] = val[sizeof(uint64_t)-1-i];
+    //}
+    //ppte_val = ppte_reversed_val;
+
+    reg_t pte = vm.ptesize == 4 ? from_target(*(target_endian<uint32_t>*)(&ppte_val)) : from_target(*(target_endian<uint64_t>*)(&ppte_val));
+    reg_t ppn = (pte & ~reg_t(PTE_ATTR)) >> PTE_PPN_SHIFT;
+
+    std::cerr << "\tpte: " << std::hex << pte << std::endl;
+    std::cerr << "\tppn: " << std::hex << ppn << std::endl;
+
+    if (pte & PTE_RSVD) {
+      break;
+    } else if (PTE_TABLE(pte)) { // next level of page table
+      if (pte & (PTE_D | PTE_A | PTE_U | PTE_N | PTE_PBMT))
+        break;
+      base = ppn << PGSHIFT;
+      std::cerr << "\t\tgoing another level." << std::endl;
+    } else if ((pte & PTE_U) ? s_mode && (type == FETCH || !sum) : !s_mode) {
+      std::cerr << "\t\tproblem 1." << std::endl;
+      break;
+    } else if (!(pte & PTE_V) || (!(pte & PTE_R) && (pte & PTE_W))) {
+      std::cerr << "\t\tproblem 2." << std::endl;
+      std::cerr << "\t\tis !(pte & PTE_V)?: " << (!(pte & PTE_V)) << std::endl;
+      std::cerr << "\t\tis !(pte & PTE_R)?: " << (!(pte & PTE_R)) << std::endl;
+      std::cerr << "\t\tis (pte & PTE_W)?: " << (pte & PTE_W) << std::endl;
+      break;
+    } else if (type == FETCH || hlvx ? !(pte & PTE_X) :
+               type == LOAD          ? !(pte & PTE_R) && !(mxr && (pte & PTE_X)) :
+                                       !((pte & PTE_R) && (pte & PTE_W))) {
+      std::cerr << "\t\tproblem 3." << std::endl;
+      break;
+    } else if ((ppn & ((reg_t(1) << ptshift) - 1)) != 0) {
+      std::cerr << "\t\tproblem 4." << std::endl;
+      break;
+    } else {
+      std::cerr << "\t\tvalid path." << std::endl;
+      reg_t ad = PTE_A | ((type == STORE) * PTE_D);
+      // take exception if access or possibly dirty bit is not set.
+      if ((pte & ad) != ad){
+        std::cerr << "\t\tproblem 5." << std::endl;
+        break;
+      }
+      // for superpage or Svnapot NAPOT mappings, make a fake leaf PTE for the TLB's benefit.
+      reg_t vpn = addr >> PGSHIFT;
+
+      int napot_bits = ((pte & PTE_N) ? (ctz(ppn) + 1) : 0);
+      if (((pte & PTE_N) && (ppn == 0 || i != 0)) || (napot_bits != 0 && napot_bits != 4))
+        break;
+
+      reg_t page_base = ((ppn & ~((reg_t(1) << napot_bits) - 1))
+                        | (vpn & ((reg_t(1) << napot_bits) - 1))
+                        | (vpn & ((reg_t(1) << ptshift) - 1))) << PGSHIFT;
+      reg_t phys = page_base | (addr & page_mask);
+      reg_t value = s2xlate(addr, phys, type, type, virt, hlvx) & ~page_mask;
+      if(paddr_ptr != nullptr)
+      {
+        *paddr_ptr = value;
+        return 0;
+      }
+      else
+      {
+        // this should have been caught earlier
+        return 7;
+      }
+    }
+  }
+
+  switch (type) {
+    case FETCH: 
+    {
+        return 3; // instruction page fault
+    }
+    case LOAD: 
+    {
+        return 4; // load page fault
+    }
+    case STORE: 
+    {
+        return 5; // store page fault
+    }
+    default: 
+    {
+        return 6; // got here without one of the three other access types; probably not supposed to happen.
+    }
+  }
+}
+
 void mmu_t::register_memtracer(memtracer_t* t)
 {
   flush_tlb();
diff --git a/riscv/mmu.h b/riscv/mmu.h
index 0b86f6cc..0f905fce 100644
--- a/riscv/mmu.h
+++ b/riscv/mmu.h
@@ -13,6 +13,49 @@
 #include "byteorder.h"
 #include <stdlib.h>
 #include <vector>
+#include "Force_Memory.h"
+
+//!< MmuEvent - struct used to record memory events from simulator...
+typedef enum _Memtype { Strong,Device,Normal } Memtype;
+typedef unsigned int CacheType;
+typedef unsigned int CacheAttrs;
+struct MmuEvent
+{
+  MmuEvent(uint64_t _va, uint64_t _pa, Memtype _type, bool _has_stage_two, CacheType _outer_type, CacheAttrs _outer_attrs, CacheType _inner_type, CacheAttrs _inner_attrs)
+    : va(_va), pa(_pa), type(_type), has_stage_two(_has_stage_two), outer_type(_outer_type), outer_attrs(_outer_attrs), inner_type(_inner_type), inner_attrs(_inner_attrs)
+  {
+  }
+
+  uint64_t va;
+  uint64_t pa;
+  Memtype type;
+  bool has_stage_two;
+  CacheType outer_type;
+  CacheAttrs outer_attrs;
+  CacheType inner_type;
+  CacheAttrs inner_attrs;
+};
+
+struct SimException {
+  SimException() : mExceptionID(0), mExceptionAttributes(0), mpComments(""), mEPC(0) {}
+  SimException(uint32_t exceptionID, uint32_t exceptionAttributes, const char* comments, uint64_t epc) :
+    mExceptionID(exceptionID), mExceptionAttributes(exceptionAttributes), mpComments(comments), mEPC(epc) {}
+  uint32_t mExceptionID; //!< 0x4E: eret. Other values are scause or mcause codes.   
+  uint32_t  mExceptionAttributes;  //!< copied from tval. 
+  const char* mpComments; //!<  exception comments, identifies enter, exit and m or s modes.
+  uint64_t mEPC; //!< exception program counter.
+};
+
+extern "C" {
+    // memory r/w callback
+    void update_generator_memory(uint32_t cpuid, uint64_t virtualAddress, uint32_t memBank, uint64_t physicalAddress, uint32_t size, const char *pBytes, const char *pAccessType);
+
+    // mmu update callback
+    void update_mmu_event(MmuEvent *event);
+
+    //exception handling callback
+    void update_exception_event(const SimException* exception);
+}
 
 // virtual memory configuration
 #define PGSHIFT 12
@@ -77,6 +120,19 @@ public:
 #endif
   }
 
+  inline reg_t misaligned_load_partially_initialized(reg_t addr, size_t size, uint32_t xlate_flags)
+  {
+#ifdef RISCV_ENABLE_MISALIGNED
+    reg_t res = 0;
+    for (size_t i = 0; i < size; i++)
+      res += (reg_t)load_partially_initialized_uint8(addr + i) << (i * 8);
+    return res;
+#else
+    bool gva = ((proc) ? proc->state.v : false) || (RISCV_XLATE_VIRT & xlate_flags);
+    throw trap_load_address_misaligned(gva, addr, 0, 0);
+#endif
+  }
+
   inline void misaligned_store(reg_t addr, reg_t data, size_t size, uint32_t xlate_flags)
   {
 #ifdef RISCV_ENABLE_MISALIGNED
@@ -105,17 +161,24 @@ public:
       reg_t vpn = addr >> PGSHIFT; \
       size_t size = sizeof(type##_t); \
       if ((xlate_flags) == 0 && likely(tlb_load_tag[vpn % TLB_ENTRIES] == vpn)) { \
-        if (proc) READ_MEM(addr, size); \
-        return from_target(*(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); \
+        reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
+        type##_t data = static_cast<type##_t>(sim->sparse_read(paddr, size)); \
+        data = to_value_from_be(data); \
+        type##_t update_data = to_target_from_value(data); \
+        update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&update_data), "read"); \
+        return data; \
       } \
       if ((xlate_flags) == 0 && unlikely(tlb_load_tag[vpn % TLB_ENTRIES] == (vpn | TLB_CHECK_TRIGGERS))) { \
-        type##_t data = from_target(*(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); \
+        reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
+        type##_t data = static_cast<type##_t>(sim->sparse_read(paddr, size)); \
+        data = to_value_from_be(data); \
         if (!matched_trigger) { \
           matched_trigger = trigger_exception(OPERATION_LOAD, addr, data); \
           if (matched_trigger) \
             throw *matched_trigger; \
         } \
-        if (proc) READ_MEM(addr, size); \
+        type##_t update_data = to_target_from_value(data); \
+        update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&update_data), "read"); \
         return data; \
       } \
       target_endian<type##_t> res; \
@@ -150,12 +213,18 @@ public:
   load_func(int32, guest_load, RISCV_XLATE_VIRT)
   load_func(int64, guest_load, RISCV_XLATE_VIRT)
 
-#ifndef RISCV_ENABLE_COMMITLOG
-# define WRITE_MEM(addr, value, size) ({})
-#else
-# define WRITE_MEM(addr, val, size) \
-  proc->state.log_mem_write.push_back(std::make_tuple(addr, val, size));
-#endif
+  // template for functions that load an aligned value from memory
+  #define load_func_partially_initialized(type, xlate_flags)\
+    inline type##_t load_partially_initialized_##type(reg_t addr) { \
+      if (unlikely(addr & (sizeof(type##_t)-1))) \
+        return misaligned_load_partially_initialized(addr, sizeof(type##_t), xlate_flags); \
+      type##_t res; \
+      load_slow_path_partially_initialized(addr, sizeof(type##_t), (uint8_t*)&res, xlate_flags); \
+      return res; \
+    }
+
+  load_func_partially_initialized(uint8, 0)
+  load_func_partially_initialized(uint64, 0)
 
   // template for functions that store an aligned value to memory
   #define store_func(type, prefix, xlate_flags) \
@@ -163,10 +232,12 @@ public:
       if (unlikely(addr & (sizeof(type##_t)-1))) \
         return misaligned_store(addr, val, sizeof(type##_t), xlate_flags); \
       reg_t vpn = addr >> PGSHIFT; \
-      size_t size = sizeof(type##_t); \
+      type##_t data = to_target_from_value(val); \
+      reg_t size = sizeof(type##_t); \
       if ((xlate_flags) == 0 && likely(tlb_store_tag[vpn % TLB_ENTRIES] == vpn)) { \
-        if (proc) WRITE_MEM(addr, val, size); \
-        *(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val); \
+        reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
+        update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&data), "write"); \
+        sim->sparse_write_with_initialization(paddr, (const uint8_t*)&data, size); \
       } \
       else if ((xlate_flags) == 0 && unlikely(tlb_store_tag[vpn % TLB_ENTRIES] == (vpn | TLB_CHECK_TRIGGERS))) { \
         if (!matched_trigger) { \
@@ -174,15 +245,14 @@ public:
           if (matched_trigger) \
             throw *matched_trigger; \
         } \
-        if (proc) WRITE_MEM(addr, val, size); \
-        *(target_endian<type##_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val); \
+        reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr; \
+        update_generator_memory(nullptr != proc ? proc->id : 0xffffffffu, addr, 0, paddr, size, reinterpret_cast<const char*>(&data), "write"); \
+        sim->sparse_write_with_initialization(paddr, (const uint8_t*)&data, size); \
       } \
       else { \
-        target_endian<type##_t> target_val = to_target(val); \
-        store_slow_path(addr, sizeof(type##_t), (const uint8_t*)&target_val, (xlate_flags)); \
-        if (proc) WRITE_MEM(addr, val, size); \
+       store_slow_path(addr, sizeof(type##_t), (const uint8_t*)&data, (xlate_flags)); \
       } \
-  }
+    }
 
   // template for functions that perform an atomic memory operation
   #define amo_func(type) \
@@ -242,18 +312,20 @@ public:
   amo_func(uint32)
   amo_func(uint64)
 
+  static const size_t LOAD_RESERVATION_SIZE = 8;
+
   inline void yield_load_reservation()
   {
+    sim->sparse_unreserve(load_reservation_address, LOAD_RESERVATION_SIZE);
     load_reservation_address = (reg_t)-1;
   }
 
   inline void acquire_load_reservation(reg_t vaddr)
   {
-    reg_t paddr = translate(vaddr, 1, LOAD, 0);
-    if (auto host_addr = sim->addr_to_mem(paddr))
-      load_reservation_address = refill_tlb(vaddr, paddr, host_addr, LOAD).target_offset + vaddr;
-    else
-      throw trap_load_access_fault((proc) ? proc->state.v : false, vaddr, 0, 0); // disallow LR to I/O space
+    load_reservation_address = translate(vaddr, LOAD_RESERVATION_SIZE, LOAD, 0);
+    sim->sparse_reserve(load_reservation_address, LOAD_RESERVATION_SIZE);
+    refill_tlb(vaddr, load_reservation_address, 0ull /*host_addr*/, LOAD);
+    return;
   }
 
   inline void load_reserved_address_misaligned(reg_t vaddr)
@@ -281,11 +353,9 @@ public:
     if (vaddr & (size-1))
       store_conditional_address_misaligned(vaddr);
 
-    reg_t paddr = translate(vaddr, 1, STORE, 0);
-    if (auto host_addr = sim->addr_to_mem(paddr))
-      return load_reservation_address == refill_tlb(vaddr, paddr, host_addr, STORE).target_offset + vaddr;
-    else
-      throw trap_store_access_fault((proc) ? proc->state.v : false, vaddr, 0, 0); // disallow SC to I/O space
+    reg_t paddr = translate(vaddr, LOAD_RESERVATION_SIZE, STORE, 0);
+    refill_tlb(vaddr, paddr, 0ull /*host_addr*/, STORE);
+    return (paddr == load_reservation_address) and (sim->sparse_is_reserved(load_reservation_address, LOAD_RESERVATION_SIZE));
   }
 
   static const reg_t ICACHE_ENTRIES = 1024;
@@ -298,21 +368,58 @@ public:
   inline icache_entry_t* refill_icache(reg_t addr, icache_entry_t* entry)
   {
     auto tlb_entry = translate_insn_addr(addr);
-    insn_bits_t insn = from_le(*(uint16_t*)(tlb_entry.host_offset + addr));
+    uint16_t insn_buf = 0;
+    uint64_t load_buff = 0ull;
+    uint64_t muh_paddr = tlb_entry.target_offset + addr;
+    size_t len = sizeof(uint16_t);
+    load_buff = sim->sparse_read(muh_paddr, len); 
+    reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+    reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+
+    insn_bits_t insn = from_le(insn_buf); 
+
     int length = insn_length(insn);
 
     if (likely(length == 4)) {
-      insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
+      load_buff = sim->sparse_read(muh_paddr + 2, len); 
+      reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+      reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+      insn_buf = from_le(insn_buf);
+      insn |= (insn_bits_t)(const int16_t)insn_buf << 16;
     } else if (length == 2) {
       insn = (int16_t)insn;
+
     } else if (length == 6) {
-      insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 4)) << 32;
-      insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
+      load_buff = sim->sparse_read(muh_paddr + 4, len); 
+      reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+      reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+      insn_buf = from_le(insn_buf); 
+      insn |= (insn_bits_t)(const int16_t)insn_buf << 32;
+
+      load_buff = sim->sparse_read(muh_paddr + 2, len); 
+      reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+      reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+      insn_buf = from_le(insn_buf); 
+      insn |= (insn_bits_t)(const uint16_t)insn_buf << 16;
     } else {
       static_assert(sizeof(insn_bits_t) == 8, "insn_bits_t must be uint64_t");
-      insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 6)) << 48;
-      insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 4)) << 32;
-      insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
+      load_buff = sim->sparse_read(muh_paddr + 6, len); 
+      reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+      reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+      insn_buf = from_le(insn_buf); 
+      insn |= (insn_bits_t)(const int16_t)insn_buf << 48;
+
+      load_buff = sim->sparse_read(muh_paddr + 4, len); 
+      reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+      reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+      insn_buf = from_le(insn_buf); 
+      insn |= (insn_bits_t)(const uint16_t)insn_buf << 32;
+
+      load_buff = sim->sparse_read(muh_paddr + 2, len); 
+      reinterpret_cast<uint8_t*>(&insn_buf)[0] = reinterpret_cast<uint8_t*>(&load_buff)[1]; 
+      reinterpret_cast<uint8_t*>(&insn_buf)[1] = reinterpret_cast<uint8_t*>(&load_buff)[0]; 
+      insn_buf = from_le(insn_buf); 
+      insn |= (insn_bits_t)(const uint16_t)insn_buf << 16;
     }
 
     insn_fetch_t fetch = {proc->decode_insn(insn), insn};
@@ -389,6 +496,35 @@ public:
     return target_big_endian? target_endian<T>::to_be(n) : target_endian<T>::to_le(n);
   }
 
+  template<typename T> inline T to_target_from_value(T n) const
+  {
+    return target_big_endian? to_be(n) : to_le(n);
+  }
+
+  template<typename T> inline T to_value_from_be(T n) const
+  {
+    return target_big_endian? n : from_be(n);
+  }
+
+
+  reg_t translate(reg_t addr, reg_t len, access_type type, uint32_t xlate_flags);
+
+  // Translate a VA to a PA by performing a page table walk but don't set any state bits
+  // and instead of throwing exceptions, return codes are used.
+  //
+  // Does a pmp check on the recovered PA.
+  //
+  //    returns:
+  //        0 - walk was successful
+  //        1 - PMP problem with PA after address translation somehow
+  //        2 - access exception while trying to check pmp status of page table entry PA
+  //        3 - walk was unsuccessful and access type was FETCH
+  //        4 - walk was unsuccessful and access type was LOAD
+  //        5 - walk was unsuccessful and access type was STORE
+  //        6 - walk was unsuccessful and access type was not any of the above
+  //        7 - walk would have been successful had paddr_ptr not been a null pointer
+  int translate_api(reg_t addr, reg_t* paddr, uint64_t* pmp_info, reg_t len, access_type type, uint32_t xlate_flags);
+
 private:
   simif_t* sim;
   processor_t* proc;
@@ -419,14 +555,26 @@ private:
   // perform a page table walk for a given VA; set referenced/dirty bits
   reg_t walk(reg_t addr, access_type type, reg_t prv, bool virt, bool hlvx);
 
+  // perform a page table walk but don't set any state bits
+  // and instead of throwing exceptions, return codes are used:
+  //
+  //    returns:
+  //        0 - walk was successful
+  //        2 - access exception while trying to check pmp status of page table entry PA
+  //        3 - walk was unsuccessful and access type was FETCH
+  //        4 - walk was unsuccessful and access type was LOAD
+  //        5 - walk was unsuccessful and access type was STORE
+  //        6 - walk was unsuccessful and access type was not any of the above
+  //        7 - walk would have been successful had paddr_ptr not been a null pointer
+  int walk_api(reg_t addr, reg_t* paddr_ptr, access_type type, reg_t prv, bool virt, bool hlvx);
+
   // handle uncommon cases: TLB misses, page faults, MMIO
   tlb_entry_t fetch_slow_path(reg_t addr);
   void load_slow_path(reg_t addr, reg_t len, uint8_t* bytes, uint32_t xlate_flags);
+  void load_slow_path_partially_initialized(reg_t addr, reg_t len, uint8_t* bytes, uint32_t xlate_flags);
   void store_slow_path(reg_t addr, reg_t len, const uint8_t* bytes, uint32_t xlate_flags);
-  bool mmio_load(reg_t addr, size_t len, uint8_t* bytes);
-  bool mmio_store(reg_t addr, size_t len, const uint8_t* bytes);
-  bool mmio_ok(reg_t addr, access_type type);
-  reg_t translate(reg_t addr, reg_t len, access_type type, uint32_t xlate_flags);
+  void initialize_slow_path(reg_t addr, reg_t len, const uint8_t* bytes, uint32_t xlate_flags);
+  //reg_t translate(reg_t addr, reg_t len, access_type type);
 
   // ITLB lookup
   inline tlb_entry_t translate_insn_addr(reg_t addr) {
@@ -440,18 +588,23 @@ private:
       result = tlb_data[vpn % TLB_ENTRIES];
     }
     if (unlikely(tlb_insn_tag[vpn % TLB_ENTRIES] == (vpn | TLB_CHECK_TRIGGERS))) {
-      target_endian<uint16_t>* ptr = (target_endian<uint16_t>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr);
-      int match = proc->trigger_match(OPERATION_EXECUTE, addr, from_target(*ptr));
+      reg_t paddr = tlb_data[vpn % TLB_ENTRIES].target_offset + addr;
+
+      uint16_t load_buff = 0;
+      load_buff = static_cast<uint16_t>(sim->sparse_read(paddr, sizeof(uint16_t)));
+
+      int match = proc->trigger_match(OPERATION_EXECUTE, addr, from_be(load_buff));
       if (match >= 0) {
-        throw trigger_matched_t(match, OPERATION_EXECUTE, addr, from_target(*ptr));
+        throw trigger_matched_t(match, OPERATION_EXECUTE, addr, from_be(load_buff));
       }
     }
     return result;
   }
 
-  inline const uint16_t* translate_insn_addr_to_host(reg_t addr) {
-    return (uint16_t*)(translate_insn_addr(addr).host_offset + addr);
-  }
+  //possibly remove
+  //inline const uint16_t* translate_insn_addr_to_host(reg_t addr) {
+  //  return (uint16_t*)(translate_insn_addr(addr).host_offset + addr);
+  //}
 
   inline trigger_matched_t *trigger_exception(trigger_operation_t operation,
       reg_t address, reg_t data)
@@ -470,6 +623,7 @@ private:
 
   reg_t pmp_homogeneous(reg_t addr, reg_t len);
   bool pmp_ok(reg_t addr, reg_t len, access_type type, reg_t mode);
+  bool pmp_ok_api(reg_t addr, reg_t* pmpaddr_ptr, uint8_t* pmpcfg_ptr, reg_t len, access_type type, reg_t mode);
 
 #ifdef RISCV_ENABLE_DUAL_ENDIAN
   bool target_big_endian;
diff --git a/riscv/processor.cc b/riscv/processor.cc
index 876c32d4..44d5c53f 100644
--- a/riscv/processor.cc
+++ b/riscv/processor.cc
@@ -18,18 +18,20 @@
 #include <limits.h>
 #include <stdexcept>
 #include <string>
+#include <cstring>
 #include <algorithm>
 
+//DEBUG
+#include <iostream>
+
 #undef STATE
 #define STATE state
 
-processor_t::processor_t(const char* isa, const char* priv, const char* varch,
-                         simif_t* sim, uint32_t id, bool halt_on_reset,
-                         FILE* log_file, std::ostream& sout_)
-  : debug(false), halt_request(HR_NONE), sim(sim), id(id), xlen(0),
-  histogram_enabled(false), log_commits_enabled(false),
-  log_file(log_file), sout_(sout_.rdbuf()), halt_on_reset(halt_on_reset),
-  extension_table(256, false), impl_table(256, false), last_pc(1), executions(1)
+processor_t::processor_t(const char* isa, const char* priv, const char* varch, simif_t* sim,
+                         uint32_t pid, bool halt_on_reset,
+                         std::ostream& sout_)
+: debug(false), halt_request(HR_NONE), sim(sim), state(pid), id(pid), xlen(0),
+ sout_(sout_.rdbuf()), halt_on_reset(halt_on_reset), extension_table(256, false), impl_table(256, false), last_pc(1), executions(1)
 {
   VU.p = this;
 
@@ -58,15 +60,6 @@ processor_t::processor_t(const char* isa, const char* priv, const char* varch,
 
 processor_t::~processor_t()
 {
-#ifdef RISCV_ENABLE_HISTOGRAM
-  if (histogram_enabled)
-  {
-    fprintf(stderr, "PC Histogram size:%zu\n", pc_histogram.size());
-    for (auto it : pc_histogram)
-      fprintf(stderr, "%0" PRIx64 " %" PRIu64 "\n", it.first, it.second);
-  }
-#endif
-
   delete mmu;
   delete disassembler;
 }
@@ -332,17 +325,20 @@ void processor_t::parse_isa_string(const char* str)
   }
 }
 
-void state_t::reset(processor_t* const proc, reg_t max_isa)
+void state_t::reset(processor_t* const proc, reg_t max_isa, uint32_t id)
 {
   pc = DEFAULT_RSTVEC;
+  prv = PRV_M;
+  pid = id;
   XPR.reset();
   FPR.reset();
+  XPR.set_pid(id);
+  FPR.set_pid(id);
 
   // This assumes xlen is always max_xlen, which is true today (see
   // mstatus_csr_t::unlogged_write()):
   auto xlen = proc->get_max_xlen();
 
-  prv = PRV_M;
   v = false;
   csrmap[CSR_MISA] = misa = std::make_shared<misa_csr_t>(proc, CSR_MISA, max_isa);
   csrmap[CSR_MSTATUS] = mstatus = std::make_shared<mstatus_csr_t>(proc, CSR_MSTATUS);
@@ -481,7 +477,11 @@ void processor_t::vectorUnit_t::reset(){
   memset(reg_file, 0, NVPR * vlenb);
 
   vtype = 0;
+  update_generator_register(p->id, "vtype", vtype, 0xffffffffffffffff, "write");
   set_vl(0, 0, 0, -1); // default to illegal configuration
+
+  //std::cout << "WARNING, vtype is hardcoded in the simulator (processor.cc, processor_t::vectorUnit_t::reset()), replace with vsetvl(i) ASAP." << std::endl;
+  //set_vl(0, 0, 0, 0b0001000); // this could be changed to force a legal configuration 
 }
 
 reg_t processor_t::vectorUnit_t::set_vl(int rd, int rs1, reg_t reqVL, reg_t newType){
@@ -503,6 +503,8 @@ reg_t processor_t::vectorUnit_t::set_vl(int rd, int rs1, reg_t reqVL, reg_t newT
       vlmax = 0;
       vtype = UINT64_MAX << (p->get_xlen() - 1);
     }
+
+    update_generator_register(p->id, "vtype", vtype, 0xffffffffffffffff, "write");
   }
 
   // set vl
@@ -516,11 +518,42 @@ reg_t processor_t::vectorUnit_t::set_vl(int rd, int rs1, reg_t reqVL, reg_t newT
     vl = reqVL > vlmax ? vlmax : reqVL;
   }
 
+
+  update_generator_register(p->id, "vl", vl, 0xffffffffffffffff, "write");
   vstart = 0;
+  update_generator_register(p->id, "vstart", vstart, 0xffffffffffffffff, "write");
   setvl_count++;
   return vl;
 }
 
+reg_t processor_t::vectorUnit_t::set_vl_api(reg_t reqVL, reg_t newType){
+  int new_vlmul = 0;
+  if (vtype != newType){
+    vtype = newType;
+    vsew = 1 << (extract64(newType, 3, 3) + 3);
+    new_vlmul = int8_t(extract64(newType, 0, 3) << 5) >> 5;
+    vflmul = new_vlmul >= 0 ? 1 << new_vlmul : 1.0 / (1 << -new_vlmul);
+    vlmax = (VLEN/vsew) * vflmul;
+    vta = extract64(newType, 6, 1);
+    vma = extract64(newType, 7, 1);
+
+    vill = !(vflmul >= 0.125 && vflmul <= 8)
+           || vsew > std::min(vflmul, 1.0f) * ELEN
+           || (newType >> 8) != 0;
+
+    if (vill) {
+      vlmax = 0;
+      vtype = UINT64_MAX << (p->get_xlen() - 1);
+    }
+  }
+
+  vl = reqVL;
+
+  vstart = 0;
+  //setvl_count++;
+  return vl;
+}
+
 void processor_t::set_debug(bool value)
 {
   debug = value;
@@ -532,26 +565,12 @@ void processor_t::set_debug(bool value)
 void processor_t::set_histogram(bool value)
 {
   histogram_enabled = value;
-#ifndef RISCV_ENABLE_HISTOGRAM
-  if (value) {
-    fprintf(stderr, "PC Histogram support has not been properly enabled;");
-    fprintf(stderr, " please re-build the riscv-isa-sim project using \"configure --enable-histogram\".\n");
-    abort();
-  }
-#endif
-}
-
-#ifdef RISCV_ENABLE_COMMITLOG
-void processor_t::enable_log_commits()
-{
-  log_commits_enabled = true;
 }
-#endif
 
 void processor_t::reset()
 {
   xlen = max_xlen;
-  state.reset(this, max_isa);
+  state.reset(this, max_isa, id);
   state.dcsr.halt = halt_on_reset;
   halt_on_reset = false;
   VU.reset();
@@ -637,6 +656,7 @@ void processor_t::set_mmu_capability(int cap)
 
 void processor_t::take_interrupt(reg_t pending_interrupts)
 {
+  //need to add register read callback calls here
   // Do nothing if no pending interrupts
   if (!pending_interrupts) {
     return;
@@ -713,6 +733,13 @@ reg_t processor_t::legalize_privilege(reg_t prv)
 }
 
 void processor_t::set_privilege(reg_t prv)
+{
+  mmu->flush_tlb();
+  state.prv = legalize_privilege(prv);
+  update_generator_register(this->id, "privilege", prv, 0x3ull, "write");
+}
+
+void processor_t::set_privilege_api(reg_t prv)
 {
   mmu->flush_tlb();
   state.prv = legalize_privilege(prv);
@@ -740,12 +767,12 @@ void processor_t::set_virt(bool virt)
 
 void processor_t::enter_debug_mode(uint8_t cause)
 {
-  state.debug_mode = true;
-  state.dcsr.cause = cause;
-  state.dcsr.prv = state.prv;
-  set_privilege(PRV_M);
-  state.dpc = state.pc;
-  state.pc = DEBUG_ROM_ENTRY;
+//  state.debug_mode = true;
+//  state.dcsr.cause = cause;
+//  state.dcsr.prv = state.prv;
+//  set_privilege(PRV_M);
+//  state.dpc = state.pc;
+//  state.pc = DEBUG_ROM_ENTRY;
 }
 
 void processor_t::debug_output_log(std::stringstream *s)
@@ -760,32 +787,11 @@ void processor_t::debug_output_log(std::stringstream *s)
 
 void processor_t::take_trap(trap_t& t, reg_t epc)
 {
-  if (debug) {
-    std::stringstream s; // first put everything in a string, later send it to output
-    s << "core " << std::dec << std::setfill(' ') << std::setw(3) << id
-      << ": exception " << t.name() << ", epc 0x"
-      << std::hex << std::setfill('0') << std::setw(max_xlen/4) << zext(epc, max_xlen) << std::endl;
-    if (t.has_tval())
-       s << "core " << std::dec << std::setfill(' ') << std::setw(3) << id
-         << ":           tval 0x" << std::hex << std::setfill('0') << std::setw(max_xlen/4)
-         << zext(t.get_tval(), max_xlen) << std::endl;
-    debug_output_log(&s);
-  }
-
-  if (state.debug_mode) {
-    if (t.cause() == CAUSE_BREAKPOINT) {
-      state.pc = DEBUG_ROM_ENTRY;
-    } else {
-      state.pc = DEBUG_ROM_TVEC;
-    }
-    return;
-  }
-
   if (t.cause() == CAUSE_BREAKPOINT && (
               (state.prv == PRV_M && state.dcsr.ebreakm) ||
               (state.prv == PRV_S && state.dcsr.ebreaks) ||
               (state.prv == PRV_U && state.dcsr.ebreaku))) {
-    enter_debug_mode(DCSR_CAUSE_SWBP);
+    //enter_debug_mode(DCSR_CAUSE_SWBP);
     return;
   }
 
@@ -797,10 +803,17 @@ void processor_t::take_trap(trap_t& t, reg_t epc)
   if (interrupt) {
     vsdeleg = (curr_virt && state.prv <= PRV_S) ? (state.mideleg->read() & state.hideleg) : 0;
     hsdeleg = (state.prv <= PRV_S) ? state.mideleg->read() : 0;
+
+    update_generator_register(this->id, "mideleg", state.mideleg->read(), 0xffffffffffffffffull, "read");
+    update_generator_register(this->id, "mideleg", state.hideleg, 0xffffffffffffffffull, "read");
+
     bit &= ~((reg_t)1 << (max_xlen-1));
   } else {
     vsdeleg = (curr_virt && state.prv <= PRV_S) ? (state.medeleg->read() & state.hedeleg) : 0;
     hsdeleg = (state.prv <= PRV_S) ? state.medeleg->read() : 0;
+
+    update_generator_register(this->id, "medeleg", state.medeleg->read(), 0xffffffffffffffffull, "read");
+    update_generator_register(this->id, "hedeleg", state.hedeleg, 0xffffffffffffffffull, "read");
   }
   if (state.prv <= PRV_S && bit < max_xlen && ((vsdeleg >> bit) & 1)) {
     // Handle the trap in VS-mode
@@ -827,6 +840,16 @@ void processor_t::take_trap(trap_t& t, reg_t epc)
     state.htval = t.get_tval2();
     state.htinst = t.get_tinst();
 
+    update_generator_register(this->id, "stvec", state.stvec->read(), 0xffffffffffffffffull, "read");
+    update_generator_register(this->id, "PC", state.pc, 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "scause", state.scause->read(), 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "sepc", state.sepc->read(), 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "stval", state.stval->read(), 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "vstart", VU.vstart, 0xffffffffffffffffull, "write");
+
+    SimException enter_s(state.scause->read(), state.stval->read(), "enter_s", epc);
+    update_exception_event(&enter_s);
+
     reg_t s = state.sstatus->read();
     s = set_field(s, MSTATUS_SPIE, get_field(s, MSTATUS_SIE));
     s = set_field(s, MSTATUS_SPP, state.prv);
@@ -852,6 +875,16 @@ void processor_t::take_trap(trap_t& t, reg_t epc)
     state.mtval2 = t.get_tval2();
     state.mtinst = t.get_tinst();
 
+    update_generator_register(this->id, "mtvec", state.mtvec->read(), 0xffffffffffffffffull, "read");
+    update_generator_register(this->id, "PC", state.pc, 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "mcause", state.mcause->read(), 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "mepc", state.mepc->read(), 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "mtval", state.mtval->read(), 0xffffffffffffffffull, "write");
+    update_generator_register(this->id, "vstart", VU.vstart, 0xffffffffffffffffull, "write");
+
+    SimException enter_m(state.mcause->read(), state.mtval->read(), "enter_m", epc);
+    update_exception_event(&enter_m);
+
     reg_t s = state.mstatus->read();
     s = set_field(s, MSTATUS_MPIE, get_field(s, MSTATUS_MIE));
     s = set_field(s, MSTATUS_MPP, state.prv);
@@ -867,29 +900,6 @@ void processor_t::disasm(insn_t insn)
 {
   uint64_t bits = insn.bits() & ((1ULL << (8 * insn_length(insn.bits()))) - 1);
   if (last_pc != state.pc || last_bits != bits) {
-    std::stringstream s;  // first put everything in a string, later send it to output
-
-#ifdef RISCV_ENABLE_COMMITLOG
-    const char* sym = get_symbol(state.pc);
-    if (sym != nullptr)
-    {
-      s << "core " << std::dec << std::setfill(' ') << std::setw(3) << id
-        << ": >>>>  " << sym << std::endl;
-    }
-#endif
-
-    if (executions != 1) {
-      s << "core " << std::dec << std::setfill(' ') << std::setw(3) << id
-        << ": Executed " << executions << " times" << std::endl;
-    }
-
-    s << "core " << std::dec << std::setfill(' ') << std::setw(3) << id
-      << std::hex << ": 0x" << std::setfill('0') << std::setw(max_xlen/4)
-      << zext(state.pc, max_xlen) << " (0x" << std::setw(8) << bits << ") "
-      << disassembler->disassemble(insn) << std::endl;
-
-    debug_output_log(&s);
-
     last_pc = state.pc;
     last_bits = bits;
     executions = 1;
@@ -920,9 +930,25 @@ void processor_t::set_csr(int which, reg_t val)
   reg_t coprocessor_ints = (reg_t)any_custom_extensions() << IRQ_COP;
   reg_t delegable_ints = supervisor_ints | coprocessor_ints;
   reg_t all_ints = delegable_ints | hypervisor_ints | MIP_MSIP | MIP_MTIP | MIP_MEIP;
+
+  reg_t effective_value = 0;
+  std::string text_name = std::string(csr_name(which));
+
   auto search = state.csrmap.find(which);
   if (search != state.csrmap.end()) {
     search->second->write(val);
+
+    // TODO(Noah): Improve this logic when a more general mechanism, i.e. one that could potentially
+    // handle other alias registers, can be devised. Since sstatus is a restricted alias of mstatus,
+    // we need to send the update for the underlying mstatus register.
+    effective_value = search->second->read();
+    if (search->second == STATE.sstatus) {
+      text_name = "mstatus";
+      effective_value = STATE.mstatus->read();
+    }
+
+    update_generator_register(this->id, text_name.c_str(), effective_value, 0xffffffffffffffffull, "write");
+
     return;
   }
 
@@ -930,24 +956,29 @@ void processor_t::set_csr(int which, reg_t val)
   {
     case CSR_SENTROPY:
       es.set_sentropy(val);
+      effective_value = val;
       break;
     case CSR_FFLAGS:
       dirty_fp_state;
       state.fflags = val & (FSR_AEXC >> FSR_AEXC_SHIFT);
+      effective_value = state.fflags;
       break;
     case CSR_FRM:
       dirty_fp_state;
       state.frm = val & (FSR_RD >> FSR_RD_SHIFT);
+      effective_value = state.frm;
       break;
     case CSR_FCSR:
       dirty_fp_state;
       state.fflags = (val & FSR_AEXC) >> FSR_AEXC_SHIFT;
       state.frm = (val & FSR_RD) >> FSR_RD_SHIFT;
+      effective_value = (state.fflags << FSR_AEXC_SHIFT) | (state.frm << FSR_RD_SHIFT);
       break;
     case CSR_VCSR:
       dirty_vs_state;
       VU.vxsat = (val & VCSR_VXSAT) >> VCSR_VXSAT_SHIFT;
       VU.vxrm = (val & VCSR_VXRM) >> VCSR_VXRM_SHIFT;
+      effective_value = (VU.vxsat << VCSR_VXSAT_SHIFT) | (VU.vxrm << VCSR_VXRM_SHIFT);
       break;
     case CSR_MINSTRET:
     case CSR_MCYCLE:
@@ -955,6 +986,8 @@ void processor_t::set_csr(int which, reg_t val)
         state.minstret = (state.minstret >> 32 << 32) | (val & 0xffffffffU);
       else
         state.minstret = val;
+
+      effective_value = state.minstret;
       // The ISA mandates that if an instruction writes instret, the write
       // takes precedence over the increment to instret.  However, Spike
       // unconditionally increments instret after executing an instruction.
@@ -964,10 +997,23 @@ void processor_t::set_csr(int which, reg_t val)
     case CSR_MINSTRETH:
     case CSR_MCYCLEH:
       state.minstret = (val << 32) | (state.minstret << 32 >> 32);
+      effective_value = state.minstret;
       state.minstret--; // See comment above.
       break;
-    case CSR_MTVAL2: state.mtval2 = val; break;
-    case CSR_MTINST: state.mtinst = val; break;
+    case CSR_MTVAL2:
+    {
+        state.mtval2 = val;
+
+        effective_value = state.mtval2;
+        break;
+    }
+    case CSR_MTINST:
+    {
+        state.mtinst = val;
+
+        effective_value = state.mtinst;
+        break;
+    }
     case CSR_HEDELEG: {
       reg_t mask =
         (1 << CAUSE_MISALIGNED_FETCH) |
@@ -983,11 +1029,13 @@ void processor_t::set_csr(int which, reg_t val)
         (1 << CAUSE_LOAD_PAGE_FAULT) |
         (1 << CAUSE_STORE_PAGE_FAULT);
       state.hedeleg = (state.hedeleg & ~mask) | (val & mask);
+      effective_value = state.hedeleg;
       break;
     }
     case CSR_HIDELEG: {
       reg_t mask = MIP_VS_MASK;
       state.hideleg = (state.hideleg & ~mask) | (val & mask);
+      effective_value = state.hideleg;
       break;
     }
     case CSR_HGEIE:
@@ -995,9 +1043,11 @@ void processor_t::set_csr(int which, reg_t val)
       break;
     case CSR_HTVAL:
       state.htval = val;
+      effective_value = state.htval;
       break;
     case CSR_HTINST:
       state.htinst = val;
+      effective_value = state.htinst;
       break;
     case CSR_HGATP: {
       mmu->flush_tlb();
@@ -1016,11 +1066,13 @@ void processor_t::set_csr(int which, reg_t val)
       mask &= ~(reg_t)3;
 
       state.hgatp = val & mask;
+      effective_value = state.hgatp;
       break;
     }
     case CSR_TSELECT:
       if (val < state.num_triggers) {
         state.tselect = val;
+        effective_value = state.tselect;
       }
       break;
     case CSR_TDATA1:
@@ -1046,6 +1098,9 @@ void processor_t::set_csr(int which, reg_t val)
         if (mc->execute)
           mc->timing = 0;
         trigger_updated();
+
+        // If mcontrol_t had a more clear size it may make sense to bitcopy its contents.
+        effective_value = val;
       }
       break;
     case CSR_TDATA2:
@@ -1054,38 +1109,53 @@ void processor_t::set_csr(int which, reg_t val)
       }
       if (state.tselect < state.num_triggers) {
         state.tdata2[state.tselect] = val;
+        
+        effective_value = val;
       }
       break;
     case CSR_DCSR:
       state.dcsr.prv = get_field(val, DCSR_PRV);
       state.dcsr.step = get_field(val, DCSR_STEP);
-      // TODO: ndreset and fullreset
       state.dcsr.ebreakm = get_field(val, DCSR_EBREAKM);
       state.dcsr.ebreakh = get_field(val, DCSR_EBREAKH);
       state.dcsr.ebreaks = get_field(val, DCSR_EBREAKS);
       state.dcsr.ebreaku = get_field(val, DCSR_EBREAKU);
       state.dcsr.halt = get_field(val, DCSR_HALT);
+        
+      memcpy(&effective_value, &(state.dcsr), sizeof(dcsr_t));
       break;
     case CSR_DPC:
       state.dpc = val & ~(reg_t)1;
+
+      effective_value = state.dpc;
       break;
     case CSR_DSCRATCH0:
       state.dscratch0 = val;
+
+      effective_value = state.dscratch0;
       break;
     case CSR_DSCRATCH1:
       state.dscratch1 = val;
+    
+      effective_value = state.dscratch1;
       break;
     case CSR_VSTART:
       dirty_vs_state;
       VU.vstart = val & (VU.get_vlen() - 1);
+
+      effective_value = VU.vstart;
       break;
     case CSR_VXSAT:
       dirty_vs_state;
       VU.vxsat = val & 0x1ul;
+
+      effective_value = VU.vxsat;
       break;
     case CSR_VXRM:
       dirty_vs_state;
       VU.vxrm = val & 0x3ul;
+
+      effective_value = VU.vxrm;
       break;
   }
 
@@ -1134,145 +1204,399 @@ void processor_t::set_csr(int which, reg_t val)
       break;
   }
 #endif
+
+  update_generator_register(this->id, text_name.c_str(), effective_value, 0xffffffffffffffffull, "write");
 }
 
-// Note that get_csr is sometimes called when read side-effects should not
-// be actioned.  In other words, Spike cannot currently support CSRs with
-// side effects on reads.
-reg_t processor_t::get_csr(int which, insn_t insn, bool write, bool peek)
+void processor_t::set_csr_api(int which, reg_t val)
 {
-#define mcounteren_ok(__which) \
-({ \
-  bool __ctr_ok = true; \
-  if (state.prv < PRV_M) \
-    __ctr_ok = (state.mcounteren->read() >> (__which & 31)) & 1;        \
-  __ctr_ok; \
-})
-#define hcounteren_ok(__which) \
-({ \
-  bool __ctr_ok = true; \
-  if (state.v) \
-    __ctr_ok = (state.hcounteren->read() >> (__which & 31)) & 1;        \
-  __ctr_ok; \
-})
-#define scounteren_ok(__which) \
-({ \
-  bool __ctr_ok = true; \
-  if (extension_enabled('S') && state.prv < PRV_S) \
-    __ctr_ok = (state.scounteren->read() >> (__which & 31)) & 1;        \
-  __ctr_ok; \
-})
-
-  reg_t res = 0;
-#define ret(n) do { \
-    res = (n); \
-    goto out; \
-  } while (false)
+#if defined(RISCV_ENABLE_COMMITLOG)
+#define LOG_CSR(rd) \
+  STATE.log_reg_write[((which) << 4) | 4] = {get_csr(rd), 0};
+#else
+#define LOG_CSR(rd)
+#endif
 
+  val = zext_xlen(val);
+  reg_t supervisor_ints = extension_enabled('S') ? MIP_SSIP | MIP_STIP | MIP_SEIP : 0;
+  reg_t vssip_int = extension_enabled('H') ? MIP_VSSIP : 0;
+  reg_t hypervisor_ints = extension_enabled('H') ? MIP_HS_MASK : 0;
+  reg_t coprocessor_ints = (reg_t)any_custom_extensions() << IRQ_COP;
+  reg_t delegable_ints = supervisor_ints | coprocessor_ints;
+  reg_t all_ints = delegable_ints | hypervisor_ints | MIP_MSIP | MIP_MTIP | MIP_MEIP;
   auto search = state.csrmap.find(which);
   if (search != state.csrmap.end()) {
-    if (!peek)
-      search->second->verify_permissions(insn, write);
-    return search->second->read();
+    search->second->write(val);
+    return;
   }
 
   switch (which)
   {
     case CSR_SENTROPY:
-      if (!extension_enabled(EXT_ZKR))
-        break;
-      /* Read-only access disallowed due to wipe-on-read side effect */
-      if (!write)
-        break;
-      ret(es.get_sentropy());
+      es.set_sentropy(val);
+      break;
     case CSR_FFLAGS:
-      require_fp;
-      if (!extension_enabled('F'))
-        break;
-      ret(state.fflags);
+      //dirty_fp_state;
+      state.fflags = val & (FSR_AEXC >> FSR_AEXC_SHIFT);
+      break;
     case CSR_FRM:
-      require_fp;
-      if (!extension_enabled('F'))
-        break;
-      ret(state.frm);
+      //dirty_fp_state;
+      state.frm = val & (FSR_RD >> FSR_RD_SHIFT);
+      break;
     case CSR_FCSR:
-      require_fp;
-      if (!extension_enabled('F'))
-        break;
-      ret((state.fflags << FSR_AEXC_SHIFT) | (state.frm << FSR_RD_SHIFT));
+      //dirty_fp_state;
+      state.fflags = (val & FSR_AEXC) >> FSR_AEXC_SHIFT;
+      state.frm = (val & FSR_RD) >> FSR_RD_SHIFT;
+      break;
     case CSR_VCSR:
-      require_vector_vs;
-      if (!extension_enabled('V'))
-        break;
-      ret((VU.vxsat << VCSR_VXSAT_SHIFT) | (VU.vxrm << VCSR_VXRM_SHIFT));
-    case CSR_INSTRET:
-    case CSR_CYCLE:
-    case CSR_HPMCOUNTER3 ... CSR_HPMCOUNTER31:
-      if (!mcounteren_ok(which))
-          goto throw_illegal;
-      if (!hcounteren_ok(which))
-          goto throw_virtual;
-      if (!scounteren_ok(which)) {
-        if (state.v)
-          goto throw_virtual;
-        else
-          goto throw_illegal;
-      }
-      if (which == CSR_INSTRET || which == CSR_CYCLE)
-        ret(state.minstret);
-      else
-        ret(0);
+      //dirty_vs_state;
+      VU.vxsat = (val & VCSR_VXSAT) >> VCSR_VXSAT_SHIFT;
+      VU.vxrm = (val & VCSR_VXRM) >> VCSR_VXRM_SHIFT;
+      break;
     case CSR_MINSTRET:
     case CSR_MCYCLE:
-    case CSR_MHPMCOUNTER3 ... CSR_MHPMCOUNTER31:
-    case CSR_MHPMEVENT3 ... CSR_MHPMEVENT31:
-      if (which == CSR_MINSTRET || which == CSR_MCYCLE)
-        ret(state.minstret);
-      else
-        ret(0);
-    case CSR_INSTRETH:
-    case CSR_CYCLEH:
-    case CSR_HPMCOUNTER3H ... CSR_HPMCOUNTER31H:
-      if (!mcounteren_ok(which) || xlen != 32)
-          goto throw_illegal;
-      if (!hcounteren_ok(which))
-          goto throw_virtual;
-      if (!scounteren_ok(which)) {
-        if (state.v)
-          goto throw_virtual;
-        else
-          goto throw_illegal;
-      }
-      if (which == CSR_INSTRETH || which == CSR_CYCLEH)
-        ret(state.minstret >> 32);
+      if (xlen == 32)
+        state.minstret = (state.minstret >> 32 << 32) | (val & 0xffffffffU);
       else
-        ret(0);
+        state.minstret = val;
+      // The ISA mandates that if an instruction writes instret, the write
+      // takes precedence over the increment to instret.  However, Spike
+      // unconditionally increments instret after executing an instruction.
+      // Correct for this artifact by decrementing instret here.
+      state.minstret--;
+      break;
     case CSR_MINSTRETH:
     case CSR_MCYCLEH:
-    case CSR_MHPMCOUNTER3H ... CSR_MHPMCOUNTER31H:
-      if (xlen == 32) {
-        if (which == CSR_MINSTRETH || which == CSR_MCYCLEH)
-          ret(state.minstret >> 32);
-        else
-          ret(0);
-      }
-      break;
-    case CSR_MCOUNTINHIBIT: ret(0);
-    case CSR_MSTATUSH:
-      if (xlen == 32)
-        ret((state.mstatus->read() >> 32) & (MSTATUSH_SBE | MSTATUSH_MBE));
-      break;
-    case CSR_MTVAL2:
-      if (extension_enabled('H'))
-        ret(state.mtval2);
-      break;
-    case CSR_MTINST:
-      if (extension_enabled('H'))
-        ret(state.mtinst);
+      state.minstret = (val << 32) | (state.minstret << 32 >> 32);
+      state.minstret--; // See comment above.
       break;
-    case CSR_MARCHID: ret(5);
-    case CSR_MIMPID: ret(0);
-    case CSR_MVENDORID: ret(0);
+    case CSR_MTVAL2: state.mtval2 = val; break;
+    case CSR_MTINST: state.mtinst = val; break;
+    case CSR_HEDELEG: {
+      reg_t mask =
+        (1 << CAUSE_MISALIGNED_FETCH) |
+        (1 << CAUSE_FETCH_ACCESS) |
+        (1 << CAUSE_ILLEGAL_INSTRUCTION) |
+        (1 << CAUSE_BREAKPOINT) |
+        (1 << CAUSE_MISALIGNED_LOAD) |
+        (1 << CAUSE_LOAD_ACCESS) |
+        (1 << CAUSE_MISALIGNED_STORE) |
+        (1 << CAUSE_STORE_ACCESS) |
+        (1 << CAUSE_USER_ECALL) |
+        (1 << CAUSE_FETCH_PAGE_FAULT) |
+        (1 << CAUSE_LOAD_PAGE_FAULT) |
+        (1 << CAUSE_STORE_PAGE_FAULT);
+      state.hedeleg = (state.hedeleg & ~mask) | (val & mask);
+      break;
+    }
+    case CSR_HIDELEG: {
+      reg_t mask = MIP_VS_MASK;
+      state.hideleg = (state.hideleg & ~mask) | (val & mask);
+      break;
+    }
+    case CSR_HGEIE:
+      /* Ignore */
+      break;
+    case CSR_HTVAL:
+      state.htval = val;
+      break;
+    case CSR_HTINST:
+      state.htinst = val;
+      break;
+    case CSR_HGATP: {
+      mmu->flush_tlb();
+
+      reg_t mask;
+      if (max_xlen == 32) {
+        mask = HGATP32_PPN | HGATP32_MODE;
+      } else {
+        mask = HGATP64_PPN & ((reg_t(1) << (MAX_PADDR_BITS - PGSHIFT)) - 1);
+
+        if (get_field(val, HGATP64_MODE) == HGATP_MODE_OFF ||
+            get_field(val, HGATP64_MODE) == HGATP_MODE_SV39X4 ||
+            get_field(val, HGATP64_MODE) == HGATP_MODE_SV48X4)
+          mask |= HGATP64_MODE;
+      }
+      mask &= ~(reg_t)3;
+
+      state.hgatp = val & mask;
+      break;
+    }
+    case CSR_TSELECT:
+      if (val < state.num_triggers) {
+        state.tselect = val;
+      }
+      break;
+    case CSR_TDATA1:
+      {
+        mcontrol_t *mc = &state.mcontrol[state.tselect];
+        if (mc->dmode && !state.debug_mode) {
+          break;
+        }
+        mc->dmode = get_field(val, MCONTROL_DMODE(xlen));
+        mc->select = get_field(val, MCONTROL_SELECT);
+        mc->timing = get_field(val, MCONTROL_TIMING);
+        mc->action = (mcontrol_action_t) get_field(val, MCONTROL_ACTION);
+        mc->chain = get_field(val, MCONTROL_CHAIN);
+        mc->match = (mcontrol_match_t) get_field(val, MCONTROL_MATCH);
+        mc->m = get_field(val, MCONTROL_M);
+        mc->h = get_field(val, MCONTROL_H);
+        mc->s = get_field(val, MCONTROL_S);
+        mc->u = get_field(val, MCONTROL_U);
+        mc->execute = get_field(val, MCONTROL_EXECUTE);
+        mc->store = get_field(val, MCONTROL_STORE);
+        mc->load = get_field(val, MCONTROL_LOAD);
+        // Assume we're here because of csrw.
+        if (mc->execute)
+          mc->timing = 0;
+        trigger_updated();
+      }
+      break;
+    case CSR_TDATA2:
+      if (state.mcontrol[state.tselect].dmode && !state.debug_mode) {
+        break;
+      }
+      if (state.tselect < state.num_triggers) {
+        state.tdata2[state.tselect] = val;
+      }
+      break;
+    case CSR_DCSR:
+      state.dcsr.prv = get_field(val, DCSR_PRV);
+      state.dcsr.step = get_field(val, DCSR_STEP);
+      // TODO: ndreset and fullreset
+      state.dcsr.ebreakm = get_field(val, DCSR_EBREAKM);
+      state.dcsr.ebreakh = get_field(val, DCSR_EBREAKH);
+      state.dcsr.ebreaks = get_field(val, DCSR_EBREAKS);
+      state.dcsr.ebreaku = get_field(val, DCSR_EBREAKU);
+      state.dcsr.halt = get_field(val, DCSR_HALT);
+      break;
+    case CSR_DPC:
+      state.dpc = val & ~(reg_t)1;
+      break;
+    case CSR_DSCRATCH0:
+      state.dscratch0 = val;
+      break;
+    case CSR_DSCRATCH1:
+      state.dscratch1 = val;
+      break;
+    case CSR_VSTART:
+      //dirty_vs_state;
+      VU.vstart = val & (VU.get_vlen() - 1);
+      break;
+    case CSR_VXSAT:
+      //dirty_vs_state;
+      VU.vxsat = val & 0x1ul;
+      break;
+    case CSR_VXRM:
+      //dirty_vs_state;
+      VU.vxrm = val & 0x3ul;
+      break;
+    case CSR_VL:
+      VU.vl = VU.set_vl_api(val, VU.vtype);
+      break;
+    case CSR_VTYPE:
+      VU.set_vl_api(VU.vl, val);
+      break;
+  }
+
+#if defined(RISCV_ENABLE_COMMITLOG)
+  switch (which)
+  {
+    case CSR_FFLAGS:
+      LOG_CSR(CSR_FFLAGS);
+      break;
+    case CSR_FRM:
+      LOG_CSR(CSR_FRM);
+      break;
+    case CSR_FCSR:
+      LOG_CSR(CSR_FFLAGS);
+      LOG_CSR(CSR_FRM);
+      LOG_CSR(CSR_FCSR);
+      break;
+    case CSR_VCSR:
+      LOG_CSR(CSR_VXSAT);
+      LOG_CSR(CSR_VXRM);
+      break;
+
+    case CSR_VSTART:
+      LOG_CSR(CSR_VSTART);
+      break;
+    case CSR_VXSAT:
+      LOG_CSR(CSR_VXSAT);
+      break;
+    case CSR_VXRM:
+      LOG_CSR(CSR_VXRM);
+      break;
+
+    case CSR_MINSTRET:
+    case CSR_MCYCLE:
+    case CSR_MINSTRETH:
+    case CSR_MCYCLEH:
+    case CSR_TSELECT:
+    case CSR_TDATA1:
+    case CSR_TDATA2:
+    case CSR_DCSR:
+    case CSR_DPC:
+    case CSR_DSCRATCH0:
+    case CSR_DSCRATCH1:
+    case CSR_SENTROPY:
+      LOG_CSR(which);
+      break;
+  }
+#endif
+}
+
+// Note that get_csr is sometimes called when read side-effects should not
+// be actioned.  In other words, Spike cannot currently support CSRs with
+// side effects on reads.
+reg_t processor_t::get_csr(int which, insn_t insn, bool write, bool peek)
+{
+#define mcounteren_ok(__which) \
+({ \
+  bool __ctr_ok = true; \
+  if (state.prv < PRV_M) \
+    __ctr_ok = (state.mcounteren->read() >> (__which & 31)) & 1;        \
+  __ctr_ok; \
+})
+#define hcounteren_ok(__which) \
+({ \
+  bool __ctr_ok = true; \
+  if (state.v) \
+    __ctr_ok = (state.hcounteren->read() >> (__which & 31)) & 1;        \
+  __ctr_ok; \
+})
+#define scounteren_ok(__which) \
+({ \
+  bool __ctr_ok = true; \
+  if (extension_enabled('S') && state.prv < PRV_S) \
+    __ctr_ok = (state.scounteren->read() >> (__which & 31)) & 1;        \
+  __ctr_ok; \
+})
+
+  reg_t res = 0;
+  std::string text_name = std::string(csr_name(which));
+#define ret(n) do { \
+    res = (n); \
+    goto out; \
+  } while (false)
+
+  auto search = state.csrmap.find(which);
+  if (search != state.csrmap.end()) {
+    if (!peek)
+      search->second->verify_permissions(insn, write);
+    res = search->second->read();
+
+    // TODO(Noah): Improve this logic when a more general mechanism, i.e. one that could potentially
+    // handle other alias registers, can be devised. Since sstatus is a restricted alias of mstatus,
+    // we need to send the update for the underlying mstatus register.
+    reg_t update_val = res;
+    if (search->second == STATE.sstatus) {
+      text_name = "mstatus";
+      update_val = STATE.mstatus->read();
+    }
+
+    update_generator_register(this->id, text_name.c_str(), update_val, 0xffffffffffffffffull, "read");
+
+    return res;
+  }
+
+  switch (which)
+  {
+    case CSR_SENTROPY:
+      if (!extension_enabled(EXT_ZKR))
+        break;
+      /* Read-only access disallowed due to wipe-on-read side effect */
+      if (!write)
+        break;
+      ret(es.get_sentropy());
+    case CSR_FFLAGS:
+      require_fp;
+      if (!extension_enabled('F'))
+        break;
+      ret(state.fflags);
+    case CSR_FRM:
+      require_fp;
+      if (!extension_enabled('F'))
+        break;
+      ret(state.frm);
+    case CSR_FCSR:
+      require_fp;
+      if (!extension_enabled('F'))
+        break;
+      ret((state.fflags << FSR_AEXC_SHIFT) | (state.frm << FSR_RD_SHIFT));
+    case CSR_VCSR:
+      require_vector_vs;
+      if (!extension_enabled('V'))
+        break;
+      ret((VU.vxsat << VCSR_VXSAT_SHIFT) | (VU.vxrm << VCSR_VXRM_SHIFT));
+    case CSR_INSTRET:
+    case CSR_CYCLE:
+    case CSR_HPMCOUNTER3 ... CSR_HPMCOUNTER31:
+      if (!mcounteren_ok(which))
+          goto throw_illegal;
+      if (!hcounteren_ok(which))
+          goto throw_virtual;
+      if (!scounteren_ok(which)) {
+        if (state.v)
+          goto throw_virtual;
+        else
+          goto throw_illegal;
+      }
+      if (which == CSR_INSTRET || which == CSR_CYCLE)
+        ret(state.minstret);
+      else
+        ret(0);
+    case CSR_MINSTRET:
+    case CSR_MCYCLE:
+    case CSR_MHPMCOUNTER3 ... CSR_MHPMCOUNTER31:
+    case CSR_MHPMEVENT3 ... CSR_MHPMEVENT31:
+      if (which == CSR_MINSTRET || which == CSR_MCYCLE)
+        ret(state.minstret);
+      else
+        ret(0);
+    case CSR_INSTRETH:
+    case CSR_CYCLEH:
+    case CSR_HPMCOUNTER3H ... CSR_HPMCOUNTER31H:
+      if (!mcounteren_ok(which) || xlen != 32)
+          goto throw_illegal;
+      if (!hcounteren_ok(which))
+          goto throw_virtual;
+      if (!scounteren_ok(which)) {
+        if (state.v)
+          goto throw_virtual;
+        else
+          goto throw_illegal;
+      }
+      if (which == CSR_INSTRETH || which == CSR_CYCLEH)
+        ret(state.minstret >> 32);
+      else
+        ret(0);
+    case CSR_MINSTRETH:
+    case CSR_MCYCLEH:
+    case CSR_MHPMCOUNTER3H ... CSR_MHPMCOUNTER31H:
+      if (xlen == 32) {
+        if (which == CSR_MINSTRETH || which == CSR_MCYCLEH)
+          ret(state.minstret >> 32);
+        else
+          ret(0);
+      }
+      break;
+    case CSR_MCOUNTINHIBIT: ret(0);
+    case CSR_MSTATUSH:
+      if (xlen == 32)
+        ret((state.mstatus->read() >> 32) & (MSTATUSH_SBE | MSTATUSH_MBE));
+      break;
+    case CSR_MTVAL2:
+      if (extension_enabled('H'))
+        ret(state.mtval2);
+      break;
+    case CSR_MTINST:
+      if (extension_enabled('H'))
+        ret(state.mtinst);
+      break;
+    case CSR_MARCHID: ret(5);
+    case CSR_MIMPID: ret(0);
+    case CSR_MVENDORID: ret(0);
     case CSR_MHARTID: ret(id);
     case CSR_HEDELEG: ret(state.hedeleg);
     case CSR_HIDELEG: ret(state.hideleg);
@@ -1410,9 +1734,245 @@ out:
     goto throw_illegal;
   }
 
+  update_generator_register(this->id, text_name.c_str(), res, 0xffffffffffffffffull, "read");
+
+  return res;
+}
+
+reg_t processor_t::get_csr_api(int which)
+{
+#define mcounteren_ok(__which) \
+({ \
+  bool __ctr_ok = true; \
+  if (state.prv < PRV_M) \
+    __ctr_ok = (state.mcounteren->read() >> (__which & 31)) & 1;        \
+  __ctr_ok; \
+})
+#define hcounteren_ok(__which) \
+({ \
+  bool __ctr_ok = true; \
+  if (state.v) \
+    __ctr_ok = (state.hcounteren->read() >> (__which & 31)) & 1;        \
+  __ctr_ok; \
+})
+#define scounteren_ok(__which) \
+({ \
+  bool __ctr_ok = true; \
+  if (extension_enabled('S') && state.prv < PRV_S) \
+    __ctr_ok = (state.scounteren->read() >> (__which & 31)) & 1;        \
+  __ctr_ok; \
+})
+
+  reg_t res = 0;
+#define ret(n) do { \
+    res = (n); \
+    goto out; \
+  } while (false)
+
+  auto search = state.csrmap.find(which);
+  if (search != state.csrmap.end()) {
+    return search->second->read();
+  }
+
+  switch (which)
+  {
+    case CSR_SENTROPY:
+      // TODO(Noah): Determine what must be done here to allow reading sentropy without side effects
+      // before support for Zkr is enabled. A comment in the Spike code indicates the register is
+      // modified when reading it.
+      if (!extension_enabled(EXT_ZKR))
+        break;
+      ret(es.get_sentropy());
+    case CSR_FFLAGS:
+      ret(state.fflags);
+    case CSR_FRM:
+      ret(state.frm);
+    case CSR_FCSR:
+      ret((state.fflags << FSR_AEXC_SHIFT) | (state.frm << FSR_RD_SHIFT));
+    case CSR_VCSR:
+      ret((VU.vxsat << VCSR_VXSAT_SHIFT) | (VU.vxrm << VCSR_VXRM_SHIFT));
+    case CSR_INSTRET:
+    case CSR_CYCLE:
+    case CSR_HPMCOUNTER3 ... CSR_HPMCOUNTER31:
+      if (which == CSR_INSTRET || which == CSR_CYCLE)
+        ret(state.minstret);
+      else
+        ret(0);
+    case CSR_MINSTRET:
+    case CSR_MCYCLE:
+    case CSR_MHPMCOUNTER3 ... CSR_MHPMCOUNTER31:
+    case CSR_MHPMEVENT3 ... CSR_MHPMEVENT31:
+      if (which == CSR_MINSTRET || which == CSR_MCYCLE)
+        ret(state.minstret);
+      else
+        ret(0);
+    case CSR_INSTRETH:
+    case CSR_CYCLEH:
+    case CSR_HPMCOUNTER3H ... CSR_HPMCOUNTER31H:
+      if (which == CSR_INSTRETH || which == CSR_CYCLEH)
+        ret(state.minstret >> 32);
+      else
+        ret(0);
+    case CSR_MINSTRETH:
+    case CSR_MCYCLEH:
+    case CSR_MHPMCOUNTER3H ... CSR_MHPMCOUNTER31H:
+      if (which == CSR_MINSTRETH || which == CSR_MCYCLEH)
+        ret(state.minstret >> 32);
+      else
+        ret(0);
+    case CSR_MCOUNTINHIBIT: ret(0);
+    case CSR_MSTATUSH:
+      ret((state.mstatus->read() >> 32) & (MSTATUSH_SBE | MSTATUSH_MBE));
+    case CSR_MTVAL2:
+      ret(state.mtval2);
+    case CSR_MTINST:
+      ret(state.mtinst);
+    case CSR_MARCHID: ret(5);
+    case CSR_MIMPID: ret(0);
+    case CSR_MVENDORID: ret(0);
+    case CSR_MHARTID: ret(id);
+    case CSR_HEDELEG: ret(state.hedeleg);
+    case CSR_HIDELEG: ret(state.hideleg);
+    case CSR_HGEIE: ret(0);
+    case CSR_HTVAL: ret(state.htval);
+    case CSR_HTINST: ret(state.htinst);
+    case CSR_HGATP: {
+      ret(state.hgatp);
+    }
+    case CSR_HGEIP: ret(0);
+    case CSR_TSELECT: ret(state.tselect);
+    case CSR_TDATA1:
+      if (state.tselect < state.num_triggers) {
+        reg_t v = 0;
+        mcontrol_t *mc = &state.mcontrol[state.tselect];
+        v = set_field(v, MCONTROL_TYPE(xlen), mc->type);
+        v = set_field(v, MCONTROL_DMODE(xlen), mc->dmode);
+        v = set_field(v, MCONTROL_MASKMAX(xlen), mc->maskmax);
+        v = set_field(v, MCONTROL_SELECT, mc->select);
+        v = set_field(v, MCONTROL_TIMING, mc->timing);
+        v = set_field(v, MCONTROL_ACTION, mc->action);
+        v = set_field(v, MCONTROL_CHAIN, mc->chain);
+        v = set_field(v, MCONTROL_MATCH, mc->match);
+        v = set_field(v, MCONTROL_M, mc->m);
+        v = set_field(v, MCONTROL_H, mc->h);
+        v = set_field(v, MCONTROL_S, mc->s);
+        v = set_field(v, MCONTROL_U, mc->u);
+        v = set_field(v, MCONTROL_EXECUTE, mc->execute);
+        v = set_field(v, MCONTROL_STORE, mc->store);
+        v = set_field(v, MCONTROL_LOAD, mc->load);
+        ret(v);
+      } else {
+        ret(0);
+      }
+      break;
+    case CSR_TDATA2:
+      if (state.tselect < state.num_triggers) {
+        ret(state.tdata2[state.tselect]);
+      } else {
+        ret(0);
+      }
+      break;
+    case CSR_TDATA3: ret(0);
+    case CSR_DCSR:
+      {
+        uint32_t v = 0;
+        v = set_field(v, DCSR_XDEBUGVER, 1);
+        v = set_field(v, DCSR_EBREAKM, state.dcsr.ebreakm);
+        v = set_field(v, DCSR_EBREAKH, state.dcsr.ebreakh);
+        v = set_field(v, DCSR_EBREAKS, state.dcsr.ebreaks);
+        v = set_field(v, DCSR_EBREAKU, state.dcsr.ebreaku);
+        v = set_field(v, DCSR_STOPCYCLE, 0);
+        v = set_field(v, DCSR_STOPTIME, 0);
+        v = set_field(v, DCSR_CAUSE, state.dcsr.cause);
+        v = set_field(v, DCSR_STEP, state.dcsr.step);
+        v = set_field(v, DCSR_PRV, state.dcsr.prv);
+        ret(v);
+      }
+    case CSR_DPC:
+      ret(state.dpc & pc_alignment_mask());
+    case CSR_DSCRATCH0:
+      ret(state.dscratch0);
+    case CSR_DSCRATCH1:
+      ret(state.dscratch1);
+    case CSR_VSTART:
+      ret(VU.vstart);
+    case CSR_VXSAT:
+      ret(VU.vxsat);
+    case CSR_VXRM:
+      ret(VU.vxrm);
+    case CSR_VL:
+      ret(VU.vl);
+    case CSR_VTYPE:
+      ret(VU.vtype);
+    case CSR_VLENB:
+      ret(VU.vlenb);
+  }
+
+#undef ret
+
+  // If we get here, the CSR doesn't exist.
+  return 0xDEADBEEFDEADBEEF;
+
+out:
   return res;
 }
 
+bool processor_t::set_pc_api(const std::string& name, const uint8_t* bytes, size_t len) //len advertises the size of the buffer
+{
+    if(bytes == nullptr)
+    {
+        return false;
+    }
+
+    if(name == std::string("PC") || name == std::string("pc"))
+    {
+        if(len != sizeof(state.pc))
+        {
+            return false;    
+        }
+        else
+        {
+            memcpy(&(state.pc), bytes, len);
+            return true;
+        }
+    }
+    else
+    {
+        return false;        
+    }
+}
+
+bool processor_t::retrieve_pc_api(uint8_t* bytes, const std::string& name, size_t len) //len advertises the size of the buffer
+{
+
+    if(bytes == nullptr)
+    {
+        return false;
+    }
+
+    if(name == std::string("PC") || name == std::string("pc"))
+    {
+        if(len != sizeof(state.pc))
+        {
+            return false;    
+        }
+        else
+        {
+            memcpy(bytes, &(state.pc), len);
+            return true;
+        }
+    }
+    else
+    {
+        return false;        
+    }
+}
+
+void processor_t::retrieve_privilege_api(reg_t* val)
+{
+  *val = state.prv;
+}
+
 reg_t illegal_instruction(processor_t* p, insn_t insn, reg_t pc)
 {
   throw trap_illegal_instruction(insn.bits());
@@ -1516,6 +2076,7 @@ bool processor_t::load(reg_t addr, size_t len, uint8_t* bytes)
       if (len <= 4) {
         memset(bytes, 0, len);
         bytes[0] = get_field(state.mip->read(), MIP_MSIP);
+        update_generator_register(this->id, "mip", state.mip->read(), 0xffffffffffffffff, "read");
         return true;
       }
       break;
@@ -1531,6 +2092,7 @@ bool processor_t::store(reg_t addr, size_t len, const uint8_t* bytes)
     case 0:
       if (len <= 4) {
         state.mip->write_with_mask(MIP_MSIP, bytes[0] << IRQ_M_SOFT);
+        update_generator_register(this->id, "mip", state.mip->read(), 0xffffffffffffffff, "write");
         return true;
       }
       break;
diff --git a/riscv/processor.h b/riscv/processor.h
index 3a240f8d..d0342b81 100644
--- a/riscv/processor.h
+++ b/riscv/processor.h
@@ -1,4 +1,5 @@
 // See LICENSE for license details.
+
 #ifndef _RISCV_PROCESSOR_H
 #define _RISCV_PROCESSOR_H
 
@@ -14,6 +15,8 @@
 #include "debug_rom_defines.h"
 #include "entropy_source.h"
 #include "csrs.h"
+#include <iostream>
+
 
 class processor_t;
 class mmu_t;
@@ -153,7 +156,7 @@ struct type_sew_t<64>
 // architectural state of a RISC-V hart
 struct state_t
 {
-  void reset(processor_t* const proc, reg_t max_isa);
+  void reset(processor_t* const proc, reg_t max_isa, uint32_t id);
 
   static const int num_triggers = 4;
 
@@ -232,6 +235,11 @@ struct state_t
   int last_inst_xlen;
   int last_inst_flen;
 #endif
+
+  size_t pid;
+
+  state_t(size_t id): XPR(id), FPR(id), pid(id) {};
+  state_t(): XPR(0), FPR(0), pid(0) {};
 };
 
 typedef enum {
@@ -285,9 +293,14 @@ class processor_t : public abstract_device_t
 public:
   processor_t(const char* isa, const char* priv, const char* varch,
               simif_t* sim, uint32_t id, bool halt_on_reset,
-              FILE *log_file, std::ostream& sout_); // because of command line option --log and -s we need both
+              std::ostream& sout_); // because of command line option --log and -s we need both
   ~processor_t();
 
+  bool set_pc_api(const std::string& name, const uint8_t* bytes, size_t len); //len advertises the size of the buffer
+  bool retrieve_pc_api(uint8_t* bytes, const std::string& name, size_t len); //len advertises the size of the buffer
+
+  void retrieve_privilege_api(reg_t* prv);
+
   void set_debug(bool value);
   void set_histogram(bool value);
 #ifdef RISCV_ENABLE_COMMITLOG
@@ -297,9 +310,11 @@ public:
   void reset();
   void step(size_t n); // run for n cycles
   void set_csr(int which, reg_t val);
+  void set_csr_api(int which, reg_t val);
   uint32_t get_id() const { return id; }
   reg_t get_csr(int which, insn_t insn, bool write, bool peek = 0);
   reg_t get_csr(int which) { return get_csr(which, insn_t(0), false, true); }
+  reg_t get_csr_api(int which);
   mmu_t* get_mmu() { return mmu; }
   state_t* get_state() { return &state; }
   unsigned get_xlen() { return xlen; }
@@ -349,6 +364,7 @@ public:
   }
   reg_t legalize_privilege(reg_t);
   void set_privilege(reg_t);
+  void set_privilege_api(reg_t prv);
   void set_virt(bool);
   void update_histogram(reg_t pc);
   const disassembler_t* get_disassembler() { return disassembler; }
@@ -531,7 +547,10 @@ public:
       bool vill;
       bool vstart_alu;
 
-      // vector element for varies SEW
+      template<class T>
+      void do_callback(reg_t vecRegIndex, reg_t eltIndex, const char pAccessType[]) const; 
+  
+      // vector element for varing SEW
       template<class T>
         T& elt(reg_t vReg, reg_t n, bool is_write = false){
           assert(vsew != 0);
@@ -539,21 +558,32 @@ public:
           reg_t elts_per_reg = (VLEN >> 3) / (sizeof(T));
           vReg += n / elts_per_reg;
           n = n % elts_per_reg;
+          reg_referenced[vReg] = 1;
+  
 #ifdef WORDS_BIGENDIAN
           // "V" spec 0.7.1 requires lower indices to map to lower significant
           // bits when changing SEW, thus we need to index from the end on BE.
           n ^= elts_per_reg - 1;
 #endif
-          reg_referenced[vReg] = 1;
-
-#ifdef RISCV_ENABLE_COMMITLOG
-          if (is_write)
-            p->get_state()->log_reg_write[((vReg) << 4) | 2] = {0, 0};
-#endif
 
           T *regStart = (T*)((char*)reg_file + vReg * (VLEN >> 3));
           return regStart[n];
         }
+  
+      template<class T>
+        T elt_val(reg_t vecReg, reg_t n, bool is_write = false){
+          T reg_val = elt<T>(vecReg, n, is_write);
+          do_callback<T>(vecReg, n, "read"); 
+          return reg_val;
+        }
+  
+       template<class T>
+        T& elt_ref(reg_t vecReg, reg_t n, bool is_write = false){
+          T& r_reg_ref = elt<T>(vecReg, n, is_write);
+          do_callback<T>(vecReg, n, "write"); 
+          return r_reg_ref;
+        }
+
     public:
 
       void reset();
@@ -568,6 +598,7 @@ public:
       }
 
       reg_t set_vl(int rd, int rs1, reg_t reqVL, reg_t newType);
+      reg_t set_vl_api(reg_t reqVL, reg_t newType);
 
       reg_t get_vlen() { return VLEN; }
       reg_t get_elen() { return ELEN; }
@@ -581,6 +612,44 @@ public:
   vectorUnit_t VU;
 };
 
+extern "C"{
+  // update_vector_element function: for the given cpuid, this callback function is called by the simulator to notify the user that a vector register element has been read or written
+  //
+  //  inputs:
+  //      uint32_t cpuid -- refers to the processor ID
+  //      const char* pRegName -- the base name of the vector register does NOT include a suffix for physical register since this is a FORCE / hardware specific notion.
+  //      uint32_t vecRegIndex -- the numerical index that goes with the vector register base name
+  //      uint32_t eltIndex -- the numerical index of the element that is updated
+  //      uint32_t eltByteWidth -- the number of bytes per element at the time of the update, used in FORCE with the eltIndex to dynamically associate physical registers for aggregated updates
+  //      const uint8_t* value -- the contents of the ENTIRE vector register if this update is a "read" or *nothing* if this is a "write". 
+  //      uint32_t byteLength -- should match the size of the ENTIRE vector register.
+  //      const char* pAccessType -- should be "read" or "write".
+  //
+  void update_vector_element(uint32_t cpuid, const char *pRegName, uint32_t vecRegIndex, uint32_t eltIndex, uint32_t eltByteWidth, const uint8_t* pValue, uint32_t  byteLength, const char* pAccessType);
+}
+
+extern const char* vr_name[];
+
+template<class T>
+void processor_t::vectorUnit_t::do_callback(reg_t vecRegIndex, reg_t eltIndex, const char pAccessType[]) const  
+{
+  reg_t elts_per_reg = (VLEN >> 3) / (sizeof(T));
+  reg_t corrected_vreg_index = vecRegIndex + eltIndex / elts_per_reg;
+  if(corrected_vreg_index > vecRegIndex)
+  {
+    eltIndex %= elts_per_reg;  	
+  }
+
+  #ifdef WORDS_BIGENDIAN
+  // "V" spec 0.7.1 requires lower indices to map to lower significant
+  // bits when changing SEW, thus we need to index from the end on BE.
+  eltIndex ^= elts_per_reg - 1;
+  #endif
+
+  uint8_t *p_reg_start = (uint8_t*)((char*)reg_file + corrected_vreg_index * (VLEN >> 3));
+  update_vector_element(p->get_state()->pid, vr_name[corrected_vreg_index], corrected_vreg_index, eltIndex, sizeof(T), p_reg_start, (VLEN >> 3), pAccessType);
+}
+
 reg_t illegal_instruction(processor_t* p, insn_t insn, reg_t pc);
 
 #define REGISTER_INSN(proc, name, match, mask, archen) \
diff --git a/riscv/sim.cc b/riscv/sim.cc
index 1ec6a9f7..a4ae21a9 100644
--- a/riscv/sim.cc
+++ b/riscv/sim.cc
@@ -2,13 +2,10 @@
 
 #include "sim.h"
 #include "mmu.h"
-#include "dts.h"
-#include "remote_bitbang.h"
 #include "byteorder.h"
 #include "platform.h"
 #include <fstream>
 #include <map>
-#include <iostream>
 #include <sstream>
 #include <climits>
 #include <cstdlib>
@@ -17,6 +14,30 @@
 #include <unistd.h>
 #include <sys/wait.h>
 #include <sys/types.h>
+#include "disasm.h"
+
+// for elf loading
+#include "elf.h"
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+// for address translation
+#include "memtracer.h"
+
+//DEBUG
+extern "C" {
+// update_generator_register function: for the given cpuid, this callback function is called by the simulator to notify the user that a register has been accessed.
+//
+//  inputs:
+//      uint32_t cpuid -- refers to the processor ID
+//      const char* registerName -- the name of the reigster (programmer's name)
+//      uint64_t value -- the data stored in the register after update
+//      uint64_t mask -- 1's indicate relevant bits
+//      const char* accessType -- indicates if the access was a read or write.
+//
+void update_generator_register(uint32_t cpuid, const char* registerName, uint64_t value, uint64_t mask, const char* accessType);  //!< update generator register information when step an instruction
+}
 
 volatile bool ctrlc_pressed = false;
 static void handle_signal(int sig)
@@ -27,57 +48,25 @@ static void handle_signal(int sig)
   signal(sig, &handle_signal);
 }
 
-sim_t::sim_t(const char* isa, const char* priv, const char* varch,
-             size_t nprocs, bool halted, bool real_time_clint,
-             reg_t initrd_start, reg_t initrd_end, const char* bootargs,
-             reg_t start_pc, std::vector<std::pair<reg_t, mem_t*>> mems,
-             std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices,
-             const std::vector<std::string>& args,
-             std::vector<int> const hartids,
-             const debug_module_config_t &dm_config,
-             const char *log_path,
-             bool dtb_enabled, const char *dtb_file,
-#ifdef HAVE_BOOST_ASIO
-             boost::asio::io_service *io_service_ptr, boost::asio::ip::tcp::acceptor *acceptor_ptr, // option -s
-#endif
+simlib_t::simlib_t(const char* isa, const char* priv, const char* varch, size_t nprocs, bool halted, const char* bootargs, reg_t start_pc, std::vector<int> const hartids, bool auto_init_mem,
              FILE *cmd_file) // needed for command line option --cmd
-  : htif_t(args),
-    mems(mems),
-    plugin_devices(plugin_devices),
-    procs(std::max(nprocs, size_t(1))),
-    initrd_start(initrd_start),
-    initrd_end(initrd_end),
+  : procs(std::max(nprocs, size_t(1))),
     bootargs(bootargs),
     start_pc(start_pc),
-    dtb_file(dtb_file ? dtb_file : ""),
-    dtb_enabled(dtb_enabled),
-    log_file(log_path),
     cmd_file(cmd_file),
-#ifdef HAVE_BOOST_ASIO
-    io_service_ptr(io_service_ptr), // socket interface
-    acceptor_ptr(acceptor_ptr),
-#endif
     sout_(nullptr),
     current_step(0),
     current_proc(0),
     debug(false),
     histogram_enabled(false),
-    log(false),
-    remote_bitbang(NULL),
-    debug_module(this, dm_config)
+    dtb_enabled(true),
+    _ForceSparseMemoryModel(Force::EMemBankType::Default, auto_init_mem),
+    entry(DRAM_BASE)
 {
   signal(SIGINT, &handle_signal);
 
   sout_.rdbuf(std::cerr.rdbuf()); // debug output goes to stderr by default
 
-  for (auto& x : mems)
-    bus.add_device(x.first, x.second);
-
-  for (auto& x : plugin_devices)
-    bus.add_device(x.first, x.second);
-
-  debug_module.add_device(&bus);
-
   debug_mmu = new mmu_t(this, NULL);
 
   if (! (hartids.empty() || hartids.size() == nprocs)) {
@@ -90,143 +79,156 @@ sim_t::sim_t(const char* isa, const char* priv, const char* varch,
 
   for (size_t i = 0; i < nprocs; i++) {
     int hart_id = hartids.empty() ? i : hartids[i];
-    procs[i] = new processor_t(isa, priv, varch, this, hart_id, halted,
-                               log_file.get(), sout_);
-  }
-
-  make_dtb();
-
-  void *fdt = (void *)dtb.c_str();
-  //handle clic
-  clint.reset(new clint_t(procs, CPU_HZ / INSNS_PER_RTC_TICK, real_time_clint));
-  reg_t clint_base;
-  if (fdt_parse_clint(fdt, &clint_base, "riscv,clint0")) {
-    bus.add_device(CLINT_BASE, clint.get());
-  } else {
-    bus.add_device(clint_base, clint.get());
+    procs[i] = new processor_t(isa, priv, varch, this, hart_id, halted, sout_);
   }
 
+  // these inputs will have to be hard coded until dtb and fdt are added as dependencies.
   //per core attribute
-  int cpu_offset = 0, rc;
-  size_t cpu_idx = 0;
-  cpu_offset = fdt_get_offset(fdt, "/cpus");
-  if (cpu_offset < 0)
-    return;
+  //int cpu_offset = 0, rc;
+  //size_t cpu_idx = 0;
+  //cpu_offset = fdt_get_offset(fdt, "/cpus");
+  //if (cpu_offset < 0)
+  //  return;
 
-  for (cpu_offset = fdt_get_first_subnode(fdt, cpu_offset); cpu_offset >= 0;
-       cpu_offset = fdt_get_next_subnode(fdt, cpu_offset)) {
+  //for (cpu_offset = fdt_get_first_subnode(fdt, cpu_offset); cpu_offset >= 0;
+  //     cpu_offset = fdt_get_next_subnode(fdt, cpu_offset)) {
 
-    if (cpu_idx >= nprocs)
-      break;
+  //  if (cpu_idx >= nprocs)
+  //    break;
 
     //handle pmp
-    reg_t pmp_num = 0, pmp_granularity = 0;
-    if (fdt_parse_pmp_num(fdt, cpu_offset, &pmp_num) == 0) {
-      procs[cpu_idx]->set_pmp_num(pmp_num);
-    }
+  //  reg_t pmp_num = 0, pmp_granularity = 0;
+  //  if (fdt_parse_pmp_num(fdt, cpu_offset, &pmp_num) == 0) {
+  //    procs[cpu_idx]->set_pmp_num(pmp_num);
+  //  }
 
-    if (fdt_parse_pmp_alignment(fdt, cpu_offset, &pmp_granularity) == 0) {
-      procs[cpu_idx]->set_pmp_granularity(pmp_granularity);
-    }
+  //  if (fdt_parse_pmp_alignment(fdt, cpu_offset, &pmp_granularity) == 0) {
+  //    procs[cpu_idx]->set_pmp_granularity(pmp_granularity);
+  //  }
 
     //handle mmu-type
-    char mmu_type[256] = "";
-    rc = fdt_parse_mmu_type(fdt, cpu_offset, mmu_type);
-    if (rc == 0) {
-      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SBARE);
-      if (strncmp(mmu_type, "riscv,sv32", strlen("riscv,sv32")) == 0) {
-        procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV32);
-      } else if (strncmp(mmu_type, "riscv,sv39", strlen("riscv,sv39")) == 0) {
-        procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV39);
-      } else if (strncmp(mmu_type, "riscv,sv48", strlen("riscv,sv48")) == 0) {
-        procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV48);
-      } else if (strncmp(mmu_type, "riscv,sbare", strlen("riscv,sbare")) == 0) {
+  //  char mmu_type[256] = "";
+  //  rc = fdt_parse_mmu_type(fdt, cpu_offset, mmu_type);
+  //  if (rc == 0) {
+  //    procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SBARE);
+  //    if (strncmp(mmu_type, "riscv,sv32", strlen("riscv,sv32")) == 0) {
+  //      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV32);
+  //    } else if (strncmp(mmu_type, "riscv,sv39", strlen("riscv,sv39")) == 0) {
+  //      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV39);
+  //    } else if (strncmp(mmu_type, "riscv,sv48", strlen("riscv,sv48")) == 0) {
+  //      procs[cpu_idx]->set_mmu_capability(IMPL_MMU_SV48);
+  //    } else if (strncmp(mmu_type, "riscv,sbare", strlen("riscv,sbare")) == 0) {
         //has been set in the beginning
-      } else {
-        std::cerr << "core ("
-                  << hartids.size()
-                  << ") doesn't have valid 'mmu-type'"
-                  << mmu_type << ").\n";
-        exit(1);
-      }
-    }
+  //    } else {
+  //      std::cerr << "core ("
+  //                << hartids.size()
+  //                << ") doesn't have valid 'mmu-type'"
+  //                << mmu_type << ").\n";
+  //      exit(1);
+  //    }
+  //  }
 
-    cpu_idx++;
-  }
+  //  cpu_idx++;
+  //}
 
-  if (cpu_idx != nprocs) {
-      std::cerr << "core number in dts ("
-                <<  cpu_idx
-                << ") doesn't match it in command line ("
-                << nprocs << ").\n";
-      exit(1);
-  }
+  //if (cpu_idx != nprocs) {
+  //    std::cerr << "core number in dts ("
+  //              <<  cpu_idx
+  //              << ") doesn't match it in command line ("
+  //              << nprocs << ").\n";
+  //    exit(1);
+  //}
 }
 
-sim_t::~sim_t()
+simlib_t::~simlib_t()
 {
   for (size_t i = 0; i < procs.size(); i++)
     delete procs[i];
   delete debug_mmu;
 }
 
-void sim_thread_main(void* arg)
-{
-  ((sim_t*)arg)->main();
-}
-
-void sim_t::main()
+int simlib_t::step_simulator(int target_id, int num_steps, int stx_failed)
 {
-  if (!debug && log)
-    set_procs_debug(true);
+  processor_t* proc_ptr = get_core(target_id);
+  if (proc_ptr == nullptr)
+    return 1;
+  proc_ptr->step(num_steps);
+  const char pc_name[] = "PC\0";
+  const uint64_t pc_mask = 0xFFFFFFFFFFFFFFFF;
+  uint64_t pc_value = 0x0;
+  const char pc_update_access_type[] = "write\0";
+  get_pc_api(target_id, reinterpret_cast<uint8_t*>(&pc_value), pc_name, sizeof(uint64_t));
+  update_generator_register(target_id, pc_name, pc_value, pc_mask, pc_update_access_type);
 
-  while (!done())
-  {
-    if (debug || ctrlc_pressed)
-      interactive();
-    else
-      step(INTERLEAVE);
-    if (remote_bitbang) {
-      remote_bitbang->tick();
-    }
-  }
+  return 0;
 }
 
-int sim_t::run()
+void simlib_t::set_debug(bool value)
 {
-  host = context_t::current();
-  target.init(sim_thread_main, this);
-  return htif_t::run();
+  debug = value;
 }
 
-void sim_t::step(size_t n)
+int simlib_t::get_disassembly(int target_id, const uint64_t* pc, char** opcode, char** disassembly)
 {
-  for (size_t i = 0, steps = 0; i < n; i += steps)
-  {
-    steps = std::min(n - i, INTERLEAVE - current_step);
-    procs[current_proc]->step(steps);
+  std::string opcode_temp;
+  std::string disassembly_temp;
+  uint64_t opcode_num = 0ull;
 
-    current_step += steps;
-    if (current_step == INTERLEAVE)
-    {
-      current_step = 0;
-      procs[current_proc]->get_mmu()->yield_load_reservation();
-      if (++current_proc == procs.size()) {
-        current_proc = 0;
-        clint->increment(INTERLEAVE / INSNS_PER_RTC_TICK);
-      }
+  if(procs.size() > 0)
+  {
+    processor_t* proc_ptr = get_core(target_id);
+    if (proc_ptr == nullptr)
+      return 1;
+    try {
+      const disassembler_t* disassembler = proc_ptr->get_disassembler(); // should be OK to get processor's disassembler, using it should be idempotent
 
-      host->switch_to();
+      // currently this fails a check in the Spike code if the pc isn't found so the code does not have the opportunity to return 1.
+      insn_fetch_t fetched = proc_ptr->get_mmu()->load_insn(*pc);
+      opcode_num = fetched.insn.bits() & ((1ull << (8 * insn_length(fetched.insn.bits()))) - 1); //This is the conversion the processor_t::disasm(...) uses to format the opcode for output.
+      disassembly_temp = disassembler->disassemble(fetched.insn);
+      // format the string interpretation of the opcode as a hex number.
+      std::stringstream stream;
+      stream << "0x" << std::hex << opcode_num;
+      opcode_temp = stream.str();
+    } catch(...) {
+      strcpy(*opcode,"00000000");
+      strcpy(*disassembly,"?");
+      return 1; // there may not be an instruction at the PC (example: page fault on branch)
     }
   }
+  else
+  {
+    return 2; // No processors, therefore no configured disassembler for us to use
+  }
+
+  // At this point disassembly proceeded correctly. Now check the output buffers
+  if(opcode == nullptr || disassembly == nullptr)
+  {
+    return 2;
+  }
+  size_t opcode_buffer_length = opcode != nullptr ? strlen(*opcode) : 0;
+  size_t disassembly_buffer_length = disassembly != nullptr ? strlen(*disassembly) : 0;
+  if((opcode_buffer_length < (opcode_temp.size()+1)) || (disassembly_buffer_length < (disassembly_temp.size()+1))) // check for enough size to place the null termination character
+  {
+    return 2; // The user didn't give us room to put the answers
+  }
+
+  // Warning: the 'insn't' null and string length tests above can fail to uncover a corner case of bad input, where a pointer to a string literal is aliased by a char* pointer.
+  // The compiler will accept this, but it will fail when you try to copy as in below, basically be sure your string buffer was correctly allocated.
+  opcode_temp.copy(*opcode, opcode_temp.size(), 0);
+  (*opcode)[opcode_temp.size()]='\0'; // No idea how the user is initializing these strings, so just null terminate the relevant part.
+  disassembly_temp.copy(*disassembly, disassembly_temp.size(), 0);
+  (*disassembly)[disassembly_temp.size()]='\0';
+
+  return 0;
 }
 
-void sim_t::set_debug(bool value)
+void simlib_t::set_log(bool value)
 {
-  debug = value;
+  log = value;
 }
 
-void sim_t::set_histogram(bool value)
+void simlib_t::set_histogram(bool value)
 {
   histogram_enabled = value;
   for (size_t i = 0; i < procs.size(); i++) {
@@ -234,81 +236,115 @@ void sim_t::set_histogram(bool value)
   }
 }
 
-void sim_t::configure_log(bool enable_log, bool enable_commitlog)
-{
-  log = enable_log;
-
-  if (!enable_commitlog)
-    return;
-
-#ifndef RISCV_ENABLE_COMMITLOG
-  fputs("Commit logging support has not been properly enabled; "
-        "please re-build the riscv-isa-sim project using "
-        "\"configure --enable-commitlog\".\n",
-        stderr);
-  abort();
-#else
-  for (processor_t *proc : procs) {
-    proc->enable_log_commits();
-  }
-#endif
-}
-
-void sim_t::set_procs_debug(bool value)
+void simlib_t::set_procs_debug(bool value)
 {
   for (size_t i=0; i< procs.size(); i++)
     procs[i]->set_debug(value);
 }
 
-static bool paddr_ok(reg_t addr)
+std::map<std::string, uint64_t> simlib_t::load_elf(const char* fn, reg_t* entry)
 {
-  return (addr >> MAX_PADDR_BITS) == 0;
-}
+  int fd = open(fn, O_RDONLY);
+  struct stat s;
+  assert(fd != -1);
+  if (fstat(fd, &s) < 0)
+    abort();
+  size_t size = s.st_size;
 
-bool sim_t::mmio_load(reg_t addr, size_t len, uint8_t* bytes)
-{
-  if (addr + len < addr || !paddr_ok(addr + len - 1))
-    return false;
-  return bus.load(addr, len, bytes);
-}
+  char* buf = (char*)mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+  assert(buf != MAP_FAILED);
+  close(fd);
 
-bool sim_t::mmio_store(reg_t addr, size_t len, const uint8_t* bytes)
-{
-  if (addr + len < addr || !paddr_ok(addr + len - 1))
-    return false;
-  return bus.store(addr, len, bytes);
-}
+  assert(size >= sizeof(Elf64_Ehdr));
+  const Elf64_Ehdr* eh64 = (const Elf64_Ehdr*)buf;
+  assert(IS_ELF32(*eh64) || IS_ELF64(*eh64));
 
-void sim_t::make_dtb()
-{
-  if (!dtb_file.empty()) {
-    std::ifstream fin(dtb_file.c_str(), std::ios::binary);
-    if (!fin.good()) {
-      std::cerr << "can't find dtb file: " << dtb_file << std::endl;
-      exit(-1);
-    }
+  std::vector<uint8_t> zeros;
+  std::vector<uint8_t> attrs;
+  std::map<std::string, uint64_t> symbols;
 
-    std::stringstream strstream;
-    strstream << fin.rdbuf();
+  #define LOAD_ELF(ehdr_t, phdr_t, shdr_t, sym_t) do { \
+    ehdr_t* eh = (ehdr_t*)buf; \
+    phdr_t* ph = (phdr_t*)(buf + eh->e_phoff); \
+    *entry = eh->e_entry; \
+    assert(size >= eh->e_phoff + eh->e_phnum*sizeof(*ph)); \
+    for (unsigned i = 0; i < eh->e_phnum; i++) { \
+      if(ph[i].p_type == PT_LOAD && ph[i].p_memsz) { \
+        if (ph[i].p_filesz) { \
+          assert(size >= ph[i].p_offset + ph[i].p_filesz); \
+          attrs.resize(ph[i].p_filesz); \
+          std::fill(attrs.begin(), attrs.end(), 0); \
+          initialize_multiword(ph[i].p_paddr, ph[i].p_filesz, (uint8_t*)buf + ph[i].p_offset); \
+        } \
+        zeros.resize(ph[i].p_memsz - ph[i].p_filesz); \
+        initialize_multiword(ph[i].p_paddr + ph[i].p_filesz, ph[i].p_memsz - ph[i].p_filesz, &zeros[0]); \
+      } \
+    } \
+    shdr_t* sh = (shdr_t*)(buf + eh->e_shoff); \
+    assert(size >= eh->e_shoff + eh->e_shnum*sizeof(*sh)); \
+    assert(eh->e_shstrndx < eh->e_shnum); \
+    assert(size >= sh[eh->e_shstrndx].sh_offset + sh[eh->e_shstrndx].sh_size); \
+    char *shstrtab = buf + sh[eh->e_shstrndx].sh_offset; \
+    unsigned strtabidx = 0, symtabidx = 0; \
+    for (unsigned i = 0; i < eh->e_shnum; i++) { \
+      unsigned max_len = sh[eh->e_shstrndx].sh_size - sh[i].sh_name; \
+      assert(sh[i].sh_name < sh[eh->e_shstrndx].sh_size); \
+      assert(strnlen(shstrtab + sh[i].sh_name, max_len) < max_len); \
+      if (sh[i].sh_type & SHT_NOBITS) continue; \
+      assert(size >= sh[i].sh_offset + sh[i].sh_size); \
+      if (strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) \
+        strtabidx = i; \
+      if (strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) \
+        symtabidx = i; \
+    } \
+    if (strtabidx && symtabidx) { \
+      char* strtab = buf + sh[strtabidx].sh_offset; \
+      sym_t* sym = (sym_t*)(buf + sh[symtabidx].sh_offset); \
+      for (unsigned i = 0; i < sh[symtabidx].sh_size/sizeof(sym_t); i++) { \
+        unsigned max_len = sh[strtabidx].sh_size - sym[i].st_name; \
+        assert(sym[i].st_name < sh[strtabidx].sh_size); \
+        assert(strnlen(strtab + sym[i].st_name, max_len) < max_len); \
+        symbols[strtab + sym[i].st_name] = sym[i].st_value; \
+      } \
+    } \
+  } while(0)
 
-    dtb = strstream.str();
-  } else {
-    dts = make_dts(INSNS_PER_RTC_TICK, CPU_HZ, initrd_start, initrd_end, bootargs, procs, mems);
-    dtb = dts_compile(dts);
-  }
+  if (IS_ELF32(*eh64))
+    LOAD_ELF(Elf32_Ehdr, Elf32_Phdr, Elf32_Shdr, Elf32_Sym);
+  else
+    LOAD_ELF(Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, Elf64_Sym);
+
+  munmap(buf, size);
+  return symbols;
 }
 
-void sim_t::set_rom()
+// use the dedicated function for initializing
+void simlib_t::make_dtb()
+{
+}
+
+void simlib_t::set_rom()
 {
   const int reset_vec_size = 8;
 
   start_pc = start_pc == reg_t(-1) ? get_entry_point() : start_pc;
 
+  processor_t* usable_proc_ptr = nullptr;
+  for(uint32_t id = 0; id < 0xffffffffu; ++id)
+  {
+    if(doesCoreWithIdExist(id))
+    {
+      usable_proc_ptr = get_core(id);
+      break;
+    }
+  }
+  assert(usable_proc_ptr != nullptr);
+
   uint32_t reset_vec[reset_vec_size] = {
     0x297,                                      // auipc  t0,0x0
     0x28593 + (reset_vec_size * 4 << 20),       // addi   a1, t0, &dtb
     0xf1402573,                                 // csrr   a0, mhartid
-    get_core(0)->get_xlen() == 32 ?
+    usable_proc_ptr->get_xlen() == 32 ?
       0x0182a283u :                             // lw     t0,24(t0)
       0x0182b283u,                              // ld     t0,24(t0)
     0x28067,                                    // jr     t0
@@ -335,67 +371,194 @@ void sim_t::set_rom()
 
   std::vector<char> rom((char*)reset_vec, (char*)reset_vec + sizeof(reset_vec));
 
-  std::string dtb;
-  if (!dtb_file.empty()) {
-    std::ifstream fin(dtb_file.c_str(), std::ios::binary);
-    if (!fin.good()) {
-      std::cerr << "can't find dtb file: " << dtb_file << std::endl;
-      exit(-1);
+  const int align = 0x1000;
+  rom.resize((rom.size() + align - 1) / align * align);
+
+  //write the rom code to the sparse memory model instead
+  std::vector<char> attrVec(rom.size(), 0x0);
+  for( size_t _index = 0; _index < rom.size(); ++_index)
+  {
+    if(sparse_is_pa_initialized(DEFAULT_RSTVEC + _index, 1))
+    {
+      std::cerr << "### Warning something already initialized the memory for VA: " << std::hex << DEFAULT_RSTVEC + _index << " with contents: " << std::hex << sparse_read(DEFAULT_RSTVEC + _index, 1) << std::endl;
+      sparse_write(DEFAULT_RSTVEC + _index, reinterpret_cast<uint8_t*>(rom.data() + _index), 1);
     }
+    else
+    {
+      sparse_initialize_pa(DEFAULT_RSTVEC + _index, reinterpret_cast<const uint8_t*>(rom.data()+_index), reinterpret_cast<const uint8_t*>(attrVec.data()+_index), 1, Force::EMemDataType::Both);
+    }
+  }
+}
 
-    std::stringstream strstream;
-    strstream << fin.rdbuf();
+// Not only loads the elf file in the specified path into the memory model but readies the simulator for stepping.
+int simlib_t::load_program_now(const char* elfPath)
+{
+  std::string path;
+  if (access(elfPath, F_OK) == 0)
+    path = elfPath;
 
-    dtb = strstream.str();
-  } else {
-    dts = make_dts(INSNS_PER_RTC_TICK, CPU_HZ, initrd_start, initrd_end, bootargs, procs, mems);
-    dtb = dts_compile(dts);
+  if (path.empty())
+  {
+    std::cerr << "could not open " << elfPath << " (did you misspell it? If VCS, did you forget +permissive/+permissive-off?)" << std::endl;
+    return 1;
   }
 
-  rom.insert(rom.end(), dtb.begin(), dtb.end());
-  const int align = 0x1000;
-  rom.resize((rom.size() + align - 1) / align * align);
+  std::map<std::string, uint64_t> symbols = load_elf(path.c_str(), &entry);
+
+  reset();
+
+  return 0;
+}
 
-  boot_rom.reset(new rom_device_t(rom));
-  bus.add_device(DEFAULT_RSTVEC, boot_rom.get());
+uint64_t simlib_t::sparse_read(reg_t paddr, size_t len)
+{
+  return _ForceSparseMemoryModel.Read(paddr, len);
 }
 
-char* sim_t::addr_to_mem(reg_t addr) {
-  if (!paddr_ok(addr))
-    return NULL;
-  auto desc = bus.find_device(addr);
-  if (auto mem = dynamic_cast<mem_t*>(desc.second))
-    if (addr - desc.first < mem->size())
-      return mem->contents(addr - desc.first);
-  return NULL;
+void simlib_t::sparse_read_partially_initialized(reg_t paddr, size_t len, uint8_t* bytes)
+{
+  _ForceSparseMemoryModel.ReadPartiallyInitialized(paddr, len, bytes);
 }
 
-const char* sim_t::get_symbol(uint64_t addr)
+void simlib_t::sparse_write(reg_t paddr, const uint8_t* bytes, size_t len)
 {
-  return htif_t::get_symbol(addr);
+  _ForceSparseMemoryModel.Write(paddr, bytes, len);
 }
 
-// htif
+void simlib_t::sparse_write(reg_t paddr, uint64_t value, size_t len)
+{
+  _ForceSparseMemoryModel.Write(paddr, value, len);
+}
 
-void sim_t::reset()
+void simlib_t::sparse_write_with_initialization(reg_t paddr, const uint8_t* bytes, size_t len)
 {
-  if (dtb_enabled)
-    set_rom();
+  if (not sparse_is_pa_initialized(paddr, len)) {
+    _ForceSparseMemoryModel.AutoInitialize(paddr, len);
+  }
+
+  _ForceSparseMemoryModel.Write(paddr, bytes, len);
+}
+
+bool simlib_t::sparse_is_pa_initialized(reg_t paddr, size_t len)
+{
+  return  _ForceSparseMemoryModel.IsInitialized(paddr, len);
+}
+
+void simlib_t::sparse_initialize_pa(reg_t paddr, const uint8_t* data, const uint8_t* attrs, uint32_t nBytes, Force::EMemDataType type)
+{
+  _ForceSparseMemoryModel.Initialize(paddr, data, attrs, nBytes, type);
+}
+
+void simlib_t::sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes, Force::EMemDataType type)
+{
+  _ForceSparseMemoryModel.Initialize(paddr, value, numBytes, type);
+}
+
+void simlib_t::sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes)
+{
+  _ForceSparseMemoryModel.Initialize(paddr, value, numBytes, Force::EMemDataType::Both);
+}
+
+void simlib_t::sparse_reserve(reg_t paddr, size_t numBytes)
+{
+  _ForceSparseMemoryModel.Reserve(paddr, numBytes);
+}
+
+void simlib_t::sparse_unreserve(reg_t paddr, size_t numBytes)
+{
+  _ForceSparseMemoryModel.Unreserve(paddr, numBytes);
+}
+
+bool simlib_t::sparse_is_reserved(reg_t paddr, size_t numBytes)
+{
+  return _ForceSparseMemoryModel.IsReserved(paddr, numBytes);
+}
+
+bool simlib_t::doesCoreWithIdExist(size_t i)
+{
+  for(processor_t* proc_ptr: procs)
+  {
+    if(proc_ptr != nullptr && proc_ptr->get_state() != nullptr && proc_ptr->get_state()->pid == i)
+    {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void simlib_t::dump_sparse_memory(std::ostream & out)
+{
+  _ForceSparseMemoryModel.Dump(out);
 }
 
-void sim_t::idle()
+void simlib_t::reset()
 {
-  target.switch_to();
+  if (dtb_enabled)
+    set_rom();
 }
 
-void sim_t::read_chunk(addr_t taddr, size_t len, void* dst)
+void simlib_t::read_chunk_partially_initialized(reg_t taddr, size_t len, void* dst)
 {
   assert(len == 8);
-  auto data = debug_mmu->to_target(debug_mmu->load_uint64(taddr));
+  auto data = debug_mmu->to_target(debug_mmu->load_partially_initialized_uint64(taddr));
   memcpy(dst, &data, sizeof data);
 }
 
-void sim_t::write_chunk(addr_t taddr, size_t len, const void* src)
+void simlib_t::clear_chunk(reg_t taddr, size_t len)
+{
+  char zeros[chunk_max_size()];
+  memset(zeros, 0, chunk_max_size());
+
+  for (size_t pos = 0; pos < len; pos += chunk_max_size())
+    write_chunk(taddr + pos, std::min(len - pos, chunk_max_size()), zeros);
+}
+
+void simlib_t::initialize_multiword(reg_t addr, size_t len, const void* bytes) // To support multiword initializations during elf loading
+{
+  size_t align = chunk_align();
+  if (len && (addr & (align-1)))
+  {
+    size_t this_len = std::min(len, align - size_t(addr & (align-1)));
+    uint8_t chunk[align];
+
+    read_chunk_partially_initialized(addr & ~(align-1), align, chunk);
+    memcpy(chunk + (addr & (align-1)), bytes, this_len);
+    write_chunk(addr & ~(align-1), align, chunk);
+
+    bytes = (char*)bytes + this_len;
+    addr += this_len;
+    len -= this_len;
+  }
+
+  if (len & (align-1))
+  {
+    size_t this_len = len & (align-1);
+    size_t start = len - this_len;
+    uint8_t chunk[align];
+
+    read_chunk_partially_initialized(addr + start, align, chunk);
+    memcpy(chunk, (char*)bytes + start, this_len);
+    write_chunk(addr + start, align, chunk);
+
+    len -= this_len;
+  }
+
+  // now we're aligned
+  bool all_zero = len != 0;
+  for (size_t i = 0; i < len; i++)
+    all_zero &= ((const char*)bytes)[i] == 0;
+
+  if (all_zero) {
+    clear_chunk(addr, len);
+  } else {
+    size_t max_chunk = chunk_max_size();
+    for (size_t pos = 0; pos < len; pos += max_chunk)
+      write_chunk(addr + pos, std::min(max_chunk, len - pos), (char*)bytes + pos);
+  }
+}
+
+void simlib_t::write_chunk(reg_t taddr, size_t len, const void* src)
 {
   assert(len == 8);
   target_endian<uint64_t> data;
@@ -403,7 +566,7 @@ void sim_t::write_chunk(addr_t taddr, size_t len, const void* src)
   debug_mmu->store_uint64(taddr, debug_mmu->from_target(data));
 }
 
-void sim_t::set_target_endianness(memif_endianness_t endianness)
+void simlib_t::set_target_endianness(memif_endianness_t endianness)
 {
 #ifdef RISCV_ENABLE_DUAL_ENDIAN
   assert(endianness == memif_endianness_little || endianness == memif_endianness_big);
@@ -419,7 +582,7 @@ void sim_t::set_target_endianness(memif_endianness_t endianness)
 #endif
 }
 
-memif_endianness_t sim_t::get_target_endianness() const
+memif_endianness_t simlib_t::get_target_endianness() const
 {
 #ifdef RISCV_ENABLE_DUAL_ENDIAN
   return debug_mmu->is_target_big_endian()? memif_endianness_big : memif_endianness_little;
@@ -428,7 +591,801 @@ memif_endianness_t sim_t::get_target_endianness() const
 #endif
 }
 
-void sim_t::proc_reset(unsigned id)
+void simlib_t::proc_reset(unsigned id)
+{
+////  debug_module.proc_reset(id);
+}
+
+processor_t *simlib_t::get_core(const std::string& i)
+{
+  char *ptr;
+  unsigned long p = strtoul(i.c_str(), &ptr, 10);
+  //if (*ptr || p >= procs.size())
+  //  throw trap_interactive();
+  return get_core(p);
+}
+
+reg_t simlib_t::get_mem(const std::vector<std::string>& args)
+{
+  //if(args.size() != 1 && args.size() != 2)
+  //  throw trap_interactive();
+
+  std::string addr_str = args[0];
+  mmu_t* mmu = debug_mmu;
+  if(args.size() == 2)
+  {
+    processor_t *p = get_core(args[0]);
+    mmu = p->get_mmu();
+    addr_str = args[1];
+  }
+
+  reg_t addr = strtol(addr_str.c_str(),NULL,16), val;
+  if(addr == LONG_MAX)
+    addr = strtoul(addr_str.c_str(),NULL,16);
+
+  switch(addr % 8)
+  {
+    case 0:
+      val = mmu->load_uint64(addr);
+      break;
+    case 4:
+      val = mmu->load_uint32(addr);
+      break;
+    case 2:
+    case 6:
+      val = mmu->load_uint16(addr);
+      break;
+    default:
+      val = mmu->load_uint8(addr);
+      break;
+  }
+  return val;
+}
+
+uint64_t simlib_t::get_csr_number(const std::string& input_name)
+{
+  //Cant use a switch here unless we map the names to ints beforehand
+  #define DECLARE_CSR(name, number) if (input_name == #name) return number;
+  #include "encoding.h"              // generates if's for all csrs
+  return 0xDEADBEEFDEADBEEF;         // else return a value outside the ISA established 4096 possible
+  #undef DECLARE_CSR
+}
+
+uint64_t simlib_t::get_xpr_number(const std::string& input_name)
+{
+  return std::find(xpr_arch_name, xpr_arch_name + NXPR, input_name) - xpr_arch_name;
+}
+
+uint64_t simlib_t::get_fpr_number(const std::string& input_name)
 {
-  debug_module.proc_reset(id);
+  return std::find(fpr_arch_name, fpr_arch_name + NFPR, input_name) - fpr_arch_name;
 }
+
+uint64_t simlib_t::get_vecr_number(const std::string& input_name)
+{
+  return std::find(vr_name, vr_name + NVPR, input_name) - vr_name;
+}
+
+std::string simlib_t::get_csr_name(uint64_t index)
+{
+  if(index < NCSR)
+    return csr_name(index);
+  else
+    return "unknown-csr";
+}
+
+std::string simlib_t::get_xpr_name(uint64_t index)
+{
+  if(index < NXPR)
+    return xpr_arch_name[index];
+  else
+    return "unknown-xpr";
+}
+
+std::string simlib_t::get_fpr_name(uint64_t index)
+{
+  if(index < NFPR)
+    return fpr_arch_name[index];
+  else
+    return "unknown-fpr";
+}
+
+std::string simlib_t::get_vecr_name(uint64_t index)
+{
+  if(index < NVPR)
+    return vr_name[index];
+  else
+    return "unknown-vr";
+}
+
+int simlib_t::read_csr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index is valid
+  if(index >= NCSR)
+    return 3;
+
+  //Check if the index corresponds to a defined csr
+  // WARNING: there are a number of CSRs that are defined in encoding.h but have no entry in the processor class get_csr method. In this case, for now, a value of 0xDEADBEEFDEADBEEF will be returned
+  std::string temp_name = get_csr_name(index);
+  size_t unknown = temp_name.find("unknown");
+  if(unknown != std::string::npos)
+    return 3;
+
+  //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
+  *value = get_core(procid)->get_csr_api(index);
+  *length = get_core(procid)->get_xlen() / 8;
+
+  return 0;
+}
+
+int simlib_t::read_csr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the name is valid
+  uint64_t index = get_csr_number(input_name);
+  if(index >= NCSR)
+    return 3;
+
+  //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
+  *value = get_core(procid)->get_csr_api(index);
+  *length = get_core(procid)->get_xlen() / 8;
+
+  return 0;
+}
+
+int simlib_t::read_xpr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the name is valid
+  uint64_t index = get_xpr_number(input_name);
+  if(index >= NXPR)
+    return 3;
+
+  //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
+  *value = get_core(procid)->get_state()->XPR.readNoCallback(index);
+  *length = get_core(procid)->get_xlen() / 8;
+
+  return 0;
+}
+
+int simlib_t::read_xpr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //check if the index provided is valid
+  if(index >= NXPR)
+    return 3;
+
+  //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
+  //*value = get_core(procid)->get_state()->XPR[index];
+
+  *value = get_core(procid)->get_state()->XPR.readNoCallback(index);
+  *length = get_core(procid)->get_xlen() / 8;
+
+  return 0;
+}
+
+int simlib_t::read_fpr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //check if the name provided is valid
+  uint64_t index = get_fpr_number(input_name);
+  if(index >= NFPR)
+    return 3;
+
+  //Check that the advertised length of the provided buffer is sufficient
+  if(*length < sizeof(freg_t))
+    return 4;
+
+  //All checks have passed, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
+  freg_t temp_fpr_val = get_core(procid)->get_state()->FPR.readNoCallback(index);
+  memcpy(value, &temp_fpr_val, sizeof(freg_t));
+  *length = sizeof(freg_t);
+
+  return 0;
+}
+
+int simlib_t::read_fpr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index provided is valid
+  if(index >= NFPR)
+    return 3;
+
+  if(*length < sizeof(freg_t))
+    return 4;
+
+  //All checks have passed
+  freg_t temp_fpr_val = get_core(procid)->get_state()->FPR.readNoCallback(index);
+  memcpy(value, &temp_fpr_val, sizeof(freg_t));
+  *length = sizeof(freg_t);
+
+  return 0;
+}
+
+int simlib_t::read_vecr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length)
+{
+  //Check that the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the name provided is valid
+  uint64_t index = get_vecr_number(input_name);
+  if(index >= NVPR)
+    return 3;
+
+  //Check that the advertised length of the buffer in bytes can hold the requested data
+  size_t vlen = get_core(procid)->VU.get_vlen() / 8;
+  if(vlen > *length){
+    return 4;
+  }
+
+  //All checks passed
+  size_t elen = get_core(procid)->VU.get_elen() / 8;
+  size_t num_elem = vlen/elen;
+
+  //Write the elements into the value buffer
+  for(size_t element = 0; element < num_elem; ++element)
+  {
+    uint64_t val = 0ull;
+    switch(elen)
+    {
+      case 8:
+      val = get_core(procid)->VU.elt<uint64_t>(index, element);
+      break;
+      case 4:
+      val = get_core(procid)->VU.elt<uint32_t>(index, element);
+      break;
+      case 2:
+      val = get_core(procid)->VU.elt<uint16_t>(index, element);
+      break;
+      case 1:
+      val = get_core(procid)->VU.elt<uint8_t>(index, element);
+      break;
+    }
+
+    memcpy(value + element * elen, &val, elen);
+  }
+
+  //Set the length value to the number of bytes that was written
+  *length = vlen;
+
+  return 0;
+}
+
+int simlib_t::read_vecr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length)
+{
+  //Check that the pointers point to something
+  if(value == nullptr || length == nullptr)
+    return 1;
+
+  //Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index provided is valid
+  if(index >= NVPR)
+    return 3;
+
+  //Check that the advertised length of the buffer in bytes can hold the requested data
+  size_t vlen = get_core(procid)->VU.get_vlen() / 8;
+  if(vlen > *length){
+    return 4;
+  }
+
+  //All checks passed
+  size_t elen = get_core(procid)->VU.get_elen() / 8;
+  size_t num_elem = vlen/elen;
+
+  //Write the elements into the value buffer
+  for(size_t element = 0; element < num_elem; ++element)
+  {
+    uint64_t val = 0ull;
+    switch(elen)
+    {
+      case 8:
+      val = get_core(procid)->VU.elt<uint64_t>(index, element);
+      break;
+      case 4:
+      val = get_core(procid)->VU.elt<uint32_t>(index, element);
+      break;
+      case 2:
+      val = get_core(procid)->VU.elt<uint16_t>(index, element);
+      break;
+      case 1:
+      val = get_core(procid)->VU.elt<uint8_t>(index, element);
+      break;
+    }
+
+    memcpy(value + element * elen, &val, elen);
+  }
+
+  //Set the length value to the number of bytes that was written
+  *length = vlen;
+
+  return 0;
+}
+
+int simlib_t::partial_read_vecr(uint32_t procid, uint64_t index, uint8_t* pValue, uint32_t length, uint32_t offset)
+{
+  //Check that the pointers point to something
+  if(pValue == nullptr)
+    return 1;
+
+  //Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index provided is valid
+  if(index >= NVPR)
+    return 3;
+
+  //Check that the advertised length of the buffer in bytes can hold the requested data
+  size_t vlen = get_core(procid)->VU.get_vlen() / 8;
+  if(vlen < (offset + length)){
+    return 4;
+  }
+
+  //All checks passed; write the elements into the value buffer
+  // make this a memcpy
+  for(size_t element = offset; element < (offset + length); ++element)
+  {
+    pValue[element - offset] = get_core(procid)->VU.elt<uint8_t>(index, element);
+  }
+
+  return 0;
+}
+
+
+int simlib_t::partial_write_vecr(uint32_t procid, uint64_t index, const uint8_t* pValue, uint32_t length, uint32_t offset)
+{
+  //Check that the pointers point to something
+  if(pValue == nullptr)
+    return 1;
+
+  //Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index provided is valid
+  if(index >= NVPR)
+    return 3;
+
+  //Check that the advertised length of the buffer in bytes can hold the requested data
+  size_t vlen = get_core(procid)->VU.get_vlen() / 8;
+  if(vlen < (offset + length)){
+    return 4;
+  }
+
+  //All checks passed; write the elements into the value buffer
+  // make this a memcpy
+  for(size_t element = offset; element < (offset + length); ++element)
+  {
+    get_core(procid)->VU.elt<uint8_t>(index, element) = pValue[element - offset];
+  }
+
+  return 0;
+}
+
+
+int simlib_t::write_csr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index is valid
+  if(index >= NCSR)
+    return 3;
+
+  //Is the indended write length matching the xlen value?
+  if(length != (get_core(procid)->get_xlen() / 8))
+    return 4;
+
+  //All checks pass, so go ahead and and write to the csr
+  get_core(procid)->set_csr_api(index, *value);
+
+  return 0;
+}
+
+int simlib_t::write_csr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the name is valid
+  uint64_t index = get_csr_number(input_name);
+  if(index >= NCSR)
+    return 3;
+
+  //Is the indended write length matching the xlen value?
+  if(length != (get_core(procid)->get_xlen() / 8))
+    return 4;
+
+  //All checks pass, so go ahead and and write to the csr
+  get_core(procid)->set_csr_api(index, *value);
+
+  return 0;
+}
+
+int simlib_t::write_xpr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the name is valid
+  uint64_t index = get_xpr_number(input_name);
+  if(index >= NXPR)
+    return 3;
+
+  //Is the indended write length matching the xlen value?
+  //if(length != (get_core(procid)->get_xlen() / 8))
+  //  return 4;
+
+  //All checks pass, so go ahead and load the value buffer and set the length to indicate the used bytes in the value buffer
+  get_core(procid)->get_state()->XPR.writeNoCallback(index, *value);
+
+  return 0;
+}
+
+int simlib_t::write_xpr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //check if the index provided is valid
+  if(index >= NXPR)
+    return 3;
+
+  //Is the indended write length matching the xlen value?
+  //if(length != (get_core(procid)->get_xlen() / 8))
+  //  return 4;
+
+  //All checks pass so we're go to write
+  get_core(procid)->get_state()->XPR.writeNoCallback(index, *value);
+
+  return 0;
+}
+
+int simlib_t::write_fpr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //check if the name provided is valid
+  uint64_t index = get_fpr_number(input_name);
+  if(index >= NFPR)
+    return 3;
+
+  //Is the indended write length matching the flen value?
+  if(length > sizeof(freg_t))
+    return 4;
+
+  //All checks have passed perform the write via a memory operation into the floating point register model
+  freg_t temp_fpr_val;
+  temp_fpr_val.v[0] = 0xffffffffffffffffull;
+  temp_fpr_val.v[1] = 0xffffffffffffffffull;
+  memcpy(&temp_fpr_val, value, length);
+  get_core(procid)->get_state()->FPR.writeNoCallback(index, temp_fpr_val);
+
+  return 0;
+}
+
+int simlib_t::write_fpr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length)
+{
+  //Check if the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check if the procid AKA hart id is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index provided is valid
+  if(index >= NFPR)
+    return 3;
+
+  //Is the indended write length matching the flen value?
+  if(length > sizeof(freg_t))
+    return 4;
+
+  //All checks have passed perform the write via a memory operation into the floating point register model
+  freg_t temp_fpr_val;
+  temp_fpr_val.v[0] = 0xffffffffffffffffull;
+  temp_fpr_val.v[1] = 0xffffffffffffffffull;
+  memcpy(&temp_fpr_val, value, length);
+  get_core(procid)->get_state()->FPR.writeNoCallback(index, temp_fpr_val);
+
+  return 0;
+}
+
+//will probably have to cast differently here and other places to the get the pointer types the same and compatible with the function.
+int simlib_t::write_vecr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length)
+{
+  //Check that the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the name provided is valid
+  uint64_t index = get_vecr_number(input_name);
+  if(index >= NVPR)
+    return 3;
+
+  //Check that the advertised length of the buffer in bytes equals the size of the vector register
+  size_t vlen = get_core(procid)->VU.get_vlen() / 8;
+  if(vlen != length)
+    return 4;
+
+  //All checks passed
+  size_t elen = get_core(procid)->VU.get_elen() / 8;
+  size_t num_elem = vlen/elen;
+
+  //Write the elements into the value buffer
+  for(size_t element = 0; element < num_elem; ++element)
+  {
+    switch(elen)
+    {
+      case 8:
+      {
+        uint64_t* reg = &(get_core(procid)->VU.elt<uint64_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+      case 4:
+      {
+        uint32_t* reg = &(get_core(procid)->VU.elt<uint32_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+      case 2:
+      {
+        uint16_t* reg = &(get_core(procid)->VU.elt<uint16_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+      case 1:
+      {
+        uint8_t* reg = &(get_core(procid)->VU.elt<uint8_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+    }
+  }
+
+  return 0;
+}
+
+int simlib_t::write_vecr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length)
+{
+  //Check that the pointers point to something
+  if(value == nullptr)
+    return 1;
+
+  //Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  //Check if the index provided is valid
+  if(index >= NVPR)
+    return 3;
+
+  //Check that the advertised length of the buffer in bytes can hold the requested data
+  size_t vlen = get_core(procid)->VU.get_vlen() / 8;
+  if(vlen != length)
+    return 4;
+
+  //All checks passed
+  size_t elen = get_core(procid)->VU.get_elen() / 8;
+  size_t num_elem = vlen/elen;
+
+  //Write the elements into the value buffer
+  for(size_t element = 0; element < num_elem; ++element)
+  {
+    switch(elen)
+    {
+      case 8:
+      {
+        uint64_t* reg = &(get_core(procid)->VU.elt<uint64_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+      case 4:
+      {
+        uint32_t* reg = &(get_core(procid)->VU.elt<uint32_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+      case 2:
+      {
+        uint16_t* reg = &(get_core(procid)->VU.elt<uint16_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+      case 1:
+      {
+        uint8_t* reg = &(get_core(procid)->VU.elt<uint8_t>(index, element));
+        memcpy(reg, value + element * elen, elen);
+        break;
+      }
+    }
+  }
+
+  return 0;
+}
+
+int simlib_t::translate_virtual_address_api(int procid, const uint64_t* vaddr, int intent, uint64_t* paddr, uint64_t* memattrs)
+{
+  // check the pointers do point to something
+  if(vaddr == nullptr || paddr == nullptr || memattrs == nullptr)
+    return 1;
+
+  // Check that the procid AKA hart is valid
+  if(not doesCoreWithIdExist(procid))
+    return 2;
+
+  // get the mmu for the specified processor and call the translation api function
+  access_type type;
+  switch(intent)
+  {
+    case(0):
+      type = access_type::LOAD;
+      break;
+    case(1):
+      type = access_type::STORE;
+      break;
+    case(2):
+      type = access_type::FETCH;
+      break;
+  }
+  // TODO(Noah): Investigate what might need to be passed for the xlate_flags parameter when there
+  // is time to do so.
+  int status = get_core(procid)->get_mmu()->translate_api(*vaddr, paddr, memattrs, reg_t(1) /* length */, static_cast<access_type>(intent), 0); // length is set to 1 byte here because the api requirements were for individual bytes only.
+
+  if(status == 0)
+  {
+    return 0;
+  }
+
+  return status + 2;
+}
+
+bool simlib_t::set_pc_api(int procid, const std::string& name, const uint8_t* bytes, size_t len)
+{
+  if(bytes == nullptr)
+  {
+    return false;
+  }
+  else if(not doesCoreWithIdExist(procid))
+  {
+    return false;
+  }
+
+  processor_t* proc_ptr = get_core(procid);
+  if(proc_ptr == nullptr)
+  {
+    return false;
+  }
+
+  return get_core(procid)->set_pc_api(name, bytes, len);
+}
+
+bool simlib_t::get_pc_api(int procid, uint8_t* bytes, const std::string& name, size_t len)
+{
+  if(bytes == nullptr)
+  {
+    return false;
+  }
+  else if(not doesCoreWithIdExist(procid))
+  {
+    return false;
+  }
+
+  processor_t* proc_ptr = get_core(procid);
+  if(proc_ptr == nullptr)
+  {
+    return false;
+  }
+
+  return get_core(procid)->retrieve_pc_api(bytes, name, len); // The method called in processor_t will validate the name and length.
+}
+
+bool simlib_t::set_privilege_api(int procid, const uint64_t* val)
+{
+  if (nullptr == val) return false;
+  if (!doesCoreWithIdExist(procid)) return false;
+
+  processor_t* proc_ptr = get_core(procid);
+  if (nullptr == proc_ptr) return false;
+
+  //assert in legalize_privilege should catch invalid values
+  //register field is only 2 bits so shouldn't be able to pass invalid case from force
+  proc_ptr->set_privilege_api(*val);
+  return true;
+}
+
+bool simlib_t::get_privilege_api(int procid, uint64_t* val)
+{
+  if(nullptr == val) return false;
+  if(!doesCoreWithIdExist(procid)) return false;
+
+  processor_t* proc_ptr = get_core(procid);
+  if(nullptr == proc_ptr) return false;
+
+  proc_ptr->retrieve_privilege_api(val);
+  return true;
+}
+
diff --git a/riscv/sim.h b/riscv/sim.h
index a425da48..378c095c 100644
--- a/riscv/sim.h
+++ b/riscv/sim.h
@@ -3,22 +3,15 @@
 #ifndef _RISCV_SIM_H
 #define _RISCV_SIM_H
 
-#include "config.h"
+#include "Force_Memory.h"
+#include "Force_Enums.h"
 
-#ifdef HAVE_BOOST_ASIO
-#include <boost/algorithm/string.hpp>
-#include <boost/regex.hpp>
-#include <boost/asio.hpp>
-#endif
+#include "config.h"
 
-#include "debug_module.h"
-#include "devices.h"
-#include "log_file.h"
 #include "processor.h"
+#include "devices.h"
 #include "simif.h"
-
-#include <fesvr/htif.h>
-#include <fesvr/context.h>
+#include <fesvr/memif.h>
 #include <vector>
 #include <string>
 #include <memory>
@@ -28,26 +21,27 @@ class mmu_t;
 class remote_bitbang_t;
 
 // this class encapsulates the processors and memory in a RISC-V machine.
-class sim_t : public htif_t, public simif_t
+class simlib_t : public simif_t
 {
 public:
-  sim_t(const char* isa, const char* priv, const char* varch, size_t _nprocs,
-        bool halted, bool real_time_clint,
-        reg_t initrd_start, reg_t initrd_end, const char* bootargs,
-        reg_t start_pc, std::vector<std::pair<reg_t, mem_t*>> mems,
-        std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices,
-        const std::vector<std::string>& args, const std::vector<int> hartids,
-        const debug_module_config_t &dm_config, const char *log_path,
-        bool dtb_enabled, const char *dtb_file,
-#ifdef HAVE_BOOST_ASIO
-        boost::asio::io_service *io_service_ptr_ctor, boost::asio::ip::tcp::acceptor *acceptor_ptr_ctor,  // option -s
-#endif
+  simlib_t(const char* isa, const char* priv, const char* varch, size_t _nprocs, bool halted,
+        const char* bootargs, reg_t start_pc, const std::vector<int> hartids, bool auto_init_mem,
         FILE *cmd_file); // needed for command line option --cmd
-  ~sim_t();
+  ~simlib_t();
+
+  // load the elf file and reset
+  int load_program_now(const char* elfPath);
+
+  // run the simulation incrementally
+  int step_simulator(int target_id, int num_steps, int stx_failed);
+
+  // fetch the instruction at the given pc using the debug_mmu and return the opcode and disassembly
+  int get_disassembly(int target_id, const uint64_t* pc, char** opcode, char** disassembly);
 
   // run the simulation to completion
   int run();
   void set_debug(bool value);
+  void set_log(bool value);
   void set_histogram(bool value);
 
   // Configure logging
@@ -59,19 +53,113 @@ public:
   void configure_log(bool enable_log, bool enable_commitlog);
 
   void set_procs_debug(bool value);
+  void set_dtb_enabled(bool value) {
+    this->dtb_enabled = value;
+  }
   void set_remote_bitbang(remote_bitbang_t* remote_bitbang) {
     this->remote_bitbang = remote_bitbang;
   }
+
   const char* get_dts() { if (dts.empty()) reset(); return dts.c_str(); }
-  processor_t* get_core(size_t i) { return procs.at(i); }
+
+  processor_t* get_core(size_t i) 
+  { 
+    for(processor_t* proc_ptr : procs)
+    {
+      if(proc_ptr != nullptr && proc_ptr->get_state() != nullptr && proc_ptr->get_state()->pid == i)
+        return proc_ptr; 
+    }
+
+    return nullptr;
+  }
+
   unsigned nprocs() const { return procs.size(); }
 
+  bool doesCoreWithIdExist(size_t i);
+
+  // for debugging the sparse memory model
+  void dump_sparse_memory(std::ostream & out);
+
   // Callback for processors to let the simulation know they were reset.
   void proc_reset(unsigned id);
 
+  //
+  reg_t get_entry_point(){ return entry; };
+
+  uint64_t get_csr_number(const std::string& input_name);
+  uint64_t get_xpr_number(const std::string& input_name);
+  uint64_t get_fpr_number(const std::string& input_name); 
+  uint64_t get_vecr_number(const std::string& input_name);
+
+  std::string get_csr_name(uint64_t index);
+  std::string get_xpr_name(uint64_t index);
+  std::string get_fpr_name(uint64_t index); 
+  std::string get_vecr_name(uint64_t index);
+
+  int read_csr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length);
+  int read_csr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length);
+
+  int read_xpr(uint32_t procid, const std::string& input_name, uint64_t* value, uint32_t* length);
+  int read_xpr(uint32_t procid, uint64_t index, uint64_t* value, uint32_t* length);
+
+  int read_fpr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length);
+  int read_fpr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length);
+
+  int read_vecr(uint32_t procid, const std::string& input_name, uint8_t* value, uint32_t* length);
+  int read_vecr(uint32_t procid, uint64_t index, uint8_t* value, uint32_t* length);
+  int partial_read_vecr(uint32_t procid, uint64_t index, uint8_t* pValue, uint32_t length, uint32_t offset);
+
+  int write_csr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length);
+  int write_csr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length);
+
+  int write_xpr(uint32_t procid, const std::string& input_name, const uint64_t* value, uint32_t length);
+  int write_xpr(uint32_t procid, uint64_t index, const uint64_t* value, uint32_t length);
+
+  int write_fpr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length);
+  int write_fpr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length);
+
+  int write_vecr(uint32_t procid, const std::string& input_name, const uint8_t* value, uint32_t length);
+  int write_vecr(uint32_t procid, uint64_t index, const uint8_t* value, uint32_t length);
+  int partial_write_vecr(uint32_t procid, uint64_t index, const uint8_t* pValue, uint32_t length, uint32_t offset);
+
+  void sparse_read_partially_initialized(reg_t paddr, size_t len, uint8_t* bytes);
+  void sparse_write(reg_t paddr, const uint8_t* bytes, size_t len);
+  void sparse_write_with_initialization(reg_t paddr, const uint8_t* bytes, size_t len);
+  void sparse_write_multiword(reg_t paddr, const uint8_t* bytes, size_t len){};
+  void sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes);
+  bool sparse_is_pa_initialized(reg_t paddr, size_t len);
+  void sparse_reserve(reg_t paddr, size_t numBytes) override;
+  void sparse_unreserve(reg_t paddr, size_t numBytes) override;
+  bool sparse_is_reserved(reg_t paddr, size_t numBytes) override;
+  void initialize_multiword(reg_t taddr, size_t len, const void* src); // To support multiword initializations during elf loading
+
+  bool set_pc_api(int procid, const std::string& name, const uint8_t* bytes, size_t len);
+  bool get_pc_api(int procid, uint8_t* bytes, const std::string& name, size_t len);
+
+  bool set_privilege_api(int procid, const uint64_t* val);
+  bool get_privilege_api(int procid, uint64_t* val);
+
+  // translate_virtual_address_api function: attempts to translate a virtual address into a physical address, returns any error information and also gathers the relevant pmp address and pmp configuration.
+  //
+  //  meaning of 'intent':
+  //    0 - indicates a 'LOAD' access
+  //    1 - indicates a 'STORE' access
+  //    2 - indicates a 'FETCH' access
+  //
+  //  returns:
+  //    0 - success
+  //    1 - some pointer arguments were null
+  //    2 - invalid procid
+  //    3 - PMP problem with PA after address translation somehow
+  //    4 - access exception while trying to check pmp status of page table entry PA
+  //    5 - walk was unsuccessful and access type was FETCH
+  //    6 - walk was unsuccessful and access type was LOAD
+  //    7 - walk was unsuccessful and access type was STORE
+  //    8 - walk was unsuccessful and access type was not any of the above
+  //
+  int translate_virtual_address_api(int procid, const uint64_t* vaddr, int intent, uint64_t* paddr, uint64_t* memattrs);
+
 private:
-  std::vector<std::pair<reg_t, mem_t*>> mems;
-  std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices;
   mmu_t* debug_mmu;  // debug port into main memory
   std::vector<processor_t*> procs;
   reg_t initrd_start;
@@ -79,24 +167,9 @@ private:
   const char* bootargs;
   reg_t start_pc;
   std::string dts;
-  std::string dtb;
-  std::string dtb_file;
-  bool dtb_enabled;
-  std::unique_ptr<rom_device_t> boot_rom;
-  std::unique_ptr<clint_t> clint;
-  bus_t bus;
-  log_file_t log_file;
 
   FILE *cmd_file; // pointer to debug command input file
 
-#ifdef HAVE_BOOST_ASIO
-  // the following are needed for command socket interface
-  boost::asio::io_service *io_service_ptr;
-  boost::asio::ip::tcp::acceptor *acceptor_ptr;
-  std::unique_ptr<boost::asio::ip::tcp::socket> socket_ptr;
-  std::string rin(boost::asio::streambuf *bout_ptr); // read input command string
-  void wout(boost::asio::streambuf *bout_ptr); // write output to socket
-#endif
   std::ostream sout_; // used for socket and terminal interface
 
   processor_t* get_core(const std::string& i);
@@ -109,43 +182,29 @@ private:
   bool debug;
   bool histogram_enabled; // provide a histogram of PCs
   bool log;
+  bool dtb_enabled;
   remote_bitbang_t* remote_bitbang;
 
-  // memory-mapped I/O routines
-  char* addr_to_mem(reg_t addr);
-  bool mmio_load(reg_t addr, size_t len, uint8_t* bytes);
-  bool mmio_store(reg_t addr, size_t len, const uint8_t* bytes);
   void make_dtb();
   void set_rom();
 
-  const char* get_symbol(uint64_t addr);
-
-  // presents a prompt for introspection into the simulation
-  void interactive();
-
-  // functions that help implement interactive()
-  void interactive_help(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_quit(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_run(const std::string& cmd, const std::vector<std::string>& args, bool noisy);
-  void interactive_run_noisy(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_run_silent(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_vreg(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_reg(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_freg(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_fregh(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_fregs(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_fregd(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_pc(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_mem(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_str(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_until(const std::string& cmd, const std::vector<std::string>& args, bool noisy);
-  void interactive_until_silent(const std::string& cmd, const std::vector<std::string>& args);
-  void interactive_until_noisy(const std::string& cmd, const std::vector<std::string>& args);
-  reg_t get_reg(const std::vector<std::string>& args);
-  freg_t get_freg(const std::vector<std::string>& args);
+  // sparse memory routines
+  Force::Memory _ForceSparseMemoryModel;
+  uint64_t sparse_read(reg_t paddr, size_t len);
+  void sparse_write(reg_t paddr, uint64_t value, size_t len);
+  //bool sparse_is_pa_initialized(reg_t paddr, size_t len);
+  void sparse_initialize_pa(reg_t paddr, const uint8_t* data, const uint8_t* attrs, uint32_t nBytes, Force::EMemDataType type);
+  void sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes, Force::EMemDataType type);
+  //void sparse_read_partially_initialized(reg_t paddr, size_t len, uint8_t* bytes);
+  //void sparse_write(reg_t paddr, const uint8_t* bytes, size_t len);
+
+
+  reg_t entry;
+  std::map<std::string, uint64_t> load_elf(const char* fn, reg_t* entry);
+
   reg_t get_mem(const std::vector<std::string>& args);
   reg_t get_pc(const std::vector<std::string>& args);
-
+    
   friend class processor_t;
   friend class mmu_t;
   friend class debug_module_t;
@@ -154,22 +213,17 @@ private:
   friend void sim_thread_main(void*);
   void main();
 
-  context_t* host;
-  context_t target;
   void reset();
-  void idle();
-  void read_chunk(addr_t taddr, size_t len, void* dst);
-  void write_chunk(addr_t taddr, size_t len, const void* src);
+  //void idle();
+  void read_chunk_partially_initialized(reg_t taddr, size_t len, void* dst);
+  void clear_chunk(reg_t taddr, size_t len);
+  //void initialize_multiword(reg_t taddr, size_t len, const void* src); // To support multiword initializations during elf loading
+  void write_chunk(reg_t taddr, size_t len, const void* src);
   size_t chunk_align() { return 8; }
   size_t chunk_max_size() { return 8; }
   void set_target_endianness(memif_endianness_t endianness);
   memif_endianness_t get_target_endianness() const;
 
-public:
-  // Initialize this after procs, because in debug_module_t::reset() we
-  // enumerate processors, which segfaults if procs hasn't been initialized
-  // yet.
-  debug_module_t debug_module;
 };
 
 extern volatile bool ctrlc_pressed;
diff --git a/riscv/simif.h b/riscv/simif.h
index 0e75d45b..555cd8c1 100644
--- a/riscv/simif.h
+++ b/riscv/simif.h
@@ -4,21 +4,27 @@
 #define _RISCV_SIMIF_H
 
 #include "decode.h"
+#include "Force_Memory.h"
 
 // this is the interface to the simulator used by the processors and memory
 class simif_t
 {
 public:
-  // should return NULL for MMIO addresses
-  virtual char* addr_to_mem(reg_t addr) = 0;
-  // used for MMIO addresses
-  virtual bool mmio_load(reg_t addr, size_t len, uint8_t* bytes) = 0;
-  virtual bool mmio_store(reg_t addr, size_t len, const uint8_t* bytes) = 0;
-  // Callback for processors to let the simulation know they were reset.
+  virtual ~simif_t() = default;
   virtual void proc_reset(unsigned id) = 0;
 
-  virtual const char* get_symbol(uint64_t addr) = 0;
-
+  // to support sparse memory model
+  virtual uint64_t sparse_read(reg_t paddr, size_t len) = 0;
+  virtual void sparse_read_partially_initialized(reg_t paddr, size_t len, uint8_t* bytes) = 0;
+  virtual void sparse_write(reg_t paddr, const uint8_t* bytes, size_t len) = 0;
+  virtual void sparse_write(reg_t paddr, uint64_t value, size_t len) = 0;
+  virtual void sparse_write_with_initialization(reg_t paddr, const uint8_t* bytes, size_t len) = 0;
+  virtual bool sparse_is_pa_initialized(reg_t paddr, size_t len) = 0;
+  virtual void sparse_initialize_pa(reg_t paddr, reg_t value, size_t numBytes, Force::EMemDataType type) = 0;
+  virtual void sparse_initialize_pa(reg_t paddr, const uint8_t* data, const uint8_t* attrs, uint32_t nBytes, Force::EMemDataType type) = 0;
+  virtual void sparse_reserve(reg_t paddr, size_t numBytes) = 0;
+  virtual void sparse_unreserve(reg_t paddr, size_t numBytes) = 0;
+  virtual bool sparse_is_reserved(reg_t paddr, size_t numBytes) = 0;
 };
 
 #endif
diff --git a/scripts/gen_src.sh b/scripts/gen_src.sh
new file mode 100755
index 00000000..efdbf5fd
--- /dev/null
+++ b/scripts/gen_src.sh
@@ -0,0 +1,6 @@
+#!/usr/bin/env bash
+insn=$1
+dst_dir=$2
+mkdir -p ${dst_dir}
+opcode=$(grep ^DECLARE_INSN\s*\(\s*${insn}\s*\, ./encoding.h | sed "s/DECLARE_INSN(.*,\(.*\),.*)/\1/")
+sed "s/NAME/${insn}/" ./insn_template.cc | sed "s/OPCODE/${opcode}/" > ${dst_dir}/${insn}.cc
\ No newline at end of file
diff --git a/softfloat/CMakeLists.txt b/softfloat/CMakeLists.txt
new file mode 100644
index 00000000..5ee63b5d
--- /dev/null
+++ b/softfloat/CMakeLists.txt
@@ -0,0 +1,25 @@
+# Copyright 2019-2021 T-Head Semiconductor Co., Ltd.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.0.0)
+project(softfloat VERSION 1.1.0)
+
+# set c++11
+set (CMAKE_CXX_STANDARD 11)
+
+aux_source_directory(${PROJECT_SOURCE_DIR} SOFTFLOAT_SRCS)
+
+add_library(${PROJECT_NAME} INTERFACE)
+target_sources(${PROJECT_NAME} INTERFACE ${SOFTFLOAT_SRCS})
+target_include_directories(${PROJECT_NAME} INTERFACE ./)
\ No newline at end of file
diff --git a/softfloat/softfloat.h b/softfloat/softfloat.h
index bdac1be2..41575b91 100644
--- a/softfloat/softfloat.h
+++ b/softfloat/softfloat.h
@@ -1,11 +1,1253 @@
+/*============================================================================
+
+This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
+University of California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+
+/*============================================================================
+| Note:  If SoftFloat is made available as a general library for programs to
+| use, it is strongly recommended that a platform-specific version of this
+| header, "softfloat.h", be created that folds in "softfloat_types.h" and that
+| eliminates all dependencies on compile-time macros.
+*============================================================================*/
+
+
+#ifndef softfloat_h
+#define softfloat_h 1
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "softfloat_types.h"
+
+#ifndef THREAD_LOCAL
+#define THREAD_LOCAL
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------
+| Default value for `softfloat_detectTininess'.
+*----------------------------------------------------------------------------*/
+#define init_detectTininess softfloat_tininess_afterRounding
+
+/*----------------------------------------------------------------------------
+| The values to return on conversions to 32-bit integer formats that raise an
+| invalid exception.
+*----------------------------------------------------------------------------*/
+#define ui32_fromPosOverflow 0xFFFFFFFF
+#define ui32_fromNegOverflow 0
+#define ui32_fromNaN         0xFFFFFFFF
+#define i32_fromPosOverflow  0x7FFFFFFF
+#define i32_fromNegOverflow  (-0x7FFFFFFF - 1)
+#define i32_fromNaN          0x7FFFFFFF
+
+/*----------------------------------------------------------------------------
+| The values to return on conversions to 64-bit integer formats that raise an
+| invalid exception.
+*----------------------------------------------------------------------------*/
+#define ui64_fromPosOverflow UINT64_C( 0xFFFFFFFFFFFFFFFF )
+#define ui64_fromNegOverflow 0
+#define ui64_fromNaN         UINT64_C( 0xFFFFFFFFFFFFFFFF )
+#define i64_fromPosOverflow  UINT64_C( 0x7FFFFFFFFFFFFFFF )
+#define i64_fromNegOverflow  (-UINT64_C( 0x7FFFFFFFFFFFFFFF ) - 1)
+#define i64_fromNaN          UINT64_C( 0x7FFFFFFFFFFFFFFF )
+
+/*----------------------------------------------------------------------------
+| "Common NaN" structure, used to transfer NaN representations from one format
+| to another.
+*----------------------------------------------------------------------------*/
+//struct commonNaN { char _unused; };
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 16-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF16UI 0x7E00
+
+/*----------------------------------------------------------------------------
+| Returns true when 16-bit unsigned integer `uiA' has the bit pattern of a
+| 16-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF16UI( uiA ) ((((uiA) & 0x7E00) == 0x7C00) && ((uiA) & 0x01FF))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 16-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f16UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & 0x0200) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 16-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF16UI( aPtr ) ((uint_fast16_t) defaultNaNF16UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 16-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast16_t
+ softfloat_propagateNaNF16UI( uint_fast16_t uiA, uint_fast16_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 32-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF32UI 0x7FC00000
+
+/*----------------------------------------------------------------------------
+| Returns true when 32-bit unsigned integer `uiA' has the bit pattern of a
+| 32-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF32UI( uiA ) ((((uiA) & 0x7FC00000) == 0x7F800000) && ((uiA) & 0x003FFFFF))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 32-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f32UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & 0x00400000) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 32-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF32UI( aPtr ) ((uint_fast32_t) defaultNaNF32UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 32-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast32_t
+ softfloat_propagateNaNF32UI( uint_fast32_t uiA, uint_fast32_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 64-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF64UI UINT64_C( 0x7FF8000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns true when 64-bit unsigned integer `uiA' has the bit pattern of a
+| 64-bit floating-point signaling NaN.
+| Note:  This macro evaluates its argument more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF64UI( uiA ) ((((uiA) & UINT64_C( 0x7FF8000000000000 )) == UINT64_C( 0x7FF0000000000000 )) && ((uiA) & UINT64_C( 0x0007FFFFFFFFFFFF )))
+
+/*----------------------------------------------------------------------------
+| Assuming `uiA' has the bit pattern of a 64-bit floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f64UIToCommonNaN( uiA, zPtr ) if ( ! ((uiA) & UINT64_C( 0x0008000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 64-bit floating-point
+| NaN, and returns the bit pattern of this value as an unsigned integer.
+*----------------------------------------------------------------------------*/
+#define softfloat_commonNaNToF64UI( aPtr ) ((uint_fast64_t) defaultNaNF64UI)
+
+/*----------------------------------------------------------------------------
+| Interpreting `uiA' and `uiB' as the bit patterns of two 64-bit floating-
+| point values, at least one of which is a NaN, returns the bit pattern of
+| the combined NaN result.  If either `uiA' or `uiB' has the pattern of a
+| signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+uint_fast64_t
+ softfloat_propagateNaNF64UI( uint_fast64_t uiA, uint_fast64_t uiB );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 80-bit extended floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNExtF80UI64 0x7FFF
+#define defaultNaNExtF80UI0  UINT64_C( 0xC000000000000000 )
+
+/*----------------------------------------------------------------------------
+| Returns true when the 80-bit unsigned integer formed from concatenating
+| 16-bit `uiA64' and 64-bit `uiA0' has the bit pattern of an 80-bit extended
+| floating-point signaling NaN.
+| Note:  This macro evaluates its arguments more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNExtF80UI( uiA64, uiA0 ) ((((uiA64) & 0x7FFF) == 0x7FFF) && ! ((uiA0) & UINT64_C( 0x4000000000000000 )) && ((uiA0) & UINT64_C( 0x3FFFFFFFFFFFFFFF )))
+
+#ifdef SOFTFLOAT_FAST_INT64
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when `SOFTFLOAT_FAST_INT64' is
+| defined.
+*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+| Assuming the unsigned integer formed from concatenating `uiA64' and `uiA0'
+| has the bit pattern of an 80-bit extended floating-point NaN, converts
+| this NaN to the common NaN form, and stores the resulting common NaN at the
+| location pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_extF80UIToCommonNaN( uiA64, uiA0, zPtr ) if ( ! ((uiA0) & UINT64_C( 0x4000000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into an 80-bit extended
+| floating-point NaN, and returns the bit pattern of this value as an unsigned
+| integer.
+*----------------------------------------------------------------------------*/
+//#if defined INLINE && ! defined softfloat_commonNaNToExtF80UI
+//INLINE
+//struct uint128 softfloat_commonNaNToExtF80UI( const struct commonNaN *aPtr )
+//{
+//    struct uint128 uiZ;
+//    uiZ.v64 = defaultNaNExtF80UI64;
+//    uiZ.v0  = defaultNaNExtF80UI0;
+//    return uiZ;
+//}
+//#else
+//struct uint128 softfloat_commonNaNToExtF80UI( const struct commonNaN *aPtr );
+//#endif
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as an 80-bit extended floating-point value, and likewise interpreting
+| the unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 80-bit extended floating-point value, and assuming at least on of these
+| floating-point values is a NaN, returns the bit pattern of the combined NaN
+| result.  If either original floating-point value is a signaling NaN, the
+| invalid exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNExtF80UI(
+     uint_fast16_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast16_t uiB64,
+     uint_fast64_t uiB0
+ );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 128-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF128UI64 UINT64_C( 0x7FFF800000000000 )
+#define defaultNaNF128UI0  UINT64_C( 0 )
+
+/*----------------------------------------------------------------------------
+| Returns true when the 128-bit unsigned integer formed from concatenating
+| 64-bit `uiA64' and 64-bit `uiA0' has the bit pattern of a 128-bit floating-
+| point signaling NaN.
+| Note:  This macro evaluates its arguments more than once.
+*----------------------------------------------------------------------------*/
+#define softfloat_isSigNaNF128UI( uiA64, uiA0 ) ((((uiA64) & UINT64_C( 0x7FFF800000000000 )) == UINT64_C( 0x7FFF000000000000 )) && ((uiA0) || ((uiA64) & UINT64_C( 0x00007FFFFFFFFFFF ))))
+
+/*----------------------------------------------------------------------------
+| Assuming the unsigned integer formed from concatenating `uiA64' and `uiA0'
+| has the bit pattern of a 128-bit floating-point NaN, converts this NaN to
+| the common NaN form, and stores the resulting common NaN at the location
+| pointed to by `zPtr'.  If the NaN is a signaling NaN, the invalid exception
+| is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_f128UIToCommonNaN( uiA64, uiA0, zPtr ) if ( ! ((uiA64) & UINT64_C( 0x0000800000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Interpreting the unsigned integer formed from concatenating `uiA64' and
+| `uiA0' as a 128-bit floating-point value, and likewise interpreting the
+| unsigned integer formed from concatenating `uiB64' and `uiB0' as another
+| 128-bit floating-point value, and assuming at least on of these floating-
+| point values is a NaN, returns the bit pattern of the combined NaN result.
+| If either original floating-point value is a signaling NaN, the invalid
+| exception is raised.
+*----------------------------------------------------------------------------*/
+struct uint128
+ softfloat_propagateNaNF128UI(
+     uint_fast64_t uiA64,
+     uint_fast64_t uiA0,
+     uint_fast64_t uiB64,
+     uint_fast64_t uiB0
+ );
+
+#else
+
+/*----------------------------------------------------------------------------
+| The following functions are needed only when `SOFTFLOAT_FAST_INT64' is not
+| defined.
+*----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+| Assuming the 80-bit extended floating-point value pointed to by `aSPtr' is
+| a NaN, converts this NaN to the common NaN form, and stores the resulting
+| common NaN at the location pointed to by `zPtr'.  If the NaN is a signaling
+| NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+#define softfloat_extF80MToCommonNaN( aSPtr, zPtr ) if ( ! ((aSPtr)->signif & UINT64_C( 0x4000000000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into an 80-bit extended
+| floating-point NaN, and stores this NaN at the location pointed to by
+| `zSPtr'.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToExtF80M
+INLINE
+void
+ softfloat_commonNaNToExtF80M(
+     const struct commonNaN *aPtr, struct extFloat80M *zSPtr )
+{
+    zSPtr->signExp = defaultNaNExtF80UI64;
+    zSPtr->signif  = defaultNaNExtF80UI0;
+}
+#else
+void
+ softfloat_commonNaNToExtF80M(
+     const struct commonNaN *aPtr, struct extFloat80M *zSPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Assuming at least one of the two 80-bit extended floating-point values
+| pointed to by `aSPtr' and `bSPtr' is a NaN, stores the combined NaN result
+| at the location pointed to by `zSPtr'.  If either original floating-point
+| value is a signaling NaN, the invalid exception is raised.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_propagateNaNExtF80M(
+     const struct extFloat80M *aSPtr,
+     const struct extFloat80M *bSPtr,
+     struct extFloat80M *zSPtr
+ );
+
+/*----------------------------------------------------------------------------
+| The bit pattern for a default generated 128-bit floating-point NaN.
+*----------------------------------------------------------------------------*/
+#define defaultNaNF128UI96 0x7FFF8000
+#define defaultNaNF128UI64 0
+#define defaultNaNF128UI32 0
+#define defaultNaNF128UI0  0
+
+/*----------------------------------------------------------------------------
+| Assuming the 128-bit floating-point value pointed to by `aWPtr' is a NaN,
+| converts this NaN to the common NaN form, and stores the resulting common
+| NaN at the location pointed to by `zPtr'.  If the NaN is a signaling NaN,
+| the invalid exception is raised.  Argument `aWPtr' points to an array of
+| four 32-bit elements that concatenate in the platform's normal endian order
+| to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+#define softfloat_f128MToCommonNaN( aWPtr, zPtr ) if ( ! ((aWPtr)[indexWordHi( 4 )] & UINT64_C( 0x0000800000000000 )) ) softfloat_raiseFlags( softfloat_flag_invalid )
+
+/*----------------------------------------------------------------------------
+| Converts the common NaN pointed to by `aPtr' into a 128-bit floating-point
+| NaN, and stores this NaN at the location pointed to by `zWPtr'.  Argument
+| `zWPtr' points to an array of four 32-bit elements that concatenate in the
+| platform's normal endian order to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+#if defined INLINE && ! defined softfloat_commonNaNToF128M
+INLINE
+void
+ softfloat_commonNaNToF128M( const struct commonNaN *aPtr, uint32_t *zWPtr )
+{
+    zWPtr[indexWord( 4, 3 )] = defaultNaNF128UI96;
+    zWPtr[indexWord( 4, 2 )] = defaultNaNF128UI64;
+    zWPtr[indexWord( 4, 1 )] = defaultNaNF128UI32;
+    zWPtr[indexWord( 4, 0 )] = defaultNaNF128UI0;
+}
+#else
+void
+ softfloat_commonNaNToF128M( const struct commonNaN *aPtr, uint32_t *zWPtr );
+#endif
+
+/*----------------------------------------------------------------------------
+| Assuming at least one of the two 128-bit floating-point values pointed to by
+| `aWPtr' and `bWPtr' is a NaN, stores the combined NaN result at the location
+| pointed to by `zWPtr'.  If either original floating-point value is a
+| signaling NaN, the invalid exception is raised.  Each of `aWPtr', `bWPtr',
+| and `zWPtr' points to an array of four 32-bit elements that concatenate in
+| the platform's normal endian order to form a 128-bit floating-point value.
+*----------------------------------------------------------------------------*/
+void
+ softfloat_propagateNaNF128M(
+     const uint32_t *aWPtr, const uint32_t *bWPtr, uint32_t *zWPtr );
+
+#endif
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+#include "platform.h"
+#include "primitiveTypes.h"
+
+#ifndef softfloat_add256M
+
+void
+ softfloat_add256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr );
+
+#endif
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_addCarryM
+
+uint_fast8_t
+ softfloat_addCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_addComplCarryM
+
+uint_fast8_t
+ softfloat_addComplCarryM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint_fast8_t carry,
+     uint32_t *zPtr
+ );
+
+#endif
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_addM
+
+void
+ softfloat_addM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ );
+
+#endif
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_approxRecip32_1
+
+extern const uint16_t softfloat_approxRecip_1k0s[16];
+extern const uint16_t softfloat_approxRecip_1k1s[16];
+
+uint32_t softfloat_approxRecip32_1( uint32_t a );
+
+#endif
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_approxRecipSqrt32_1
+
+extern const uint16_t softfloat_approxRecipSqrt_1k0s[];
+extern const uint16_t softfloat_approxRecipSqrt_1k1s[];
+
+uint32_t softfloat_approxRecipSqrt32_1( unsigned int oddExpA, uint32_t a );
+
+#endif
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_compare128M
+
+int_fast8_t softfloat_compare128M( const uint32_t *aPtr, const uint32_t *bPtr );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_compare96M
+
+int_fast8_t softfloat_compare96M( const uint32_t *aPtr, const uint32_t *bPtr );
+
+#endif
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_countLeadingZeros64
+
+#define softfloat_countLeadingZeros64 softfloat_countLeadingZeros64
+#include "primitives.h"
+
+uint_fast8_t softfloat_countLeadingZeros64( uint64_t a );
+
+#endif
+
+
+#include <stdbool.h>
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_mul128MTo256M
+
+void
+ softfloat_mul128MTo256M(
+     const uint32_t *aPtr, const uint32_t *bPtr, uint32_t *zPtr );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+void
+ softfloat_mul128To256M(
+     uint64_t a64, uint64_t a0, uint64_t b64, uint64_t b0, uint64_t *zPtr );
+
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_mul64To128
+
+struct uint128 softfloat_mul64To128( uint64_t a, uint64_t b );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#include <stdint.h>
+
+#ifndef softfloat_mul64To128M
+
+void softfloat_mul64To128M( uint64_t a, uint64_t b, uint32_t *zPtr );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_negXM
+
+void softfloat_negXM( uint_fast8_t size_words, uint32_t *zPtr );
+
+#endif
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_remStepMBy32
+
+void
+ softfloat_remStepMBy32(
+     uint_fast8_t size_words,
+     const uint32_t *remPtr,
+     uint_fast8_t dist,
+     const uint32_t *bPtr,
+     uint32_t q,
+     uint32_t *zPtr
+ );
+
+#endif
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_shiftRightJam128
+
+struct uint128
+ softfloat_shiftRightJam128( uint64_t a64, uint64_t a0, uint_fast32_t dist );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_shiftRightJam128Extra
+
+struct uint128_extra
+ softfloat_shiftRightJam128Extra(
+     uint64_t a64, uint64_t a0, uint64_t extra, uint_fast32_t dist );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_shiftRightJam256M
+
+static
+ void
+  softfloat_shortShiftRightJamM(
+      uint_fast8_t size_words,
+      const uint64_t *aPtr,
+      uint_fast8_t dist,
+      uint64_t *zPtr
+  )
+{
+    uint_fast8_t uNegDist;
+    unsigned int index, lastIndex;
+    uint64_t partWordZ, wordA;
+
+    uNegDist = -dist;
+    index = indexWordLo( size_words );
+    lastIndex = indexWordHi( size_words );
+    wordA = aPtr[index];
+    partWordZ = wordA>>dist;
+    if ( partWordZ<<dist != wordA ) partWordZ |= 1;
+    while ( index != lastIndex ) {
+        wordA = aPtr[index + wordIncr];
+        zPtr[index] = wordA<<(uNegDist & 63) | partWordZ;
+        index += wordIncr;
+        partWordZ = wordA>>dist;
+    }
+    zPtr[index] = partWordZ;
+
+}
+
+void
+ softfloat_shiftRightJam256M(
+     const uint64_t *aPtr, uint_fast32_t dist, uint64_t *zPtr );
+
+#endif
+
+
+
+
 
 /*============================================================================
 
-This C header file is part of the SoftFloat IEEE Floating-Point Arithmetic
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
 Package, Release 3d, by John R. Hauser.
 
-Copyright 2011, 2012, 2013, 2014, 2015, 2016, 2017 The Regents of the
-University of California.  All rights reserved.
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
@@ -34,28 +1276,250 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 =============================================================================*/
 
+#ifndef softfloat_shortShiftLeft64To96M
+
+void
+ softfloat_shortShiftLeft64To96M(
+     uint64_t a, uint_fast8_t dist, uint32_t *zPtr );
+
+#endif
+
+
 
 /*============================================================================
-| Note:  If SoftFloat is made available as a general library for programs to
-| use, it is strongly recommended that a platform-specific version of this
-| header, "softfloat.h", be created that folds in "softfloat_types.h" and that
-| eliminates all dependencies on compile-time macros.
-*============================================================================*/
 
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
 
-#ifndef softfloat_h
-#define softfloat_h 1
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
 
-#include <stdbool.h>
-#include <stdint.h>
-#include "softfloat_types.h"
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_shortShiftRightExtendM
+
+void
+ softfloat_shortShiftRightExtendM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ );
 
-#ifndef THREAD_LOCAL
-#define THREAD_LOCAL
 #endif
 
-#ifdef __cplusplus
-extern "C" {
+
+
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015, 2016 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_shortShiftRightM
+
+void
+ softfloat_shortShiftRightM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     uint_fast8_t dist,
+     uint32_t *zPtr
+ );
+
+#endif
+
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_sub1XM
+
+void softfloat_sub1XM( uint_fast8_t size_words, uint32_t *zPtr );
+
+#endif
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_sub256M
+
+void
+ softfloat_sub256M(
+     const uint64_t *aPtr, const uint64_t *bPtr, uint64_t *zPtr );
+
+#endif
+
+
+
+/*============================================================================
+
+This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
+Package, Release 3d, by John R. Hauser.
+
+Copyright 2011, 2012, 2013, 2014, 2015 The Regents of the University of
+California.  All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions, and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions, and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+
+ 3. Neither the name of the University nor the names of its contributors may
+    be used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+=============================================================================*/
+
+#ifndef softfloat_subM
+
+void
+ softfloat_subM(
+     uint_fast8_t size_words,
+     const uint32_t *aPtr,
+     const uint32_t *bPtr,
+     uint32_t *zPtr
+ );
+
 #endif
 
 /*----------------------------------------------------------------------------
@@ -71,6 +1535,8 @@ enum {
 | Software floating-point rounding mode.  (Mode "odd" is supported only if
 | SoftFloat is compiled with macro 'SOFTFLOAT_ROUND_ODD' defined.)
 *----------------------------------------------------------------------------*/
+//THREAD_LOCAL uint_fast8_t softfloat_roundingMode;
+
 extern THREAD_LOCAL uint_fast8_t softfloat_roundingMode;
 enum {
     softfloat_round_near_even   = 0,
@@ -143,10 +1609,13 @@ void i64_to_f128M( int64_t, float128_t * );
 *----------------------------------------------------------------------------*/
 uint_fast8_t f16_to_ui8( float16_t, uint_fast8_t, bool );
 uint_fast16_t f16_to_ui16( float16_t, uint_fast8_t, bool );
-uint_fast32_t f16_to_ui32( float16_t, uint_fast8_t, bool );
-uint_fast64_t f16_to_ui64( float16_t, uint_fast8_t, bool );
 int_fast8_t f16_to_i8( float16_t, uint_fast8_t, bool );
 int_fast16_t f16_to_i16( float16_t, uint_fast8_t, bool );
+uint_fast16_t f16_classify( float16_t );
+uint_fast16_t f32_to_ui16( float32_t, uint_fast8_t, bool );
+int_fast16_t f32_to_i16( float32_t, uint_fast8_t, bool );
+uint_fast32_t f16_to_ui32( float16_t, uint_fast8_t, bool );
+uint_fast64_t f16_to_ui64( float16_t, uint_fast8_t, bool );
 int_fast32_t f16_to_i32( float16_t, uint_fast8_t, bool );
 int_fast64_t f16_to_i64( float16_t, uint_fast8_t, bool );
 uint_fast32_t f16_to_ui32_r_minMag( float16_t, bool );
@@ -185,10 +1654,8 @@ float16_t f16_recip7( float16_t );
 /*----------------------------------------------------------------------------
 | 32-bit (single-precision) floating-point operations.
 *----------------------------------------------------------------------------*/
-uint_fast16_t f32_to_ui16( float32_t, uint_fast8_t, bool );
 uint_fast32_t f32_to_ui32( float32_t, uint_fast8_t, bool );
 uint_fast64_t f32_to_ui64( float32_t, uint_fast8_t, bool );
-int_fast16_t f32_to_i16( float32_t, uint_fast8_t, bool );
 int_fast32_t f32_to_i32( float32_t, uint_fast8_t, bool );
 int_fast64_t f32_to_i64( float32_t, uint_fast8_t, bool );
 uint_fast32_t f32_to_ui32_r_minMag( float32_t, bool );
diff --git a/spike_main/handcar_cosim_wrapper.h b/spike_main/handcar_cosim_wrapper.h
new file mode 100644
index 00000000..9ea6df2f
--- /dev/null
+++ b/spike_main/handcar_cosim_wrapper.h
@@ -0,0 +1,306 @@
+//
+// Copyright (C) [2020] Futurewei Technologies, Inc.
+//
+// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the License);
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
+// FIT FOR A PARTICULAR PURPOSE.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#ifndef __WRAPPER_H__
+#define __WRAPPER_H__
+#include <stdint.h>
+#include <string.h>
+
+#ifdef __cplusplus
+#include <string>
+extern "C" {
+#endif
+
+// get_simulator_version function: write the simulator version into the supplied string buffer
+//
+// inputs:
+//      char* version -- pointer to the string buffer for writing the version information, should be managed by the caller
+// outputs:
+//      char* version -- version information gets written to this buffer
+// return:
+//      0 -- success
+//      1 -- something went wrong like the buffer was not large enough
+int get_simulator_version(char* version);
+
+// set_simulator_parameter function: set simulator value or path options before initialization
+// inputs:
+//     const char* name: string identifier of parameter to be modified
+//     const uint64_t* value: pointer to the numeric value up to 64 bits, if any, that the parameter should be set to
+//     const char* path: some parameters are filepaths, if this is the case that information is specified with this argument
+//
+// return values:
+//     SUCCESS = 0,
+//     NAME_NOT_FOUND = 1, (name was spelled incorrectly or option is not available)
+//     VAL_IS_NULL = 2, (even though the option requires a value argument)
+//     PATH_IS_NULL = 3, (even though the option requires a path / string argument)
+//     NAME_IS_NULL = 4 (all options must be specified by name)
+//     10 (Indicates that initialize_simulator was called before set_simulator_parameter, this isn't allowed)
+//
+// notes:
+//     See handcar API test program source to understand how to sequence calls to set_simulator_parameter.
+//
+int set_simulator_parameter(const char* name, const uint64_t* value, const char* path);
+
+// initialize_simulator function: Initial resource allocation and construction of functional simulator related objects.
+//
+// warning: must be called in order to use API
+//
+// inputs:
+//     const char* options, space separated string where options are specified, follows the usage as in Spike
+//
+void initialize_simulator(const char* options);
+
+// terminate_simulator function: free simulator resources.
+//
+// warning:
+//     must be called manually when through with functional simulation
+//
+void terminate_simulator();
+
+// simulator_load_elf function: load the contents of an elf file into the memory model, target_id is ignored for now
+//
+// warning:
+//     MUST be called after simulator is initialized and before any calls step the simulator.
+//
+//     target_id is ignored. PMA / PMP per hart and interaction with memory model needs to be looked into especially before MP use.
+//
+//     Underlying Spike code will throw a runtime exception if elf_path cannot be resolved and opened.
+//
+// inputs:
+//     int target_id, inert, placeholder for future functionality
+//     const char* elf_path, host filepath where ELF file to load may be found
+//
+// returns:
+//     0 means success,
+//     1 means failure
+//
+int simulator_load_elf(int target_id, const char* elf_path);
+
+// For development purposes only, will only dump sparse memory in the future when the dense model is no longer required for reference.
+//
+//
+void dump_memory(const char* file_to_create);
+
+// step_simulator function: step the simulation forward num_steps instructions on the target_id hart
+//
+// inputs:
+//     int target_id, which hardware tread to step
+//     int num_steps, how many instructions for the chosen hardware thread to perform
+//     int stx_failed, unspecified requested api parameter, does nothing currently
+//
+// returns:
+//     0 indicates the requested steps completed sucessfully,
+//     1 indicates failure
+//
+int step_simulator(int target_id, int num_steps, int stx_failed);
+
+// get_disassembly function: for the given pc address, populates the information in the preallocated opcode and disassemby string buffers.
+//
+// warning:
+//     the caller has responsibility over allocating and managing the memory for the strings.
+//
+// inputs:
+//     const uint64_t* pc, given for some reason as a constant pointer (as requested for the API), dereferenced to obtain the pc address
+//     char** opcode, pointer to an allocated string buffer
+//     char** disassembly, pointer to an allocated string buffer
+//
+//  outputs:
+//      opcode, copys the opcode information as a hex string to opcode
+//      disassembly, copys the disassembly text to disassembly
+//
+//  returns:
+//      0 success,
+//      2 could not complete because either no processors were instantiated or no allocated opcode or disassembly string buffers were provided
+//
+int get_disassembly(const uint64_t* pPc, char** pOpcode, char** pDisassembly);
+int get_disassembly_for_target(int target_id, const uint64_t* pPc, char** pOpcode, char** pDisassembly);
+
+// read_simulator_memory function: for the given target_id and physical address addr and length, writes the contents of the relevant memory address into the provided data buffer
+//
+// inputs:
+//      int target_id -- refers to the processor id
+//      const uint64_t* addr -- refers to the physical address
+//      const int* length -- the number of bytes to read from memory and copy into data
+//      uint8_t* -- buffer for memory data to be copied into, is expected to be managed by the caller
+//
+//  outputs:
+//      uint8_t* data -- buffer where the memory data requested is copied into
+//
+//  returns:
+//      0 -- success
+//      1 -- one or more of the pointer arguments to the function are null
+//      2 -- the data buffer is the wrong size for the requested read
+//      3 -- other failure
+int read_simulator_memory(int target_id, const uint64_t* addr, int length, uint8_t* data);
+
+// write_simulator_memory function: for the given target_id and physical address addr and length, copy the provided data buffer into the memory model
+//
+// inputs:
+//     int target_id -- refers to the processor id
+//     const uint64_t* addr -- refers to the physical address
+//     int length -- refers to the number of bytes to be copied from the data buffer into the memory model
+//     const uint8_t* data -- the data buffer with contents to be copied into the memory model
+//
+//  side effects:
+//     alters the state of the memory model by modifying or initializing its contents
+//
+//  returns:
+//     0 -- success
+//     1 -- one or more pointer arguments to the function call are null
+//     2 -- the advertised length of the data buffer is negative or greater than 8
+//     3 -- other failure
+int write_simulator_memory(int target_id, const uint64_t* addr, int length, const uint8_t* data);
+
+// This API was added to facilitate tests of the other APIs listed here.
+int initialize_simulator_memory(int target_id, const uint64_t* addr, int length, uint64_t data);
+
+// read_simulator_register function: for the given target_id, register category and register index supply the associated register_name, value and length in bytes
+//
+//  inputs:
+//      int target_id -- the processor id
+//      const char* pRegName -- should be an allocated pointer to a character buffer sufficient to hold any relevant register name
+//      uint8_t* value -- the buffer for byte string representing the numeric value of the requested register. Management is the responsibility of the caller
+//      int length -- the length of the buffer the user provides to the API
+//
+//  outputs:
+//      uint8_t* value -- value is written with the numeric data stored in the requested register
+//
+//  returns:
+//      0 -- success
+//      1 -- one or more of the pointer arguments is null
+//      2 -- target_id was outside the the expected range given the number of processors being simulated
+//      3 -- the register category and index combination could not be mapped to a register
+//      4 -- the advertised length of the value buffer was too short
+//
+int read_simulator_register(int target_id, const char* pRegName, uint8_t* value, int length);
+
+//  inputs:
+//
+//  outputs:
+//
+//  returns:
+//      0
+int partial_read_large_register(int target_id, const char* pRegName, uint8_t* pValue, uint32_t length, uint32_t offset);
+
+//  inputs:
+//
+//  outputs:
+//
+//  returns:
+//      0
+int partial_write_large_register(int target_id, const char* pRegName, const uint8_t* pValue, uint32_t length, uint32_t offset);
+
+// read_simulator_register_fpix function: for the given target_id, register name supply the value and bit mask
+//
+//  inputs:
+//      int target_id -- the processor id
+//      const char* registerName -- name of the register for lookup in the simulator
+//      uint64_t* value -- the buffer for byte string representing the numeric value of the requested register.
+//      uint64_t* mask -- high bits are relevant parts of the returned value
+//
+//  outputs:
+//      uint64_t* value -- the data contents fo the register
+//      uint64_t* mask -- indicates which bits to pay attention to in the returned value result
+//
+//  returns:
+//      0 -- success
+//      1 -- one or more of the pointer arguments is null
+//      2 -- the provided register name could not be mapped to a register in the simulator
+//      3 -- other failure
+//
+int read_simulator_register_fpix(uint32_t target_id, const char* registerName, uint64_t* value, uint64_t* mask);
+
+// write_simulator_register function: for the given target_id, pRegName write the supplied reg_data of length num bytes into the corresponding simulator register
+//
+//  inputs:
+//      int target_id -- refers to the processor id
+//      const char* pRegName -- refers to the registers architectural name (not the programmers name) and ordinal
+//      const uint8_t* data -- the data buffer to be copied into the specified register
+//      int length -- the number of bytes to be copied into the specified register
+//
+//  side effects:
+//      modifies the value of the speficied register in the simulator
+//
+//  returns:
+//      0 -- success
+//      1 -- one or more of the pointer arguments to this function are null
+//      2 -- the input data buffer is too small for the specified length
+//      3 -- the provided register name could not be mapped to a register in the simulator
+//      4 -- the advertised length of the data buffer did not match the length of the target register
+//      5 -- readback with 'getter' method after write with 'setter' method shows a mismatch
+//
+int write_simulator_register(int target_id, const char* pRegName, const uint8_t* data, int length);
+
+// write_simulator_register_fpix function: for the given target_id, pRegName write the supplied reg_data of length num bytes into the corresponding simulator register
+//
+//  inputs:
+//      int target_id -- refers to the processor id
+//      const char* registerName -- refers to the register's name as in Spike code, usually the programmer name
+//      uint64_t value -- the buffer for byte string representing the numeric value of the requested register.
+//      uint64_t mask -- high bits are relevant parts of the supplied value
+//
+//  side effects:
+//      modifies the value of the speficied register in the simulator
+//
+//  returns:
+//      0 -- success
+//      1 -- one or more of the pointer arguments to this function are null
+//      2 -- the provided register name could not be mapped to a register in the simulator
+//      3 -- other failure
+//
+int write_simulator_register_fpix( uint32_t target_id, const char* registerName, uint64_t value, uint64_t mask);
+
+bool inject_simulator_events(uint32_t cpuid, uint32_t events){return false;} //!< inject events into simulator
+
+// translate_virtual_address function: given a target_id(procid), virtual address, intent attempt to translate that address into a physical address and load the relevant PMP information into memattrs
+//
+// meaning of 'intent':
+//   0 - indicates a 'LOAD' access
+//   1 - indicates a 'STORE' access
+//   2 - indicates a 'FETCH' access
+//
+// returns:
+//   0 - success
+//   1 - some pointer arguments were null
+//   2 - invalid procid
+//   3 - PMP problem with PA after address translation somehow
+//   4 - access exception while trying to check pmp status of page table entry PA
+//   5 - walk was unsuccessful and access type was FETCH
+//   6 - walk was unsuccessful and access type was LOAD
+//   7 - walk was unsuccessful and access type was STORE
+//   8 - walk was unsuccessful and access type was not any of the above
+//
+int translate_virtual_address(int target_id, const uint64_t* vaddr, int intent, uint64_t* paddr, uint64_t* memattrs);
+
+//The following "update" method declarations are here to remind the user what callback methods are expected to be present in the code that uses the cosim API.
+//In order to disable the requirement, just append "{}" before the ";" symbols.
+//
+// inputs:
+//  uint32_t cpuid : the id of the core from which the register update is being received.
+//  const char *pRegName : the name of the logical register in which the element belongs.
+//  uint32_t vecRegIndex : the index of the vector register, somewhat redundant with name.
+//  uint32_t eltByteWidth : the byte width of the element, important because this can change during runtime.
+//  const uint8_t* pValue : whenever access type is read, this points to the entire data content of the whole vector register not just an element.
+//  uint32_t byteLength : the number of bytes that pValue points to.
+//  const char* pAccessType : should be either "read" or "write".
+void update_vector_element(uint32_t cpuid, const char *pRegName, uint32_t vecRegIndex, uint32_t eltIndex, uint32_t eltByteWidth, const uint8_t* pValue, uint32_t  byteLength, const char* pAccessType);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
+
diff --git a/spike_main/spike.cc b/spike_main/spike.cc
index ac45fbf7..b745c782 100644
--- a/spike_main/spike.cc
+++ b/spike_main/spike.cc
@@ -1,8 +1,6 @@
-// See LICENSE for license details.
-
+#include "handcar_cosim_wrapper.h"
 #include "sim.h"
 #include "mmu.h"
-#include "remote_bitbang.h"
 #include "cachesim.h"
 #include "extension.h"
 #include <dlfcn.h>
@@ -12,203 +10,532 @@
 #include <vector>
 #include <string>
 #include <memory>
+#include <map>
+#include <numeric>
 #include <fstream>
-#include "../VERSION"
+#include <iostream>
+#include <ios>
+#include <iomanip>
 
-static void help(int exit_code = 1)
-{
-  fprintf(stderr, "Spike RISC-V ISA Simulator " SPIKE_VERSION "\n\n");
-  fprintf(stderr, "usage: spike [host options] <target program> [target options]\n");
-  fprintf(stderr, "Host Options:\n");
-  fprintf(stderr, "  -p<n>                 Simulate <n> processors [default 1]\n");
-  fprintf(stderr, "  -m<n>                 Provide <n> MiB of target memory [default 2048]\n");
-  fprintf(stderr, "  -m<a:m,b:n,...>       Provide memory regions of size m and n bytes\n");
-  fprintf(stderr, "                          at base addresses a and b (with 4 KiB alignment)\n");
-  fprintf(stderr, "  -d                    Interactive debug mode\n");
-  fprintf(stderr, "  -g                    Track histogram of PCs\n");
-  fprintf(stderr, "  -l                    Generate a log of execution\n");
-#ifdef HAVE_BOOST_ASIO
-  fprintf(stderr, "  -s                    Command I/O via socket (use with -d)\n");
-#endif
-  fprintf(stderr, "  -h, --help            Print this help message\n");
-  fprintf(stderr, "  -H                    Start halted, allowing a debugger to connect\n");
-  fprintf(stderr, "  --log=<name>          File name for option -l\n");
-  fprintf(stderr, "  --debug-cmd=<name>    Read commands from file (use with -d)\n");
-  fprintf(stderr, "  --isa=<name>          RISC-V ISA string [default %s]\n", DEFAULT_ISA);
-  fprintf(stderr, "  --priv=<m|mu|msu>     RISC-V privilege modes supported [default %s]\n", DEFAULT_PRIV);
-  fprintf(stderr, "  --varch=<name>        RISC-V Vector uArch string [default %s]\n", DEFAULT_VARCH);
-  fprintf(stderr, "  --pc=<address>        Override ELF entry point\n");
-  fprintf(stderr, "  --hartids=<a,b,...>   Explicitly specify hartids, default is 0,1,...\n");
-  fprintf(stderr, "  --ic=<S>:<W>:<B>      Instantiate a cache model with S sets,\n");
-  fprintf(stderr, "  --dc=<S>:<W>:<B>        W ways, and B-byte blocks (with S and\n");
-  fprintf(stderr, "  --l2=<S>:<W>:<B>        B both powers of 2).\n");
-  fprintf(stderr, "  --device=<P,B,A>      Attach MMIO plugin device from an --extlib library\n");
-  fprintf(stderr, "                          P -- Name of the MMIO plugin\n");
-  fprintf(stderr, "                          B -- Base memory address of the device\n");
-  fprintf(stderr, "                          A -- String arguments to pass to the plugin\n");
-  fprintf(stderr, "                          This flag can be used multiple times.\n");
-  fprintf(stderr, "                          The extlib flag for the library must come first.\n");
-  fprintf(stderr, "  --log-cache-miss      Generate a log of cache miss\n");
-  fprintf(stderr, "  --extension=<name>    Specify RoCC Extension\n");
-  fprintf(stderr, "                          This flag can be used multiple times.\n");
-  fprintf(stderr, "  --extlib=<name>       Shared library to load\n");
-  fprintf(stderr, "                        This flag can be used multiple times.\n");
-  fprintf(stderr, "  --rbb-port=<port>     Listen on <port> for remote bitbang connection\n");
-  fprintf(stderr, "  --dump-dts            Print device tree string and exit\n");
-  fprintf(stderr, "  --disable-dtb         Don't write the device tree blob into memory\n");
-  fprintf(stderr, "  --kernel=<path>       Load kernel flat image into memory\n");
-  fprintf(stderr, "  --initrd=<path>       Load kernel initrd into memory\n");
-  fprintf(stderr, "  --bootargs=<args>     Provide custom bootargs for kernel [default: console=hvc0 earlycon=sbi]\n");
-  fprintf(stderr, "  --real-time-clint     Increment clint time at real-time rate\n");
-  fprintf(stderr, "  --dm-progsize=<words> Progsize for the debug module [default 2]\n");
-  fprintf(stderr, "  --dm-sba=<bits>       Debug bus master supports up to "
-      "<bits> wide accesses [default 0]\n");
-  fprintf(stderr, "  --dm-auth             Debug module requires debugger to authenticate\n");
-  fprintf(stderr, "  --dmi-rti=<n>         Number of Run-Test/Idle cycles "
-      "required for a DMI access [default 0]\n");
-  fprintf(stderr, "  --dm-abstract-rti=<n> Number of Run-Test/Idle cycles "
-      "required for an abstract command to execute [default 0]\n");
-  fprintf(stderr, "  --dm-no-hasel         Debug module supports hasel\n");
-  fprintf(stderr, "  --dm-no-abstract-csr  Debug module won't support abstract to authenticate\n");
-  fprintf(stderr, "  --dm-no-halt-groups   Debug module won't support halt groups\n");
-  fprintf(stderr, "  --dm-no-impebreak     Debug module won't support implicit ebreak in program buffer\n");
-
-  exit(exit_code);
-}
+#include <cstring> 
 
-static void suggest_help()
-{
-  fprintf(stderr, "Try 'spike --help' for more information.\n");
-  exit(1);
-}
+//For fooling input arguments
+#include <string.h>
 
-static bool check_file_exists(const char *fileName)
-{
-  std::ifstream infile(fileName);
-  return infile.good();
-}
+//controls
+#define ARGV_ELEMENT_BUFFER_SIZE 128 // The number of characters in --<option_name>=<argment> for a particular option
+#define NOISY true
 
-static std::ifstream::pos_type get_file_size(const char *filename)
-{
-  std::ifstream in(filename, std::ios::ate | std::ios::binary);
-  return in.tellg();
-}
+//To manage the lifecycle of the simulator objects for library use, and to keep stack memory use to a minimum. pointers are manually managed.
+simlib_t* _pSimulatorTopLevel = nullptr;
+icache_sim_t* ic = nullptr;
+dcache_sim_t* dc = nullptr;
+cache_sim_t* l2 = nullptr;
+//std::function<extension_t*()> extension;
 
-static void read_file_bytes(const char *filename,size_t fileoff,
-                            mem_t* mem, size_t memoff, size_t read_sz)
+//Persistent options class and support, designed to keep consistency with Spike's existing options
+//Options storage manages the setting and retrieval of options stored as OptionsPrimitives
+class OptionsStorage
 {
-  std::ifstream in(filename, std::ios::in | std::ios::binary);
-  in.seekg(fileoff, std::ios::beg);
+  //OptionsPrimitive is a record type used to store the definition of an option as well as its settings either default or after user modification.
+  struct OptionsPrimitive
+  {
+    bool mIsUsed;
+    char mShortName;
+    std::string mLongName;
+    bool mNeedsVal;
+    bool mNeedsPath;
+    uint64_t mVal;
+    std::string mPath;
+  };
 
-  std::vector<char> read_buf(read_sz, 0);
-  in.read(&read_buf[0], read_sz);
-  mem->store(memoff, read_sz, (uint8_t*)&read_buf[0]);
-}
+  enum DESCRIPTIVE_INITIALIZATION_VALUES : bool
+  {
+    NEEDS_VAL = true,
+    NEEDS_PATH = true,
+    USED = true,
+    UNUSED = false
+  };
 
-bool sort_mem_region(const std::pair<reg_t, mem_t*> &a,
-                       const std::pair<reg_t, mem_t*> &b)
-{
-  if (a.first == b.first)
-    return (a.second->size() < b.second->size());
-  else
-    return (a.first < b.first);
-}
+  enum ERROR_CODES : int
+  {
+    SUCCESS = 0,
+    NAME_NOT_FOUND = 1,
+    VAL_IS_NULL = 2,
+    PATH_IS_NULL = 3,
+    NAME_IS_NULL = 4,
+    ARGV_MEMORY_ERROR = 5
+  };
 
-void merge_overlapping_memory_regions(std::vector<std::pair<reg_t, mem_t*>>& mems)
-{
-  // check the user specified memory regions and merge the overlapping or
-  // eliminate the containing parts
-  std::sort(mems.begin(), mems.end(), sort_mem_region);
-  std::vector<std::pair<reg_t, mem_t*>>::iterator it = mems.begin() + 1;
-
-  while (it != mems.end()) {
-    reg_t start = prev(it)->first;
-    reg_t end = prev(it)->first + prev(it)->second->size();
-    reg_t start2 = it->first;
-    reg_t end2 = it->first + it->second->size();
-
-    //contains -> remove
-    if (start2 >= start && end2 <= end) {
-      it = mems.erase(it);
-    //parital overlapped -> extend
-    } else if (start2 >= start && start2 < end) {
-      delete prev(it)->second;
-      prev(it)->second = new mem_t(std::max(end, end2) - start);
-      it = mems.erase(it);
-    // no overlapping -> keep it
-    } else {
-      it++;
+  std::string _flat_options; // temporary storage of a space separated options string following the format of a command line argument given to Spike original executable.
+  char** _stored_argv; // options reformatted into an argument vector suitable for input to Spike's original input parsing code.
+  int _stored_argc; // number of elements in the argument vector _stored_argv.
+  std::map<std::string, OptionsPrimitive> _options_map; // used to support calls to set_simulator_parameter, used to encode option vocabulary, argument requirements and which options are enabled.  
+  std::vector<std::string> _token_vector; // buffer to store parsed argument vector elements, used to support when initialize_simulator is called with a non-null char* input and set_simulator_parameter is not used.
+  
+  // _allocateDummyOptions function: the class has a few execution pathways, all of which require that the setting of the first and last elements of _stored_argv to some dummy values
+  //
+  // inputs:
+  //    _stored_argc (implicit), needs to be up to date with regards to number of elements in _stored_argv
+  //    _stored_argc (implicit), needs at least two element slots 
+  //
+  // outputs:
+  //    _stored_argv (implicit), allocates and sets the values of the first and last elements of _stored_argv
+  void _allocateDummyOptions()
+  {
+    // Allocate the elements of argv starting first with with first and last, which are dummy arguments.
+    _stored_argv[0] = (char*)malloc(20 * sizeof(char));
+    _stored_argv[_stored_argc-1] = (char*)malloc(20 * sizeof(char));
+    const char arg1[] = "handcar_cosim\0";
+    const char arg2[] = "no_elf\0";
+    memcpy(_stored_argv[0], arg1, strlen(arg1)+1);
+    memcpy(_stored_argv[_stored_argc-1], arg2, strlen(arg2)+1);
+  }
+
+  
+  // _unpackFlatOptions function: takes a space separated options string, formatted as it would be for command line arguments for the Spike original executable, 
+  //    and recomposes it into an argument vector so that spike argument parsing code can work exactly as it was designed to work. 
+  //    This is needed because Verilog does not have a char** equivalent type and the philosphopy of this adaptation is to change as little of Spike as necessary.
+  //
+  // inputs:
+  //   _flat_options (implicit)
+  //
+  // outputs:
+  //   _token_vector (implicit)
+  //
+  void _unpackFlatOptions()
+  {
+    if(_flat_options == "")
+    {    
+      if(NOISY)
+      {
+        printf("### handcar_cosim::OptionsStorage::_unpackFlatOptions(): No options specified.\n");
+      }
+      return;
+    }
+
+    size_t pos = 0;
+    std::string inter_argument_delimeter = " ";
+    std::string token;
+    std::string flat_options_temp = _flat_options;
+
+    // Using a ' ' as a delimeter, break the options string into tokens and save those tokens into _token_vector
+    while((pos = flat_options_temp.find(inter_argument_delimeter)) != std::string::npos)
+    {
+      token = flat_options_temp.substr(0, pos);
+      flat_options_temp = flat_options_temp.substr(pos + inter_argument_delimeter.length());   
+      
+      // all cases we ultimately leave to the original Spike code to validate
+      _token_vector.push_back(token);
+    }
+    // Handle the case that there is just a single option, or a single option left.
+    if(flat_options_temp.size() > 0)
+    {
+      _token_vector.push_back(flat_options_temp);
     }
   }
-}
 
-static std::vector<std::pair<reg_t, mem_t*>> make_mems(const char* arg)
-{
-  // handle legacy mem argument
-  char* p;
-  auto mb = strtoull(arg, &p, 0);
-  if (*p == 0) {
-    reg_t size = reg_t(mb) << 20;
-    if (size != (size_t)size)
-      throw std::runtime_error("Size would overflow size_t");
-    return std::vector<std::pair<reg_t, mem_t*>>(1, std::make_pair(reg_t(DRAM_BASE), new mem_t(size)));
-  }
-
-  // handle base/size tuples
-  std::vector<std::pair<reg_t, mem_t*>> res;
-  while (true) {
-    auto base = strtoull(arg, &p, 0);
-    if (!*p || *p != ':')
-      help();
-    auto size = strtoull(p + 1, &p, 0);
-
-    // page-align base and size
-    auto base0 = base, size0 = size;
-    size += base0 % PGSIZE;
-    base -= base0 % PGSIZE;
-    if (size % PGSIZE != 0)
-      size += PGSIZE - size % PGSIZE;
-
-    if (base + size < base)
-      help();
-
-    if (size != size0) {
-      fprintf(stderr, "Warning: the memory at  [0x%llX, 0x%llX] has been realigned\n"
-                      "to the %ld KiB page size: [0x%llX, 0x%llX]\n",
-              base0, base0 + size0 - 1, long(PGSIZE / 1024), base, base + size - 1);
-    }
-
-    res.push_back(std::make_pair(reg_t(base), new mem_t(size)));
-    if (!*p)
-      break;
-    if (*p != ',')
-      help();
-    arg = p + 1;
+
+  // _rejectOrEnroll function: looks up an option by name from the _options_map and determines if the right types of arguments have been provided. If so, the option is enabled and the argument is stored.
+  //
+  // inputs:
+  //   name, the keyname for the option, follows the name used by Spike originally, must not have '-' or '--' prefixes. 
+  //   pValue, if the option takes a numeric argument, this pointer should not be null
+  //   path, if the option takes any kind of string argument such as a comma-separated list, the path pointer should not be null
+  //
+  // outputs:
+  //  _options_map (implicit), USED field and arguements fields are updated for enabled options
+  //
+  // returns:  
+  //   returns error codes to indicate the nature of a deficiency or success status
+  //   NAME_IS_NULL, VAL_IS_NULL, PATH_IS_NULL and SUCCESS     
+  //
+  //   _options_map (implicit), if an option is correctly specified the _options_map will be updated
+  //
+  // note: friendship is used to allow set_simulator_parameter to call this function. 
+  //     Options cannot be de-activated once set, but they can be re-specified.
+  //
+  int _rejectOrEnroll(const char* name, const uint64_t* pValue, const char* path)
+  {
+    if(name == nullptr)
+    {
+      if(NOISY)
+      {
+        printf("### handcar_cosim::OptionsStorage::_rejectOrEnroll, null option name.\n");
+      }
+      return NAME_IS_NULL;
+    }
+
+    //Is this option part of the known vocabulary?
+    auto map_item = _options_map.find(name);
+    if(map_item == _options_map.end())
+    {
+      if(NOISY)
+      {
+         printf("### handcar_cosim::OptionsStorage::_rejectOrEnroll, cannot find option '%s'.\n", name);
+      }
+      return NAME_NOT_FOUND;
+    }
+
+    if(map_item->second.mNeedsVal)
+    {
+      if(pValue == nullptr)
+      {
+        if(NOISY)
+        {
+          printf("### handcar_cosim::OptionsStorage_rejectOrEnroll, numeric value for option %s is needed, but is null.\n", name);
+        }
+        return VAL_IS_NULL;
+      }
+      else
+      {
+        map_item->second.mVal = *pValue;
+      }
+    }
+
+    if(map_item->second.mNeedsPath)
+    {
+      if(path == nullptr)
+      {
+        if(NOISY)
+        {
+          printf("### handcar_cosim::OptionsStorage_rejectOrEnroll, path / string for option %s is needed, but is null.\n", name);
+        }
+        return PATH_IS_NULL;
+      }
+      else
+      {
+        map_item->second.mPath = path;
+      }
+    }
+
+    // Set the option as USED in the map only after all the sanity checks have passed.
+    map_item->second.mIsUsed = true;
+
+    return  SUCCESS;
   }
 
-  merge_overlapping_memory_regions(res);
-  return res;
-}
 
-static unsigned long atoul_safe(const char* s)
-{
-  char* e;
-  auto res = strtoul(s, &e, 10);
-  if (*e)
-    help();
-  return res;
-}
+  // _resetArgMatrix function: clears the memory allocated to char** _stored_argv, uses count of number of enabled options to resize char** _stored_argv. 
+  //               Then, memory is allocated for the elements and the first and last elements are set to dummy arguements.
+  //
+  // inputs:
+  //    _options_map (implicit), scanned to accumulate a count of the number of options that are 'USED'
+  //
+  // outputs:
+  //    _stored_argv (implicit), contains formatted options equivalent to what Spike original main would have seen with the same options reqested
+  //    _stored_argc (implicit), indicates the number of elements in _stored_argv
+  //
+  // returns:
+  //    Error codes:
+  //    ARGV_MEMORY_ERROR if _stored_argv cannot be allocated
+  //    SUCCESS if everything proceeded ok
+  //
+  // notes:
+  //    allocates a fixed amount of memory for each of the argument vector elements, ARGV_ELEMENT_BUFFER_SIZE characters of memory. This might be insufficient for extremely long file-paths. 
+  //    128 characters: 11111111222222223333333344444444555555556666666677777777888888881111111122222222333333334444444455555555666666667777777788888888
+  //
+  //    needs to be called after a group of calls to enrollOrReject, not needed if the const char* constructor was used.
+  int _resetArgMatrix()
+  {
+    // Wipe out the old data in _stored_argv and its elements
+    for(int arg_num = 0; arg_num < _stored_argc; ++arg_num)
+    {
+      free(_stored_argv[arg_num]);
+      _stored_argv[arg_num] = nullptr;
+    }
+    free(_stored_argv);
+    _stored_argv = nullptr;    
+    _stored_argc = 0;
+
+    // lambda function to for counting number of options to set so that the argv can be resized
+    auto add_one_if_used = [](int count, const std::pair<std::string, OptionsPrimitive>& option_record)
+    {
+      if(option_record.second.mIsUsed)
+        return ++count;
+      else
+        return count; 
+    };
+    int num_options_used = 2 + std::accumulate(_options_map.begin(), _options_map.end(), int(0), add_one_if_used); 
+
+    // We added two entries for the first and last arguments which are dummies: the host executable name and a placehold for the ELF name. 
+    // The ELF file is dealt with by a totally different API function than set_simlator_parameter, so we just set a dummy vlaue here for now.
+
+    // Allocate argv
+    _stored_argv = (char **)malloc(num_options_used * sizeof(char*));
+    if(_stored_argv == nullptr)
+    {
+      if(NOISY)
+      {
+        printf("### handcar_cosim::OptionsStorage::_resetArgMatrix, unable to allocate _stored_argv.\n");
+      }
+      return ARGV_MEMORY_ERROR;
+    }
+    else
+    {
+      _stored_argc = num_options_used;
+    }
+
+    // Allocate the elements of argv starting first with with first and last, which are dummy arguments.
+    _allocateDummyOptions();
+
+    for(int arg_num = 1; arg_num < (_stored_argc-1); ++arg_num)
+    {
+      _stored_argv[arg_num] = (char*)malloc(ARGV_ELEMENT_BUFFER_SIZE * sizeof(char));  
+    }
+      
+    return SUCCESS;    
+  }
+
+
+  // _loadArgMatrix function: once memory has been allocated for char** _stored_argv, scan the _options_map for enabled options and write them into the argv. 
+  //
+  // inputs:
+  //    _options_map (implicit), read to determine what to put into the _stored_argv array.
+  //
+  // outputs:
+  //    _stored_argv (implicit), enabled options are re-encoded and written into the memory allocated for them.
+  //
+  // returns:
+  //    Error codes:
+  //    ARGV_MEMORY_ERROR if an option token cannot be written into the _stored_argv
+  //    SUCCESS if everything proceeded ok
+  //
+  // Needs to be called after _resetArgMatrix
+  int _loadArgMatrix()
+  {
+    // we start the arg_num at 1 because 0 is reserved for a dummy argument
+    int arg_num = 1;
+    for(const auto& map_item : _options_map) // we should have called resetArgMatric alread so that we already know know much room we need for the used options in this map.
+    {
+      if(map_item.second.mIsUsed)
+      {
+        std::string temp("");
+
+        // Spike options are short only or long only, except for help, which of those is this one?
+        if(map_item.second.mShortName == '0')
+        {
+          temp += ("--");
+          temp += map_item.second.mLongName;
+          if(map_item.second.mNeedsVal || map_item.second.mNeedsPath)
+          {
+            temp += "=";      
+          }
+        }
+        else
+        {
+          temp += "-";
+          temp += map_item.first;
+        }
+
+        // Spike options sometimes take single scalar numeric values, but most of them take a string, and some of them take no argument; which case is it here?
+        if(map_item.second.mNeedsVal)
+        {
+          temp += std::to_string(map_item.second.mVal);
+        }
+        else if(map_item.second.mNeedsPath)
+        {
+          temp += map_item.second.mPath;
+        }
+        
+        // The return of c_str is null terminated and contiguous in C++11
+        if( memcpy(_stored_argv[arg_num], temp.c_str(), strlen(temp.c_str())+1) == nullptr)
+        {
+          if(NOISY)
+          {
+            printf("### handcar_cosim::OptionsStorage::_loadArgMatrix(), call failed, unable to memcpy options text for option %s.\n", temp.c_str());
+          }
+          return ARGV_MEMORY_ERROR;
+        }
+        else
+        {
+          ++arg_num;
+        }
+      }
+    }
+
+    return SUCCESS;
+  }
+
+
+public:
+  // The constructor that must be used when intending to use the set_simulator_parameter interface
+  OptionsStorage():
+    _flat_options(""),
+    _stored_argv(nullptr),
+    _stored_argc(0),
+    _options_map{
+      //The defaults for these values are set in initialize_simulator, not here. There entries are inert until as a result of a user command they are set to 'USED' for mIsUsed
+      {"g", {UNUSED, 'g', "", UNUSED, UNUSED, 0, ""}}, // if present, enable pc histogram report
+      {"l", {UNUSED, 'l', "", UNUSED, UNUSED, 0, ""}}, // if present, enable logging
+      {"p", {UNUSED, 'p', "", NEEDS_VAL, UNUSED, 0, ""}},// Value argument determines number of processors
+      {"m", {UNUSED, 'm', "", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is interpreted as a memory configuration 
+      {"pc", {UNUSED, '0', "pc", NEEDS_VAL, UNUSED, 0, ""}}, // Value argument overrides the ELF entry point
+      {"hartids", {UNUSED, '0', "hartids", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is used to explicitly set the hartids
+      {"ic", {UNUSED, '0', "ic", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is used to configure the instruction cache model
+      {"dc", {UNUSED, '0', "dc", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is used to configure the data cache model
+      {"l2", {UNUSED, '0', "l2", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is used to configure the l2 cache model
+      {"log-cache-miss", {UNUSED, '0', "log-cache-miss", UNUSED, UNUSED, 0, ""}}, // if present, enable logging of estimated cache misses
+      {"varch", {UNUSED, '0', "varch", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is used to configure the RISC-V Vector uArch string
+      //
+      //WARNING, IT'S NOT A GREAT IDEA TO PLAY WITH THESE FOLLOWING OPTIONS UNLESS YOU KNOW WHAT YOU'RE DOING
+      //
+      {"isa", {UNUSED, '0', "isa", UNUSED, NEEDS_PATH, 0, ""}}, // Path argument is used to set the RISC-V ISA string
+      {"d", {UNUSED, 'd', "", UNUSED, UNUSED, 0, ""}},// if present, enable debug human-interactive mode
+      {"H", {UNUSED, 'h', "", UNUSED, UNUSED, 0, ""}}, // if present starts the simulator halted, meant to facilitate the connection of an external debugger
+      //{"rbb-port", {UNUSED, '0', "rbb-port", NEEDS_VAL, UNUSED, 0, ""}}, // Value argument is interpreted as the port for Remote Bit Bang
+      {"device", {UNUSED, '0', "device", UNUSED, NEEDS_PATH, 0, ""}}, // Path arguement is forwarded to device parser
+//      {"extension", {UNUSED, '0', "extension", UNUSED, NEEDS_PATH, 0, ""}}, // Specify RoCC extension
+      {"dump-dts", {UNUSED, '0', "dump-dts", UNUSED, UNUSED, 0, ""}}, // dump the device tree string and quit
+      {"disable-dtb", {UNUSED, '0', "disable-dtb", UNUSED, UNUSED, 0, ""}}, // don't write the device tree blob into memory
+      {"extlib", {UNUSED, '0', "extlib", UNUSED, NEEDS_PATH, 0, ""}}, // Shared library to load (Spike feature)
+      {"dm-progsize", {UNUSED, '0', "dm-progsize", NEEDS_VAL, UNUSED, 0, ""}}, //"progsize" for the debug module
+      {"dm-sba", {UNUSED, '0', "dm-sba", NEEDS_VAL, UNUSED, 0, ""}}, // Debug bus master supports up to <bits> wide accesses
+      {"dm-auth", {UNUSED, '0', "dm-auth", UNUSED, UNUSED, 0, ""}}, // Debug module requires debugger to authenticate
+      {"dmi-rti", {UNUSED, '0', "dmi-rti", NEEDS_VAL, UNUSED, 0, ""}}, // Number of run-test/idle cycles required for a dmi access
+      {"dm-abstract-rti", {UNUSED, '0', "dmi-abstract-rti", NEEDS_VAL, UNUSED, 0, ""}}, // Number of run-test/idle cycles required for an abstract command to execute
+      {"dm-no-hasel", {UNUSED, '0', "dm-no-hasel", UNUSED, UNUSED, 0, ""}}, // debug module supports hasel
+      {"dm-no-abstract-csr", {UNUSED, '0', "dm-no-abstract-csr", UNUSED, UNUSED, 0, ""}}, // debug module wont support abstract to authenticate 
+      {"dm-no-halt-groups", {UNUSED, '0', "dm-no-halt-groups", UNUSED, UNUSED, 0, ""}}, // debug module wont support halt groups 
+      {"h", {UNUSED, 'h', "", UNUSED, UNUSED, 0, ""}} // display help and quit.
+    },
+    _token_vector()
+  {
+    _stored_argc = 2;
+    _stored_argv = (char **)malloc(_stored_argc * sizeof(char*));
+    _allocateDummyOptions();
+  } 
+
+
+  // One and done mode. Spike orignal code is in charge of options validation. Not meant to be used with set_simulator_parameter 
+  OptionsStorage(const char* options):
+    _flat_options((options == nullptr) ? "" : options),
+    _stored_argv(nullptr),
+    _stored_argc(0),
+    _options_map{},
+    _token_vector()
+  {
+    _unpackFlatOptions();
+
+    if(NOISY)
+    {
+      for(auto token : _token_vector)
+      {
+        printf("token: %s\n", token.c_str());
+      }
+    }
+
+    if(_token_vector.size() > 0)
+    {
+      // Allocate argv
+      _stored_argc = _token_vector.size() + 2;
+      _stored_argv = (char **)malloc(_stored_argc * sizeof(char*));
+      _allocateDummyOptions();
+  
+      for(int arg_num = 1; arg_num < (_stored_argc-1); ++arg_num)
+      {
+        _stored_argv[arg_num] = (char*)malloc(ARGV_ELEMENT_BUFFER_SIZE * sizeof(char));  
+        memcpy(_stored_argv[arg_num], _token_vector.at(arg_num - 1).c_str() , strlen(_token_vector.at(arg_num - 1).c_str())+1);
+      }
+    }
+    else
+    {
+      _stored_argc = 2;
+      _stored_argv = (char **)malloc(_stored_argc * sizeof(char*));
+      _allocateDummyOptions();
+    }
+  } 
+
+
+  ~OptionsStorage()
+  {
+    for(int arg_num = 0; arg_num < _stored_argc; ++arg_num)
+    {
+      free(_stored_argv[arg_num]);
+      _stored_argv[arg_num] = nullptr;
+    }
+
+    free(_stored_argv);
+    _stored_argv = nullptr;    
+  }
 
-static unsigned long atoul_nonzero_safe(const char* s)
-{
-  auto res = atoul_safe(s);
-  if (!res)
-    help();
-  return res;
-}
 
-int main(int argc, char** argv)
+  char** exposeStoredArgv()
+  {
+    return _stored_argv;
+  }
+
+
+  int exposeStoredArgc()
+  {
+    return _stored_argc;
+  } 
+
+
+  // These can't be methods of OptionsStorage, but they need access to OptionsStorage private that ought not be more widely exposed.
+  friend void initialize_simulator(const char* options);
+  friend int set_simulator_parameter(const char* name, const uint64_t* pValue, const char* path);
+
+};
+OptionsStorage* _pOptionsStorage;
+
+bool isa_rv32;  // true if simulator configured (via isa cmdline option) as 32-bits (RV32)
+bool isa_D;     // true if double-precision floating pt extension configured in
+
+void initialize_simulator(const char* options)
 {
+  // Hopefully the user has called set_simulator_parameter a number of times before calling initialize_simulator, but handle the contingency if they didn't.
+  if(_pOptionsStorage == nullptr)
+  {
+    if(options != nullptr)
+    {
+      _pOptionsStorage = new OptionsStorage(options);
+    }
+    else
+    {
+      _pOptionsStorage = new OptionsStorage();
+    }
+  }
+  else // The user called set_simulator_parameter earlier
+  {
+    // Read the options map into a reallocated argv holder.
+    int rcode = _pOptionsStorage->_resetArgMatrix();
+    if(rcode != 0)
+    {
+      if(NOISY)
+      {
+        printf("### handcar_cosim::OptionsStorage::_resetArgMatrix. OptionsStorage error code: %d, Cannot proceed.\n", rcode);
+      }
+      terminate_simulator();
+      return; // Leave early because options memory reallocation failed. 
+      
+    }
+    rcode = _pOptionsStorage->_loadArgMatrix();
+    if(rcode != 0)
+    {
+      if(NOISY)
+      {
+        printf("### handcar_cosim::OptionsStorage::_loadArgMatrix. OptionsStorage error code: %d, Cannot proceed.\n", rcode);
+      }
+      terminate_simulator();
+      return; // Leave early because options setting failed.
+    }
+  }
+
+  int argc = _pOptionsStorage->exposeStoredArgc();
+  char ** argv = _pOptionsStorage->exposeStoredArgv();
+
+  //Dump options
+  if(NOISY)
+  { 
+    printf("Received additional options: ");
+    for(int arg = 0; arg < argc; ++arg)
+    {
+     printf("%s, ", argv[arg]);
+    }
+    printf("\n");
+  }
+  
   bool debug = false;
   bool halted = false;
   bool histogram = false;
@@ -220,43 +547,20 @@ int main(int argc, char** argv)
   size_t nprocs = 1;
   const char* kernel = NULL;
   reg_t kernel_offset, kernel_size;
-  size_t initrd_size;
-  reg_t initrd_start = 0, initrd_end = 0;
   const char* bootargs = NULL;
   reg_t start_pc = reg_t(-1);
-  std::vector<std::pair<reg_t, mem_t*>> mems;
-  std::vector<std::pair<reg_t, abstract_device_t*>> plugin_devices;
-  std::unique_ptr<icache_sim_t> ic;
-  std::unique_ptr<dcache_sim_t> dc;
-  std::unique_ptr<cache_sim_t> l2;
   bool log_cache = false;
-  bool log_commits = false;
-  const char *log_path = nullptr;
-  std::vector<std::function<extension_t*()>> extensions;
-  const char* initrd = NULL;
+  bool auto_init_mem = false;
   const char* isa = DEFAULT_ISA;
   const char* priv = DEFAULT_PRIV;
   const char* varch = DEFAULT_VARCH;
-  const char* dtb_file = NULL;
-  uint16_t rbb_port = 0;
-  bool use_rbb = false;
   unsigned dmi_rti = 0;
-  debug_module_config_t dm_config = {
-    .progbufsize = 2,
-    .max_bus_master_bits = 0,
-    .require_authentication = false,
-    .abstract_rti = 0,
-    .support_hasel = true,
-    .support_abstract_csr_access = true,
-    .support_haltgroups = true,
-    .support_impebreak = true
-  };
   std::vector<int> hartids;
-
+ 
   auto const hartids_parser = [&](const char *s) {
     std::string const str(s);
     std::stringstream stream(str);
-
+ 
     int n;
     while (stream >> n)
     {
@@ -265,79 +569,27 @@ int main(int argc, char** argv)
     }
   };
 
-  auto const device_parser = [&plugin_devices](const char *s) {
-    const std::string str(s);
-    std::istringstream stream(str);
-
-    // We are parsing a string like name,base,args.
-
-    // Parse the name, which is simply all of the characters leading up to the
-    // first comma. The validity of the plugin name will be checked later.
-    std::string name;
-    std::getline(stream, name, ',');
-    if (name.empty()) {
-      throw std::runtime_error("Plugin name is empty.");
-    }
-
-    // Parse the base address. First, get all of the characters up to the next
-    // comma (or up to the end of the string if there is no comma). Then try to
-    // parse that string as an integer according to the rules of strtoull. It
-    // could be in decimal, hex, or octal. Fail if we were able to parse a
-    // number but there were garbage characters after the valid number. We must
-    // consume the entire string between the commas.
-    std::string base_str;
-    std::getline(stream, base_str, ',');
-    if (base_str.empty()) {
-      throw std::runtime_error("Device base address is empty.");
-    }
-    char* end;
-    reg_t base = static_cast<reg_t>(strtoull(base_str.c_str(), &end, 0));
-    if (end != &*base_str.cend()) {
-      throw std::runtime_error("Error parsing device base address.");
-    }
-
-    // The remainder of the string is the arguments. We could use getline, but
-    // that could ignore newline characters in the arguments. That should be
-    // rare and discouraged, but handle it here anyway with this weird in_avail
-    // technique. The arguments are optional, so if there were no arguments
-    // specified we could end up with an empty string here. That's okay.
-    auto avail = stream.rdbuf()->in_avail();
-    std::string args(avail, '\0');
-    stream.readsome(&args[0], avail);
-
-    plugin_devices.emplace_back(base, new mmio_plugin_device_t(name, args));
-  };
-
   option_parser_t parser;
-  parser.help(&suggest_help);
-  parser.option('h', "help", 0, [&](const char* s){help(0);});
   parser.option('d', 0, 0, [&](const char* s){debug = true;});
   parser.option('g', 0, 0, [&](const char* s){histogram = true;});
   parser.option('l', 0, 0, [&](const char* s){log = true;});
-#ifdef HAVE_BOOST_ASIO
-  parser.option('s', 0, 0, [&](const char* s){socket = true;});
-#endif
-  parser.option('p', 0, 1, [&](const char* s){nprocs = atoul_nonzero_safe(s);});
-  parser.option('m', 0, 1, [&](const char* s){mems = make_mems(s);});
+  parser.option('p', 0, 1, [&](const char* s){nprocs = atoi(s);});
   // I wanted to use --halted, but for some reason that doesn't work.
   parser.option('H', 0, 0, [&](const char* s){halted = true;});
-  parser.option(0, "rbb-port", 1, [&](const char* s){use_rbb = true; rbb_port = atoul_safe(s);});
   parser.option(0, "pc", 1, [&](const char* s){start_pc = strtoull(s, 0, 0);});
   parser.option(0, "hartids", 1, hartids_parser);
-  parser.option(0, "ic", 1, [&](const char* s){ic.reset(new icache_sim_t(s));});
-  parser.option(0, "dc", 1, [&](const char* s){dc.reset(new dcache_sim_t(s));});
-  parser.option(0, "l2", 1, [&](const char* s){l2.reset(cache_sim_t::construct(s, "L2$"));});
+  parser.option(0, "ic", 1, [&](const char* s){ic = new icache_sim_t(s);});
+  parser.option(0, "dc", 1, [&](const char* s){dc = new dcache_sim_t(s);});
+  parser.option(0, "l2", 1, [&](const char* s){l2 = cache_sim_t::construct(s, "L2$");});
   parser.option(0, "log-cache-miss", 0, [&](const char* s){log_cache = true;});
+  parser.option(0, "auto-init-mem", 0, [&](const char* s){auto_init_mem = true;});
   parser.option(0, "isa", 1, [&](const char* s){isa = s;});
   parser.option(0, "priv", 1, [&](const char* s){priv = s;});
   parser.option(0, "varch", 1, [&](const char* s){varch = s;});
-  parser.option(0, "device", 1, device_parser);
-  parser.option(0, "extension", 1, [&](const char* s){extensions.push_back(find_extension(s));});
+  //parser.option(0, "extension", 1, [&](const char* s){extensions.push_back(find_extension(s));});
   parser.option(0, "dump-dts", 0, [&](const char *s){dump_dts = true;});
   parser.option(0, "disable-dtb", 0, [&](const char *s){dtb_enabled = false;});
-  parser.option(0, "dtb", 1, [&](const char *s){dtb_file = s;});
   parser.option(0, "kernel", 1, [&](const char* s){kernel = s;});
-  parser.option(0, "initrd", 1, [&](const char* s){initrd = s;});
   parser.option(0, "bootargs", 1, [&](const char* s){bootargs = s;});
   parser.option(0, "real-time-clint", 0, [&](const char *s){real_time_clint = true;});
   parser.option(0, "extlib", 1, [&](const char *s){
@@ -347,28 +599,6 @@ int main(int argc, char** argv)
       exit(-1);
     }
   });
-  parser.option(0, "dm-progsize", 1,
-      [&](const char* s){dm_config.progbufsize = atoul_safe(s);});
-  parser.option(0, "dm-no-impebreak", 0,
-      [&](const char* s){dm_config.support_impebreak = false;});
-  parser.option(0, "dm-sba", 1,
-      [&](const char* s){dm_config.max_bus_master_bits = atoul_safe(s);});
-  parser.option(0, "dm-auth", 0,
-      [&](const char* s){dm_config.require_authentication = true;});
-  parser.option(0, "dmi-rti", 1,
-      [&](const char* s){dmi_rti = atoul_safe(s);});
-  parser.option(0, "dm-abstract-rti", 1,
-      [&](const char* s){dm_config.abstract_rti = atoul_safe(s);});
-  parser.option(0, "dm-no-hasel", 0,
-      [&](const char* s){dm_config.support_hasel = false;});
-  parser.option(0, "dm-no-abstract-csr", 0,
-      [&](const char* s){dm_config.support_abstract_csr_access = false;});
-  parser.option(0, "dm-no-halt-groups", 0,
-      [&](const char* s){dm_config.support_haltgroups = false;});
-  parser.option(0, "log-commits", 0,
-                [&](const char* s){log_commits = true;});
-  parser.option(0, "log", 1,
-                [&](const char* s){log_path = s;});
   FILE *cmd_file = NULL;
   parser.option(0, "debug-cmd", 1, [&](const char* s){
      if ((cmd_file = fopen(s, "r"))==NULL) {
@@ -378,105 +608,710 @@ int main(int argc, char** argv)
   });
 
   auto argv1 = parser.parse(argv);
-  std::vector<std::string> htif_args(argv1, (const char*const*)argv + argc);
-  if (mems.empty())
-    mems = make_mems("2048");
 
-  if (!*argv1)
-    help();
+  std::string isa_str = isa;
+  isa_rv32 = isa_str.find("RV32") != std::string::npos;
+  isa_D = (isa_str.find("F") != std::string::npos) && (isa_str.find("D") != std::string::npos);
 
-  if (kernel && check_file_exists(kernel)) {
-    kernel_size = get_file_size(kernel);
-    if (isa[2] == '6' && isa[3] == '4')
-      kernel_offset = 0x200000;
-    else
-      kernel_offset = 0x400000;
-    for (auto& m : mems) {
-      if (kernel_size && (kernel_offset + kernel_size) < m.second->size()) {
-         read_file_bytes(kernel, 0, m.second, kernel_offset, kernel_size);
-         break;
-      }
-    }
+  _pSimulatorTopLevel = new simlib_t(isa, priv, varch, nprocs, halted, bootargs, start_pc, hartids, auto_init_mem, cmd_file);
+  _pSimulatorTopLevel->set_dtb_enabled(dtb_enabled);
+ 
+  if (ic && l2) ic->set_miss_handler(&*l2);
+  if (dc && l2) dc->set_miss_handler(&*l2);
+  if (ic) ic->set_log(log_cache);
+  if (dc) dc->set_log(log_cache);
+  for (size_t i = 0; i < nprocs; i++)
+  {
+  if (ic) _pSimulatorTopLevel->get_core(i)->get_mmu()->register_memtracer(&*ic);
+  if (dc) _pSimulatorTopLevel->get_core(i)->get_mmu()->register_memtracer(&*dc);
   }
+ 
+  _pSimulatorTopLevel->set_log(log);
+  _pSimulatorTopLevel->set_histogram(histogram);
 
-  if (initrd && check_file_exists(initrd)) {
-    initrd_size = get_file_size(initrd);
-    for (auto& m : mems) {
-      if (initrd_size && (initrd_size + 0x1000) < m.second->size()) {
-         initrd_end = m.first + m.second->size() - 0x1000;
-         initrd_start = initrd_end - initrd_size;
-         read_file_bytes(initrd, 0, m.second, initrd_start - m.first, initrd_size);
-         break;
-      }
+  argc=0;
+  argv=nullptr;
+}
+
+
+void terminate_simulator()
+{
+  // NOTE: the if guards around all the delete statements are needed because it is possible that some of these are not allocated when terminate_simulator is called, since it is an external API function.
+  if(_pSimulatorTopLevel != nullptr)
+  {
+    delete _pSimulatorTopLevel;
+    _pSimulatorTopLevel = nullptr;
+  }
+
+  if(_pOptionsStorage != nullptr)
+  { 
+    delete _pOptionsStorage;
+    _pOptionsStorage = nullptr;
+  }
+
+  // originally handled by smart pointers, but we have to delete these manually now.
+  if(ic != nullptr)
+  {
+    delete ic;
+    ic = nullptr;
+  }
+
+  if(dc != nullptr)
+  {
+    delete dc;
+    dc = nullptr;
+  }
+
+  if(l2 != nullptr)
+  {
+    delete l2;
+    l2 = nullptr;
+  }
+}
+
+
+void clearSimulatorLeaveOptions()
+{
+  if(_pSimulatorTopLevel != nullptr)
+  {
+    delete _pSimulatorTopLevel;
+    _pSimulatorTopLevel = nullptr;
+  }
+
+  // originally handled by smart pointers, but we have to delete these manually now.
+  if(ic != nullptr)
+  {
+    delete ic;
+    ic = nullptr;
+  }
+
+  if(dc != nullptr)
+  {
+    delete dc;
+    dc = nullptr;
+  }
+
+  if(l2 != nullptr)
+  {
+    delete l2;
+    l2 = nullptr;
+  }
+}
+
+
+int set_simulator_parameter(const char* name, const uint64_t* pValue, const char* path)
+{
+  if(_pOptionsStorage == nullptr)
+  {
+     _pOptionsStorage = new OptionsStorage();
+  }
+
+  // This call just modifies the options map so that the next time initialize_simulator is called, the simulator sees the intended options to load.
+  int rcode = _pOptionsStorage->_rejectOrEnroll(name, pValue, path);
+
+  // end early if something didn't work
+  if(rcode != 0)
+  {
+    if(NOISY)
+    {
+      printf("### handcar_cosim::set_simulator_parameter(), call failed with error code: %d\n", rcode);
     }
+    return rcode;
   }
 
-#ifdef HAVE_BOOST_ASIO
-  boost::asio::io_service *io_service_ptr = NULL; // needed for socket command interface option -s
-  boost::asio::ip::tcp::acceptor *acceptor_ptr = NULL;
-  if (socket) {  // if command line option -s is set
-     try
-     { // create socket server
-       using boost::asio::ip::tcp;
-       io_service_ptr = new boost::asio::io_service;
-       acceptor_ptr = new tcp::acceptor(*io_service_ptr, tcp::endpoint(tcp::v4(), 0));
-       // aceptor is created passing argument port=0, so O.S. will choose a free port
-       std::string name = boost::asio::ip::host_name();
-       std::cout << "Listening for debug commands on " << name.substr(0,name.find('.'))
-                 << " port " << acceptor_ptr->local_endpoint().port() << " ." << std::endl;
-       // at the end, add space and some other character for convenience of javascript .split(" ")
-     }
-     catch (std::exception& e)
+  // Reinitialization has been seen not to work, so we will indicate to the user that this is not ok
+  if(_pSimulatorTopLevel != nullptr){
+    return 10;
+  }
+
+  return 0;
+}
+
+
+int simulator_load_elf(int target_id, const char* elf_path)
+{
+  int rcode = 1;
+  if(_pSimulatorTopLevel != nullptr)
+  {
+     // checks only that a dummy entry has been made for the elf filepath to be stored. 
+     rcode = _pSimulatorTopLevel->load_program_now(elf_path);
+  }
+  else 
+  {
+     if(NOISY)
      {
-       std::cerr << e.what() << std::endl;
-       exit(-1);
+       printf("### handcar_cosim::simulator_load_elf(...), simulator not initialized before simulator_load_elf(...) called.\n");
      }
   }
-#endif
 
-  sim_t s(isa, priv, varch, nprocs, halted, real_time_clint,
-      initrd_start, initrd_end, bootargs, start_pc, mems, plugin_devices, htif_args,
-      std::move(hartids), dm_config, log_path, dtb_enabled, dtb_file,
-#ifdef HAVE_BOOST_ASIO
-      io_service_ptr, acceptor_ptr,
-#endif
-      cmd_file);
-  std::unique_ptr<remote_bitbang_t> remote_bitbang((remote_bitbang_t *) NULL);
-  std::unique_ptr<jtag_dtm_t> jtag_dtm(
-      new jtag_dtm_t(&s.debug_module, dmi_rti));
-  if (use_rbb) {
-    remote_bitbang.reset(new remote_bitbang_t(rbb_port, &(*jtag_dtm)));
-    s.set_remote_bitbang(&(*remote_bitbang));
+  //dump_memory("./memdump.txt");
+
+  return rcode;
+}
+
+
+void dump_memory(const char* file_to_create)
+{
+  //if(_pMemories != nullptr)
+  //{
+  //  // dump the dense memory model
+  //  for(auto& mem: *_pMemories)
+  //  {
+  //    const size_t base_address = mem.first;
+  //    const uint8_t* data = reinterpret_cast<uint8_t*>( mem.second->contents());
+  //    const size_t total_size = mem.second->size();
+  //    if(total_size % size_t(8))
+  //    {
+  //      printf("### handcar_cosim::dump_memory, size of memory region is not a multiple of 8 bytes!");
+  //      return;
+  //    }
+
+  //    std::fstream dump(std::string(file_to_create), std::fstream::out);
+  //    if(!dump)
+  //    { 
+  //      printf("### handcar_cosim::dump_memory, can't open memory dump file!");
+  //      return;
+  //    }
+
+  //    for(size_t byte_idx = 0; byte_idx < total_size; byte_idx += size_t(8))
+  //    {
+  //      uint64_t chunk_buffer = ((uint64_t(data[byte_idx]) & 0xFF ) << 56ull) | ((uint64_t(data[byte_idx + 1]) & 0xFF) << 48ull) | ((uint64_t(data[byte_idx + 2]) & 0xFF) << 40ull) | ((uint64_t(data[byte_idx + 3]) & 0xFF) << 32ull) | ((uint64_t(data[byte_idx + 4]) & 0XFF) << 24ull) | ((uint64_t(data[byte_idx + 5]) & 0xFF) << 16ull) | ((uint64_t(data[byte_idx + 6]) & 0xFF) << 8ull) | uint64_t(data[byte_idx + 7]); 
+
+  //      dump << std::hex << std::setfill('0') << std::setw(16) << byte_idx + base_address << ": " << std::setw(16) << chunk_buffer << std::endl;
+  //    }
+  //  }
+
+    // Now dump the sparse memory model
+     std::fstream dump2(std::string("./sparsedump.txt"), std::fstream::out);
+    if(!dump2)
+    { 
+      printf("### handcar_cosim::dump_memory, can't open memory dump file!");
+      return;
+    }
+
+    _pSimulatorTopLevel->dump_sparse_memory(dump2);    
+  //}
+}
+
+
+int step_simulator(int target_id, int num_steps, int stx_failed)
+{
+  return _pSimulatorTopLevel->step_simulator(target_id, num_steps, stx_failed);
+}
+
+
+int get_disassembly(const uint64_t* pc, char** opcode, char** disassembly)
+{
+  return _pSimulatorTopLevel->get_disassembly(0, pc, opcode, disassembly);
+}
+
+
+int get_disassembly_for_target(int target_id, const uint64_t* pc, char** opcode, char** disassembly)
+{
+  return _pSimulatorTopLevel->get_disassembly(target_id, pc, opcode, disassembly);
+}
+
+
+int get_simulator_version(char* version)
+{
+  const char version_string[] = "0.0\0";
+  if(version == nullptr)
+  {
+    return 1;
+  }
+  if(sizeof(version_string) > sizeof(version))
+  {
+    printf("#### handcar_cosim::get_simulator_version, not enough room in 'version' string buffer");
+    return 1;
+  }
+
+  strcpy(version, version_string);   
+
+  return 0;
+}
+
+//NEW DEBUG
+int read_simulator_register(int target_id, const char* pRegName, uint8_t* pValue, int length)
+{
+  //Check that the pointers point to something
+  if(pRegName == nullptr || pValue == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
   }
 
-  if (dump_dts) {
-    printf("%s", s.get_dts());
-    return 0;
+  // Is the user asking to write to a register that actually exists? 
+  int status = 0;
+  uint8_t category = 0; // Four is not one of the admissible categories
+  uint64_t index = _pSimulatorTopLevel->get_csr_number(std::string(pRegName));
+  std::string temp_name = _pSimulatorTopLevel->get_csr_name(index);
+
+  // Check if this is any of the other types of register
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 1;
+    index = _pSimulatorTopLevel->get_xpr_number(std::string(pRegName));
+    temp_name = _pSimulatorTopLevel->get_xpr_name(index);
   }
 
-  if (ic && l2) ic->set_miss_handler(&*l2);
-  if (dc && l2) dc->set_miss_handler(&*l2);
-  if (ic) ic->set_log(log_cache);
-  if (dc) dc->set_log(log_cache);
-  for (size_t i = 0; i < nprocs; i++)
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 2;
+    index = _pSimulatorTopLevel->get_fpr_number(std::string(pRegName));
+    temp_name = _pSimulatorTopLevel->get_fpr_name(index);
+  }
+
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 3;
+    index = _pSimulatorTopLevel->get_vecr_number(std::string(pRegName));
+    temp_name = _pSimulatorTopLevel->get_vecr_name(index);
+  }
+
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 4; //fail category
+    status = 3;
+  }
+
+  //PC is a special case since its not directly writeable in Spike code
+  if(strcmp(pRegName, "PC") == 0 || strcmp(pRegName, "pc") == 0)
+  {
+    category = 5;
+    status = 0;
+  }
+
+  //privilege is internal register to force, should bypass CSR/register and access state of proc
+  if(strcmp(pRegName, "PRIVILEGE") == 0 || strcmp(pRegName, "privilege") == 0)
+  {
+    category = 6;
+    status = 0;
+  }
+
+  // Check the category of the register and try to obtain the name
+  uint32_t my_length = length;
+  switch(category)
+  {
+    case(0) : //CSR
+    {
+      status = _pSimulatorTopLevel->read_csr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), reinterpret_cast<uint64_t*>(pValue), &my_length);         
+      break;
+    }
+    case(1) : //XPR
+    {
+      status = _pSimulatorTopLevel->read_xpr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), reinterpret_cast<uint64_t*>(pValue), &my_length);         
+      break;
+    }
+    case(2) : //FPR
+    {
+      status = _pSimulatorTopLevel->read_fpr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), pValue, &my_length);         
+      break;
+    }
+    case(3) : //VR
+    {
+      status = _pSimulatorTopLevel->read_vecr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), pValue, &my_length);         
+      break;
+    }  
+    case(5) : //PC
+    {
+      status = _pSimulatorTopLevel->get_pc_api(static_cast<int>(target_id), reinterpret_cast<uint8_t*>(pValue), std::string(pRegName), my_length) ? int(0) : int(3);     
+      break;
+    }
+    case(6) : //privilege
+    {
+      status = _pSimulatorTopLevel->get_privilege_api(static_cast<uint64_t>(target_id), reinterpret_cast<uint64_t*>(pValue)) ? int(0) : int(3);
+      break;
+    }
+    default:
+      status = 3; // failure
+  }
+
+  return status;
+}
+
+
+int partial_read_large_register(int target_id, const char* pRegName, uint8_t* pValue, uint32_t length, uint32_t offset)
+{
+  //Check that the pointers point to something
+  if(pRegName == nullptr || pValue == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  // Is the user asking to write to a register that actually exists? 
+  int status = 0;
+  uint8_t category = 3; // Four is not one of the admissible categories
+  uint64_t index = _pSimulatorTopLevel->get_vecr_number(std::string(pRegName));
+  std::string temp_name = _pSimulatorTopLevel->get_vecr_name(index);
+
+  // Check if this is any of the other types of register
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 4; //fail category
+    status = 3;
+  }
+
+  // Check the category of the register and try to obtain the name
+  switch(category)
+  {
+    case(3) : //VR
+    {
+      status = _pSimulatorTopLevel->partial_read_vecr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), pValue, length, offset);         
+      break;
+    }  
+    default:
+      status = 3; // failure
+  }
+
+  return status;
+}
+
+
+int partial_write_large_register(int target_id, const char* pRegName, const uint8_t* pValue, uint32_t length, uint32_t offset)
+{
+  //Check that the pointers point to something
+  if(pRegName == nullptr || pValue == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  // Is the user asking to write to a register that actually exists? 
+  int status = 0;
+  uint8_t category = 3; // Four is not one of the admissible categories
+  uint64_t index = _pSimulatorTopLevel->get_vecr_number(std::string(pRegName));
+  std::string temp_name = _pSimulatorTopLevel->get_vecr_name(index);
+
+  // Check if this is any of the other types of register
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 4; //fail category
+    status = 3;
+  }
+
+  // Check the category of the register and try to obtain the name
+  switch(category)
+  {
+    case(3) : //VR
+    {
+      status = _pSimulatorTopLevel->partial_write_vecr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), pValue, length, offset);         
+      break;
+    }  
+    default:
+      status = 3; // failure
+  }
+
+  return status;
+}
+
+
+int write_simulator_register(int target_id, const char* pRegName, const uint8_t* data, int length)
+{
+  //Check that the pointers point to something
+  if(pRegName == nullptr || data == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  // Is the user asking to write to a register that actually exists? 
+  int status = 0;
+  uint8_t category = 0; // Four is not one of the admissible categories
+  uint64_t index = _pSimulatorTopLevel->get_csr_number(std::string(pRegName));
+  std::string temp_name = _pSimulatorTopLevel->get_csr_name(index);
+
+  // Check if this is any of the other types of register
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 1;
+    index = _pSimulatorTopLevel->get_xpr_number(std::string(pRegName));
+    temp_name = _pSimulatorTopLevel->get_xpr_name(index);
+  }
+
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 2;
+    index = _pSimulatorTopLevel->get_fpr_number(std::string(pRegName));
+    temp_name = _pSimulatorTopLevel->get_fpr_name(index);
+  }
+
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 3;
+    index = _pSimulatorTopLevel->get_vecr_number(std::string(pRegName));
+    temp_name = _pSimulatorTopLevel->get_vecr_name(index);
+  }
+
+  if(temp_name.find("unknown") != std::string::npos)
+  {
+    category = 4; //fail category
+    status = 3;
+  }
+
+  //PC is a special case since its not directly writeable in Spike code
+  if(strcmp(pRegName, "PC") == 0 || strcmp(pRegName, "pc") == 0)
   {
-    if (ic) s.get_core(i)->get_mmu()->register_memtracer(&*ic);
-    if (dc) s.get_core(i)->get_mmu()->register_memtracer(&*dc);
-    for (auto e : extensions)
-      s.get_core(i)->register_extension(e());
+    category = 5;
+    status = 0;
   }
 
-  s.set_debug(debug);
-  s.configure_log(log, log_commits);
-  s.set_histogram(histogram);
+  //privilege is internal register to force, should bypass CSR/register and access state of proc
+  if(strcmp(pRegName, "PRIVILEGE") == 0 || strcmp(pRegName, "privilege") == 0)
+  {
+    category = 6;
+    status = 0;
+  }
 
-  auto return_code = s.run();
+  // Check the category of the register and try to obtain the name
+  uint32_t my_length = static_cast<uint32_t>(length);
+  switch(category)
+  {
+    case(0) : //CSR
+    {
+      status = _pSimulatorTopLevel->write_csr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), reinterpret_cast<const uint64_t*>(data), my_length);         
+      break;
+    }
+    case(1) : //XPR
+    {
+      status = _pSimulatorTopLevel->write_xpr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), reinterpret_cast<const uint64_t*>(data), my_length);         
+      break;
+    }
+    case(2) : //FPR
+    {
+      status = _pSimulatorTopLevel->write_fpr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), data, my_length);         
+      break;
+    }
+    case(3) : //VR
+    {
+      status = _pSimulatorTopLevel->write_vecr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), data, my_length);         
+      break;
+    }  
+    case(5) : //PC
+    {
+      status = _pSimulatorTopLevel->set_pc_api(static_cast<int>(target_id), std::string(pRegName), reinterpret_cast<const uint8_t*>(data), my_length) ? int(0) : int(3);     
+      break;
+    }
+    case(6) : //privilege
+    {
+      status = _pSimulatorTopLevel->set_privilege_api(static_cast<int>(target_id), reinterpret_cast<const uint64_t*>(data)) ? int(0) : int(3);
+      break;
+    }
+    default:
+      status = 3; // failure
+  }
 
-  for (auto& mem : mems)
-    delete mem.second;
+  return status;
+}
 
-  for (auto& plugin_device : plugin_devices)
-    delete plugin_device.second;
+int read_simulator_memory(int target_id, const uint64_t* addr, int length, uint8_t* data)
+{ 
+  // check that the pointers point to something 
+  if(addr == nullptr || data == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  // check that the length argument is not out of regulation
+  if(length < 0 || length > 8)
+  {
+    return 2;
+  }
+
+  // the checks such as they are have passed, perform the read
+  _pSimulatorTopLevel->sparse_read_partially_initialized(static_cast<reg_t>(*addr), static_cast<size_t>(length), data);
+
+  return 0;
+}
+
+int write_simulator_memory(int target_id, const uint64_t* addr, int length, const uint8_t* data)
+{ 
+  // check that the pointers point to something 
+  if(addr == nullptr || data == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  // check that the length argument is not out of regulation
+  if(length < 0)
+  {
+    return 2;
+  }
+
+  if(_pSimulatorTopLevel->sparse_is_pa_initialized(static_cast<reg_t>(*addr), static_cast<size_t>(length)))
+  {
+    _pSimulatorTopLevel->sparse_write(static_cast<reg_t>(*addr), data, static_cast<size_t>(length));
+  }
+  else
+  {
+    _pSimulatorTopLevel->initialize_multiword(static_cast<reg_t>(*addr), static_cast<size_t>(length), data);
+  }
+
+  return 0;
+}
+
+int initialize_simulator_memory(int target_id, const uint64_t* addr, int length, uint64_t data)
+{ 
+  // check that the pointers point to something 
+  if(addr == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  // check that the length argument is not out of regulation
+  if(length < 0 || length > 8)
+  {
+    return 2;
+  }
+
+  // the checks such as they are have passed, perform the read
+  _pSimulatorTopLevel->sparse_initialize_pa(static_cast<reg_t>(*addr), data, static_cast<size_t>(length));
+
+  return 0;
+}
+
+int translate_virtual_address(int target_id, const uint64_t* vaddr, int intent, uint64_t* paddr, uint64_t* memattrs)
+{
+  if(vaddr == nullptr || paddr == nullptr || memattrs == nullptr || _pSimulatorTopLevel == nullptr)
+    return 1;
 
-  return return_code;
+  return _pSimulatorTopLevel->translate_virtual_address_api(target_id, vaddr, intent, paddr, memattrs);
 }
+
+bool is_gpr(std::string &rname) {
+  uint64_t index = _pSimulatorTopLevel->get_xpr_number(rname);
+  std::string temp_name = _pSimulatorTopLevel->get_xpr_name(index);
+
+  return (temp_name.find("unknown") == std::string::npos);
+}
+
+int register_size(std::string &rname) {
+  int length = isa_rv32 ? 4 : 8;  // set the 'default' register length based on the ISA (RV32 vs RV64)
+
+  if (rname == std::string("PC")) {
+    length = 8;  // if the register is the PC then set the length to 8...
+  } else {
+    uint64_t index = _pSimulatorTopLevel->get_fpr_number(rname);
+    std::string temp_name = _pSimulatorTopLevel->get_fpr_name(index);
+
+    if (temp_name == "unknown-fpr") {
+      // not a floating pt register...
+    } else {
+      if ( isa_D )   // if double-precision floating pt extension present
+        length = 8;  //   then floating pt registers are widened to 64 bits
+    }
+  }
+
+  return length;
+}
+
+int read_simulator_register_fpix(uint32_t target_id, const char* registerName, uint64_t* pValue, uint64_t* mask)
+{
+  if(registerName == nullptr || pValue == nullptr || mask == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  //const uint64_t buffer = (pValue & mask); // Are we masked on or masked off? Need to check what the convention of the bitmask is here.
+  std::string nameForReference(registerName);
+
+  int length = register_size(nameForReference);
+  
+  if(nameForReference != std::string("PC"))
+  {
+    // Is the user asking to read a register that actually exists? 
+    int status = 0;
+    uint8_t category = 0; // Four is not one of the admissible categories
+    uint64_t index = _pSimulatorTopLevel->get_csr_number(nameForReference);
+    std::string temp_name = _pSimulatorTopLevel->get_csr_name(index);
+
+    // Check if this is any of the other types of register
+    if(temp_name.find("unknown") != std::string::npos)
+    {
+      category = 1;
+      index = _pSimulatorTopLevel->get_xpr_number(nameForReference);
+      temp_name = _pSimulatorTopLevel->get_xpr_name(index);
+    }
+
+    if(temp_name.find("unknown") != std::string::npos)
+    {
+      category = 2;
+      index = _pSimulatorTopLevel->get_fpr_number(std::string(nameForReference));
+      temp_name = _pSimulatorTopLevel->get_fpr_name(index);
+    }
+
+    if(temp_name.find("unknown") != std::string::npos)
+    {
+      category = 4; //fail category
+      status = 3;
+    }
+        
+    // Check the category of the register and try to obtain the name
+    uint32_t my_length = static_cast<uint32_t>(length);
+
+    switch(category)
+    {
+      case(0) : //CSR
+      {
+        status = _pSimulatorTopLevel->read_csr(static_cast<uint32_t>(target_id), static_cast<uint64_t>(index), pValue, &my_length);         
+        break;
+      }
+      case(1) : //XPR
+      {
+        status = _pSimulatorTopLevel->read_xpr(static_cast<uint32_t>(target_id), static_cast<uint64_t>(index), pValue, &my_length);         
+        break;
+      }
+      case(2) : //FPR
+      {
+        uint8_t fp_buff[16] = {0};
+        uint32_t fp_buff_size = sizeof(fp_buff);
+        status = _pSimulatorTopLevel->read_fpr(static_cast<uint64_t>(target_id), static_cast<uint64_t>(index), fp_buff, &fp_buff_size);         
+        memcpy(pValue, fp_buff, my_length);
+        break;
+      }
+      // Fpix API is not suited for getting 128 bit values like from the vector registers and floating point registers yet.
+      // load the data into an appropriate buffer and then copy the first 64 bits to the user's buffer 
+      default:
+        status = 3; // failure
+    }
+
+    *mask = 0xFFFFFFFFFFFFFFFFul; 
+
+    return status;
+  }
+  else
+  {
+    int status = (_pSimulatorTopLevel->get_pc_api(static_cast<int>(target_id), reinterpret_cast<uint8_t*>(pValue), nameForReference, length) ? int(0) : int(3));     
+  
+    *mask = 0xFFFFFFFFFFFFFFFFul;
+    return status;
+  }
+}
+
+
+int write_simulator_register_fpix(uint32_t target_id, const char* registerName, uint64_t value, uint64_t mask)
+{
+  if(registerName == nullptr || _pSimulatorTopLevel == nullptr)
+  {
+    return 1;
+  }
+
+  std::string nameForReference(registerName);
+
+  //int length = 8;
+  int length = register_size(nameForReference);
+
+
+  uint64_t rval = value;
+
+  if ( is_gpr(nameForReference) && (length == 4) ) {
+    if ( (rval & 0x80000000) != 0)
+      rval |= 0xffffffff00000000ull;
+  }
+      
+  const uint64_t buffer = rval;     // Are we masked on or masked off?
+                                    // Need to check what the convention of the bitmask is here.
+  
+
+  //std::cout << "[write_simulator_register_fpix] " << nameForReference << " = !!!" << std::hex << rval << std::dec << "!!!" << std::endl;
+
+  return write_simulator_register(static_cast<int>(target_id), registerName, reinterpret_cast<const uint8_t*>(&buffer), length);
+}
+
+
